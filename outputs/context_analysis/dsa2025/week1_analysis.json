[
    {
        "topic_description": "Tìm hiểu về hai kiểu dữ liệu cơ bản: Stack và Queue. Chủ đề này bao gồm nguyên tắc LIFO và FIFO, cũng như các thao tác chủ yếu như push, pop, enqueue và dequeue. Học sinh sẽ có thể so sánh và phân biệt giữa hai loại cấu trúc dữ liệu này thông qua câu hỏi trắc nghiệm.",
        "output_with_context": {
            "question": "Nguyên tắc hoạt động của Stack là gì?",
            "answer": "LIFO (Last In First Out) - vào sau ra trước.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n| **In-place** | ✅ | ❌ | ✅ |\n| **Cache-friendly** | ✅ | ❌ | ⚠️ |\n\n#### 6.1. Khi nào dùng Quick Sort?\n\n**Nên dùng:**\n- ✅ Mảng trong RAM (in-memory sorting)\n- ✅ Cần sorting nhanh nhất average case\n- ✅ Bộ nhớ hạn chế\n- ✅ Random access data (array)\n- ✅ Không cần stable sort\n\n**Không nên dùng:**\n- ❌ Cần đảm bảo O(n log n) worst case\n- ❌ Cần stable sorting\n- ❌ Linked list (Merge Sort tốt hơn)\n- ❌ Dữ liệu đã gần sắp xếp (trừ khi dùng random pivot)\n\n---\n\n### 7. Quick Sort trong thư viện chuẩn\n\n#### 7.1. Python's sorted() và sort()\n\nPython sử dụng **Timsort** (hybrid của Merge Sort và Insertion Sort), không phải Quick Sort, vì:\n- Stable sorting\n- Tốt với dữ liệu có pattern\n- Worst case O(n log n) đảm bảo\n\n#### 7.2. C++ std::sort()\n\nC++ sử dụng **Introsort** (Introspective Sort):\n- Bắt đầu với Quick Sort\n- Chuyển sang Heap Sort nếu đệ quy quá sâu (tránh O(n²))\n- Dùng Insertion Sort cho mảng nhỏ\n\n#### 7.3. Java's Arrays.sort()\n\n- **Primitive types:** Dual-Pivot Quick Sort\n- **Object types:** Timsort (stable)\n\n---\n\n## Priority Queue & Binary Heap\n\n### 1. Giới thiệu Priority Queue\n\n#### 1.1. Khái niệm\n\n**Priority Queue (Hàng đợi ưu tiên)** là một cấu trúc dữ liệu trừu tượng trong đó mỗi phần tử có một độ ưu tiên (priority) được gán cho nó. Phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào.\n\n**Khác với Queue thông thường:**\n- Queue thông thường: FIFO (First In First Out)\n- Priority Queue: Phần tử có priority cao nhất ra trước\n\n**Ví dụ thực tế:**\n- **Hệ thống cấp cứu:** Bệnh nhân nguy kịch được ưu tiên khám trước\n- **CPU Scheduling:** Process có priority cao được xử lý trước\n- **Dijkstra Algorithm:** Chọn đỉnh có khoảng cách nhỏ nhất\n- **A* Search:** Chọn node có f(n) nhỏ nhất\n- **Huffman Coding:** Xây dựng cây mã hóa\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Insert/Enqueue:** Thêm phần tử với priority\n**b) Extract-Max/Min:** Lấy và xóa phần tử có priority cao/thấp nhất\n**c) Peek/Top:** Xem phần tử có priority cao/thấp nhất\n**d) Change Priority:** Thay đổi priority của phần tử\n**e) Delete:** Xóa phần tử bất kỳ\n\n#### 1.3. Các cách cài đặt\n\n| Cài đặt | Insert | Extract-Max | Peek |\n|---------|--------|-------------|------|\n| Array (unsorted) | O(1) | O(n) | O(n) |\n| Array (sorted) | O(n) | O(1) | O(1) |\n| Linked List | O(n) | O(1) | O(1) |\n| **Binary Heap** | **O(log n)** | **O(log n)** | **O(1)** |\n| Fibonacci Heap | O(1) | O(log n) | O(1) |\n\n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n\n**Mối quan hệ:**\n- Stack và Queue là hai cấu trúc dữ liệu tuyến tính cơ bản có nguyên tắc hoạt động và ứng dụng khác nhau.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n**f) Size:** Trả về số lượng phần tử trong queue\n- Độ phức tạp: O(1)\n\n#### 2.3. Cài đặt Queue\n\n**Cách 1: Sử dụng mảng (Circular Queue)**\n\n```python\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = -1\n        self.rear = -1\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        if self.is_full():\n            raise Exception(\"Queue is full\")\n        \n        if self.front == -1:  # Queue rỗng\n            self.front = 0\n        \n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = item\n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.queue[self.front]\n        \n        if self.front == self.rear:  # Chỉ còn 1 phần tử\n            self.front = -1\n            self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue[self.front]\n    \n    def is_empty(self):\n        return self.front == -1\n    \n    def is_full(self):\n        return (self.rear + 1) % self.capacity == self.front\n    \n    def size(self):\n        return self.size_count\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass QueueLinkedList:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        new_node = Node(item)\n        \n        if self.rear is None:  # Queue rỗng\n            self.front = self.rear = new_node\n        else:\n            self.rear.next = new_node\n            self.rear = new_node\n        \n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.front.data\n        self.front = self.front.next\n        \n        if self.front is None:  # Queue trở nên rỗng\n            self.rear = None\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.front.data\n    \n    def is_empty(self):\n        return self.front is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 2.4. Các loại Queue đặc biệt\n\n**a) Deque (Double-ended Queue):**\nCho phép thêm và xóa phần tử ở cả hai đầu.\n\n```python\nfrom collections import deque\n\ndq = deque()\ndq.append(1)      # Thêm vào phải\ndq.appendleft(2)  # Thêm vào trái\ndq.pop()          # Xóa từ phải\ndq.popleft()      # Xóa từ trái\n```\n\n**b) Priority Queue (Hàng đợi ưu tiên):**\nMỗi phần tử có một độ ưu tiên, phần tử có độ ưu tiên cao nhất được xử lý trước.\n\n```python\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, item, priority):\n        heapq.heappush(self.heap, (priority, item))\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Priority Queue is empty\")\n        return heapq.heappop(self.heap)[1]\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 2.5. Ứng dụng của Queue\n\n**a) BFS (Breadth-First Search) trong đồ thị:**\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    \n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n\n**Mối quan hệ:**\n- Stack và Queue là hai cấu trúc dữ liệu tuyến tính cơ bản có nguyên tắc hoạt động và ứng dụng khác nhau.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return result\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\nprint(bfs(graph, 'A'))  # ['A', 'B', 'C', 'D', 'E', 'F']\n```\n\n**b) Quản lý tài nguyên chia sẻ:**\n- CPU scheduling\n- Disk scheduling\n- Printer queue\n\n**c) Xử lý bất đồng bộ:**\n- Message queue trong các hệ thống phân tán\n- Event handling trong GUI\n\n**d) Cache implementation:**\n- LRU (Least Recently Used) cache sử dụng kết hợp queue và hash map\n\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n```\n\n#### 2.6. So sánh Stack và Queue\n\n| Đặc điểm | Stack | Queue |\n|----------|-------|-------|\n| Nguyên tắc | LIFO | FIFO |\n| Thao tác chính | Push, Pop | Enqueue, Dequeue |\n| Truy cập | Chỉ ở đỉnh (top) | Ở đầu (front) và cuối (rear) |\n| Ứng dụng | Backtracking, Expression evaluation | BFS, Scheduling |\n| Cài đặt | Array, Linked List | Array (Circular), Linked List |\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n\n**Mối quan hệ:**\n- Stack và Queue là hai cấu trúc dữ liệu tuyến tính cơ bản có nguyên tắc hoạt động và ứng dụng khác nhau.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n\n## Stack & Queue\n\n### 1. Stack (Ngăn xếp)\n\n#### 1.1. Khái niệm cơ bản\n\nStack là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **LIFO (Last In First Out)** - \"vào sau ra trước\". Điều này có nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Chồng sách: Cuốn sách đặt lên trên cùng sẽ là cuốn được lấy ra đầu tiên\n- Lịch sử trình duyệt: Nút \"Back\" đưa bạn về trang trước đó theo thứ tự ngược lại\n- Undo/Redo trong text editor\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Push (Đẩy):** Thêm một phần tử vào đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Tăng con trở top lên 1 và thêm phần tử\n\n**b) Pop (Lấy ra):** Xóa và trả về phần tử ở đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Lấy phần tử tại top và giảm top xuống 1\n\n**c) Peek/Top:** Xem phần tử ở đỉnh stack mà không xóa\n- Độ phức tạp: O(1)\n\n**d) isEmpty:** Kiểm tra stack có rỗng không\n- Độ phức tạp: O(1)\n\n**e) Size:** Trả về số lượng phần tử trong stack\n- Độ phức tạp: O(1)\n\n#### 1.3. Cài đặt Stack\n\n**Cách 1: Sử dụng mảng (Array)**\n\n```python\nclass Stack:\n    def __init__(self, capacity=100):\n        self.capacity = capacity\n        self.stack = []\n        self.top = -1\n    \n    def push(self, item):\n        if self.top >= self.capacity - 1:\n            raise Exception(\"Stack Overflow\")\n        self.stack.append(item)\n        self.top += 1\n        return True\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.stack[self.top]\n        self.stack.pop()\n        self.top -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.stack[self.top]\n    \n    def is_empty(self):\n        return self.top == -1\n    \n    def size(self):\n        return self.top + 1\n    \n    def display(self):\n        if self.is_empty():\n            print(\"Stack is empty\")\n        else:\n            print(\"Stack elements:\", end=\" \")\n            for i in range(self.top, -1, -1):\n                print(self.stack[i], end=\" \")\n            print()\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass StackLinkedList:\n    def __init__(self):\n        self.head = None\n        self.size_count = 0\n    \n    def push(self, item):\n        new_node = Node(item)\n        new_node.next = self.head\n        self.head = new_node\n        self.size_count += 1\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.head.data\n        self.head = self.head.next\n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.head.data\n    \n    def is_empty(self):\n        return self.head is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 1.4. Ứng dụng của Stack\n\n**a) Kiểm tra dấu ngoặc hợp lệ:**\n\n```python\ndef is_valid_parentheses(s):\n    stack = []\n\n**Các khái niệm quan trọng:**\n- LIFO (Last In, First Out) là nguyên tắc hoạt động và tính chất cốt lõi của cấu trúc dữ liệu Stack, nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên.\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n\n**Mối quan hệ:**\n- Stack có tính chất LIFO (Last In, First Out), nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên.\n- Stack và Queue là hai cấu trúc dữ liệu tuyến tính cơ bản có nguyên tắc hoạt động và ứng dụng khác nhau.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\n# Test\nprint(is_valid_parentheses(\"()[]{}\"))  # True\nprint(is_valid_parentheses(\"([)]\"))    # False\n```\n\n**b) Chuyển đổi biểu thức Infix sang Postfix:**\n\n```python\ndef infix_to_postfix(expression):\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    stack = []\n    output = []\n    \n    for char in expression:\n        if char.isalnum():  # Toán hạng\n            output.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output.append(stack.pop())\n            stack.pop()  # Loại bỏ '('\n        else:  # Toán tử\n            while (stack and stack[-1] != '(' and\n                   precedence.get(stack[-1], 0) >= precedence.get(char, 0)):\n                output.append(stack.pop())\n            stack.append(char)\n    \n    while stack:\n        output.append(stack.pop())\n    \n    return ''.join(output)\n\n# Test\nprint(infix_to_postfix(\"A+B*C\"))  # ABC*+\n```\n\n**c) Tính giá trị biểu thức Postfix:**\n\n```python\ndef evaluate_postfix(expression):\n    stack = []\n    \n    for char in expression:\n        if char.isdigit():\n            stack.append(int(char))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            \n            if char == '+':\n                stack.append(a + b)\n            elif char == '-':\n                stack.append(a - b)\n            elif char == '*':\n                stack.append(a * b)\n            elif char == '/':\n                stack.append(a // b)\n    \n    return stack.pop()\n\n# Test\nprint(evaluate_postfix(\"23*5+\"))  # 11\n```\n\n**d) Thuật toán quay lui (Backtracking):**\nStack được sử dụng trong các thuật toán quay lui như giải mê cung, N-Queens, sudoku solver.\n\n**e) Đánh giá biểu thức số học và biên dịch:**\nCompiler sử dụng stack để parse và đánh giá các biểu thức.\n\n---\n\n### 2. Queue (Hàng đợi)\n\n#### 2.1. Khái niệm cơ bản\n\nQueue là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **FIFO (First In First Out)** - \"vào trước ra trước\". Phần tử được thêm vào đầu tiên sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Hàng người xếp hàng mua vé: Người đến trước được phục vụ trước\n- Hàng đợi in ấn: Tài liệu gửi in trước sẽ được in trước\n- Hàng đợi xử lý trong hệ thống: CPU scheduling, disk scheduling\n\n#### 2.2. Các thao tác cơ bản\n\n**a) Enqueue (Thêm vào):** Thêm phần tử vào cuối queue\n- Độ phức tạp: O(1)\n\n**b) Dequeue (Lấy ra):** Xóa và trả về phần tử ở đầu queue\n- Độ phức tạp: O(1)\n\n**c) Front/Peek:** Xem phần tử ở đầu queue mà không xóa\n- Độ phức tạp: O(1)\n\n**d) Rear:** Xem phần tử ở cuối queue\n- Độ phức tạp: O(1)\n\n**e) isEmpty:** Kiểm tra queue có rỗng không\n- Độ phức tạp: O(1)\n\n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n\n**Mối quan hệ:**\n- Stack có tính chất LIFO (Last In, First Out), nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên.\n- Stack và Queue là hai cấu trúc dữ liệu tuyến tính cơ bản có nguyên tắc hoạt động và ứng dụng khác nhau."
        },
        "output_without_context": {
            "question": "Kiểu dữ liệu nào sử dụng nguyên tắc LIFO trong các thao tác của nó?",
            "answer": "Stack"
        }
    },
    {
        "topic_description": "Khám phá những khác biệt và điểm mạnh của hai cách triển khai Stack: danh sách liên kết và mảng cố định. Chủ đề này giúp học sinh hiểu thời gian thao tác và bộ nhớ sử dụng cho mỗi phương pháp, qua đó cải thiện khả năng phân tích lựa chọn triển khai.",
        "output_with_context": {
            "question": "So sánh hai cách triển khai Stack: danh sách liên kết và mảng, phương pháp nào giúp tránh được vấn đề Stack Overflow do giới hạn dung lượng cố định của mảng?",
            "answer": "Danh sách liên kết",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n**f) Size:** Trả về số lượng phần tử trong queue\n- Độ phức tạp: O(1)\n\n#### 2.3. Cài đặt Queue\n\n**Cách 1: Sử dụng mảng (Circular Queue)**\n\n```python\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = -1\n        self.rear = -1\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        if self.is_full():\n            raise Exception(\"Queue is full\")\n        \n        if self.front == -1:  # Queue rỗng\n            self.front = 0\n        \n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = item\n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.queue[self.front]\n        \n        if self.front == self.rear:  # Chỉ còn 1 phần tử\n            self.front = -1\n            self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue[self.front]\n    \n    def is_empty(self):\n        return self.front == -1\n    \n    def is_full(self):\n        return (self.rear + 1) % self.capacity == self.front\n    \n    def size(self):\n        return self.size_count\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass QueueLinkedList:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        new_node = Node(item)\n        \n        if self.rear is None:  # Queue rỗng\n            self.front = self.rear = new_node\n        else:\n            self.rear.next = new_node\n            self.rear = new_node\n        \n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.front.data\n        self.front = self.front.next\n        \n        if self.front is None:  # Queue trở nên rỗng\n            self.rear = None\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.front.data\n    \n    def is_empty(self):\n        return self.front is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 2.4. Các loại Queue đặc biệt\n\n**a) Deque (Double-ended Queue):**\nCho phép thêm và xóa phần tử ở cả hai đầu.\n\n```python\nfrom collections import deque\n\ndq = deque()\ndq.append(1)      # Thêm vào phải\ndq.appendleft(2)  # Thêm vào trái\ndq.pop()          # Xóa từ phải\ndq.popleft()      # Xóa từ trái\n```\n\n**b) Priority Queue (Hàng đợi ưu tiên):**\nMỗi phần tử có một độ ưu tiên, phần tử có độ ưu tiên cao nhất được xử lý trước.\n\n```python\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, item, priority):\n        heapq.heappush(self.heap, (priority, item))\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Priority Queue is empty\")\n        return heapq.heappop(self.heap)[1]\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 2.5. Ứng dụng của Queue\n\n**a) BFS (Breadth-First Search) trong đồ thị:**\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    \n\n**Các khái niệm quan trọng:**\n- Linked List (danh sách liên kết) là một cấu trúc dữ liệu tuyến tính, trong đó các phần tử (node) không nhất thiết phải được lưu trữ liên tiếp trong bộ nhớ. Mỗi node chứa dữ liệu và một con trỏ (hoặc tham chiếu) đến node tiếp theo. Khi cài đặt Stack bằng Linked List, việc thêm/xóa phần tử ở đầu danh sách rất hiệu quả, giúp tránh được vấn đề Stack Overflow do giới hạn dung lượng cố định của mảng.\n- Linked List (danh sách liên kết) là một cấu trúc dữ liệu tuyến tính trong đó các phần tử không được lưu trữ ở các vị trí bộ nhớ liên tiếp. Mỗi phần tử (node) chứa dữ liệu và một con trỏ đến node tiếp theo. Phép Search có độ phức tạp O(n), Insert O(1) (thêm vào đầu hoặc cuối nếu có con trỏ tail), Delete O(n) (cần tìm node trước đó). Không duy trì thứ tự sorted.\n- Linked List là một cấu trúc dữ liệu tuyến tính, trong đó các phần tử không được lưu trữ ở các vị trí bộ nhớ liền kề. Thay vào đó, mỗi phần tử (node) chứa dữ liệu và một con trỏ (hoặc tham chiếu) đến node tiếp theo trong chuỗi. Linked List thường được sử dụng trong Chaining để xử lý xung đột trong Hash Table.\n- Linked List (danh sách liên kết) là một cấu trúc dữ liệu tuyến tính trong đó các phần tử không được lưu trữ tại các vị trí bộ nhớ liên tiếp. Mỗi phần tử (node) chứa dữ liệu và một con trỏ (hoặc liên kết) trỏ đến node tiếp theo trong chuỗi. Linked List không hỗ trợ random access hiệu quả. Merge Sort thường tốt hơn Quicksort và có thể được áp dụng hiệu quả cho Linked List.\n- Linked List là một cấu trúc dữ liệu tuyến tính, trong đó các phần tử không được lưu trữ ở các vị trí bộ nhớ liền kề. Mỗi phần tử (node) chứa dữ liệu và một con trỏ trỏ đến node tiếp theo. Trong BST, khi cây bị suy biến (ví dụ, chỉ chèn các phần tử tăng dần), nó có thể trở thành một dạng Linked List, dẫn đến độ phức tạp O(n) cho các phép toán.\n\n**Mối quan hệ:**\n- Stack có thể được cài đặt bằng Linked List.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n\n## Stack & Queue\n\n### 1. Stack (Ngăn xếp)\n\n#### 1.1. Khái niệm cơ bản\n\nStack là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **LIFO (Last In First Out)** - \"vào sau ra trước\". Điều này có nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Chồng sách: Cuốn sách đặt lên trên cùng sẽ là cuốn được lấy ra đầu tiên\n- Lịch sử trình duyệt: Nút \"Back\" đưa bạn về trang trước đó theo thứ tự ngược lại\n- Undo/Redo trong text editor\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Push (Đẩy):** Thêm một phần tử vào đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Tăng con trở top lên 1 và thêm phần tử\n\n**b) Pop (Lấy ra):** Xóa và trả về phần tử ở đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Lấy phần tử tại top và giảm top xuống 1\n\n**c) Peek/Top:** Xem phần tử ở đỉnh stack mà không xóa\n- Độ phức tạp: O(1)\n\n**d) isEmpty:** Kiểm tra stack có rỗng không\n- Độ phức tạp: O(1)\n\n**e) Size:** Trả về số lượng phần tử trong stack\n- Độ phức tạp: O(1)\n\n#### 1.3. Cài đặt Stack\n\n**Cách 1: Sử dụng mảng (Array)**\n\n```python\nclass Stack:\n    def __init__(self, capacity=100):\n        self.capacity = capacity\n        self.stack = []\n        self.top = -1\n    \n    def push(self, item):\n        if self.top >= self.capacity - 1:\n            raise Exception(\"Stack Overflow\")\n        self.stack.append(item)\n        self.top += 1\n        return True\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.stack[self.top]\n        self.stack.pop()\n        self.top -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.stack[self.top]\n    \n    def is_empty(self):\n        return self.top == -1\n    \n    def size(self):\n        return self.top + 1\n    \n    def display(self):\n        if self.is_empty():\n            print(\"Stack is empty\")\n        else:\n            print(\"Stack elements:\", end=\" \")\n            for i in range(self.top, -1, -1):\n                print(self.stack[i], end=\" \")\n            print()\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass StackLinkedList:\n    def __init__(self):\n        self.head = None\n        self.size_count = 0\n    \n    def push(self, item):\n        new_node = Node(item)\n        new_node.next = self.head\n        self.head = new_node\n        self.size_count += 1\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.head.data\n        self.head = self.head.next\n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.head.data\n    \n    def is_empty(self):\n        return self.head is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 1.4. Ứng dụng của Stack\n\n**a) Kiểm tra dấu ngoặc hợp lệ:**\n\n```python\ndef is_valid_parentheses(s):\n    stack = []\n\n**Các khái niệm quan trọng:**\n- Linked List (danh sách liên kết) là một cấu trúc dữ liệu tuyến tính, trong đó các phần tử (node) không nhất thiết phải được lưu trữ liên tiếp trong bộ nhớ. Mỗi node chứa dữ liệu và một con trỏ (hoặc tham chiếu) đến node tiếp theo. Khi cài đặt Stack bằng Linked List, việc thêm/xóa phần tử ở đầu danh sách rất hiệu quả, giúp tránh được vấn đề Stack Overflow do giới hạn dung lượng cố định của mảng.\n- Linked List (danh sách liên kết) là một cấu trúc dữ liệu tuyến tính trong đó các phần tử không được lưu trữ ở các vị trí bộ nhớ liên tiếp. Mỗi phần tử (node) chứa dữ liệu và một con trỏ đến node tiếp theo. Phép Search có độ phức tạp O(n), Insert O(1) (thêm vào đầu hoặc cuối nếu có con trỏ tail), Delete O(n) (cần tìm node trước đó). Không duy trì thứ tự sorted.\n- Linked List là một cấu trúc dữ liệu tuyến tính, trong đó các phần tử không được lưu trữ ở các vị trí bộ nhớ liền kề. Thay vào đó, mỗi phần tử (node) chứa dữ liệu và một con trỏ (hoặc tham chiếu) đến node tiếp theo trong chuỗi. Linked List thường được sử dụng trong Chaining để xử lý xung đột trong Hash Table.\n- Linked List (danh sách liên kết) là một cấu trúc dữ liệu tuyến tính trong đó các phần tử không được lưu trữ tại các vị trí bộ nhớ liên tiếp. Mỗi phần tử (node) chứa dữ liệu và một con trỏ (hoặc liên kết) trỏ đến node tiếp theo trong chuỗi. Linked List không hỗ trợ random access hiệu quả. Merge Sort thường tốt hơn Quicksort và có thể được áp dụng hiệu quả cho Linked List.\n- Linked List là một cấu trúc dữ liệu tuyến tính, trong đó các phần tử không được lưu trữ ở các vị trí bộ nhớ liền kề. Mỗi phần tử (node) chứa dữ liệu và một con trỏ trỏ đến node tiếp theo. Trong BST, khi cây bị suy biến (ví dụ, chỉ chèn các phần tử tăng dần), nó có thể trở thành một dạng Linked List, dẫn đến độ phức tạp O(n) cho các phép toán.\n\n**Mối quan hệ:**\n- Stack có thể được cài đặt bằng Linked List."
        },
        "output_without_context": {
            "question": "Khi so sánh hai cách triển khai Stack là danh sách liên kết và mảng cố định, yếu tố nào ảnh hưởng lớn nhất đến thời gian thao tác trong danh sách liên kết?",
            "answer": "Thời gian truy cập bộ nhớ không liên tiếp."
        }
    },
    {
        "topic_description": "Chủ đề này sẽ tập trung vào các thao tác 'push' và 'pop' trong mô hình Stack. Học sinh sẽ được yêu cầu mô tả quy trình thực hiện các thao tác này cùng với cấu trúc dữ liệu liên quan, giúp củng cố hiểu biết về cách thức hoạt động bên trong của Stack.",
        "output_with_context": {
            "question": "Trong cấu trúc dữ liệu Stack, thao tác nào được sử dụng để thêm một phần tử vào đỉnh của Stack?",
            "answer": "Push",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return result\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\nprint(bfs(graph, 'A'))  # ['A', 'B', 'C', 'D', 'E', 'F']\n```\n\n**b) Quản lý tài nguyên chia sẻ:**\n- CPU scheduling\n- Disk scheduling\n- Printer queue\n\n**c) Xử lý bất đồng bộ:**\n- Message queue trong các hệ thống phân tán\n- Event handling trong GUI\n\n**d) Cache implementation:**\n- LRU (Least Recently Used) cache sử dụng kết hợp queue và hash map\n\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n```\n\n#### 2.6. So sánh Stack và Queue\n\n| Đặc điểm | Stack | Queue |\n|----------|-------|-------|\n| Nguyên tắc | LIFO | FIFO |\n| Thao tác chính | Push, Pop | Enqueue, Dequeue |\n| Truy cập | Chỉ ở đỉnh (top) | Ở đầu (front) và cuối (rear) |\n| Ứng dụng | Backtracking, Expression evaluation | BFS, Scheduling |\n| Cài đặt | Array, Linked List | Array (Circular), Linked List |\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Phép toán Pop trên Stack yêu cầu Stack không được rỗng, nếu không sẽ xảy ra điều kiện Stack Underflow.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n\n## Stack & Queue\n\n### 1. Stack (Ngăn xếp)\n\n#### 1.1. Khái niệm cơ bản\n\nStack là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **LIFO (Last In First Out)** - \"vào sau ra trước\". Điều này có nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Chồng sách: Cuốn sách đặt lên trên cùng sẽ là cuốn được lấy ra đầu tiên\n- Lịch sử trình duyệt: Nút \"Back\" đưa bạn về trang trước đó theo thứ tự ngược lại\n- Undo/Redo trong text editor\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Push (Đẩy):** Thêm một phần tử vào đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Tăng con trở top lên 1 và thêm phần tử\n\n**b) Pop (Lấy ra):** Xóa và trả về phần tử ở đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Lấy phần tử tại top và giảm top xuống 1\n\n**c) Peek/Top:** Xem phần tử ở đỉnh stack mà không xóa\n- Độ phức tạp: O(1)\n\n**d) isEmpty:** Kiểm tra stack có rỗng không\n- Độ phức tạp: O(1)\n\n**e) Size:** Trả về số lượng phần tử trong stack\n- Độ phức tạp: O(1)\n\n#### 1.3. Cài đặt Stack\n\n**Cách 1: Sử dụng mảng (Array)**\n\n```python\nclass Stack:\n    def __init__(self, capacity=100):\n        self.capacity = capacity\n        self.stack = []\n        self.top = -1\n    \n    def push(self, item):\n        if self.top >= self.capacity - 1:\n            raise Exception(\"Stack Overflow\")\n        self.stack.append(item)\n        self.top += 1\n        return True\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.stack[self.top]\n        self.stack.pop()\n        self.top -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.stack[self.top]\n    \n    def is_empty(self):\n        return self.top == -1\n    \n    def size(self):\n        return self.top + 1\n    \n    def display(self):\n        if self.is_empty():\n            print(\"Stack is empty\")\n        else:\n            print(\"Stack elements:\", end=\" \")\n            for i in range(self.top, -1, -1):\n                print(self.stack[i], end=\" \")\n            print()\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass StackLinkedList:\n    def __init__(self):\n        self.head = None\n        self.size_count = 0\n    \n    def push(self, item):\n        new_node = Node(item)\n        new_node.next = self.head\n        self.head = new_node\n        self.size_count += 1\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.head.data\n        self.head = self.head.next\n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.head.data\n    \n    def is_empty(self):\n        return self.head is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 1.4. Ứng dụng của Stack\n\n**a) Kiểm tra dấu ngoặc hợp lệ:**\n\n```python\ndef is_valid_parentheses(s):\n    stack = []\n\n**Các khái niệm quan trọng:**\n- Push là thao tác hoặc phép toán thêm một phần tử vào đỉnh của Stack. Khi thực hiện Push, con trỏ 'top' của Stack sẽ được tăng lên 1 và phần tử mới được thêm vào vị trí đó. Độ phức tạp thời gian của phép toán Push thường là O(1).\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Thao tác Push trên Stack có độ phức tạp thời gian O(1).\n- Phép toán Pop trên Stack yêu cầu Stack không được rỗng, nếu không sẽ xảy ra điều kiện Stack Underflow.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n**f) Size:** Trả về số lượng phần tử trong queue\n- Độ phức tạp: O(1)\n\n#### 2.3. Cài đặt Queue\n\n**Cách 1: Sử dụng mảng (Circular Queue)**\n\n```python\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = -1\n        self.rear = -1\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        if self.is_full():\n            raise Exception(\"Queue is full\")\n        \n        if self.front == -1:  # Queue rỗng\n            self.front = 0\n        \n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = item\n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.queue[self.front]\n        \n        if self.front == self.rear:  # Chỉ còn 1 phần tử\n            self.front = -1\n            self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue[self.front]\n    \n    def is_empty(self):\n        return self.front == -1\n    \n    def is_full(self):\n        return (self.rear + 1) % self.capacity == self.front\n    \n    def size(self):\n        return self.size_count\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass QueueLinkedList:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        new_node = Node(item)\n        \n        if self.rear is None:  # Queue rỗng\n            self.front = self.rear = new_node\n        else:\n            self.rear.next = new_node\n            self.rear = new_node\n        \n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.front.data\n        self.front = self.front.next\n        \n        if self.front is None:  # Queue trở nên rỗng\n            self.rear = None\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.front.data\n    \n    def is_empty(self):\n        return self.front is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 2.4. Các loại Queue đặc biệt\n\n**a) Deque (Double-ended Queue):**\nCho phép thêm và xóa phần tử ở cả hai đầu.\n\n```python\nfrom collections import deque\n\ndq = deque()\ndq.append(1)      # Thêm vào phải\ndq.appendleft(2)  # Thêm vào trái\ndq.pop()          # Xóa từ phải\ndq.popleft()      # Xóa từ trái\n```\n\n**b) Priority Queue (Hàng đợi ưu tiên):**\nMỗi phần tử có một độ ưu tiên, phần tử có độ ưu tiên cao nhất được xử lý trước.\n\n```python\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, item, priority):\n        heapq.heappush(self.heap, (priority, item))\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Priority Queue is empty\")\n        return heapq.heappop(self.heap)[1]\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 2.5. Ứng dụng của Queue\n\n**a) BFS (Breadth-First Search) trong đồ thị:**\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    \n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Phép toán Pop trên Stack yêu cầu Stack không được rỗng, nếu không sẽ xảy ra điều kiện Stack Underflow.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\n# Test\nprint(is_valid_parentheses(\"()[]{}\"))  # True\nprint(is_valid_parentheses(\"([)]\"))    # False\n```\n\n**b) Chuyển đổi biểu thức Infix sang Postfix:**\n\n```python\ndef infix_to_postfix(expression):\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    stack = []\n    output = []\n    \n    for char in expression:\n        if char.isalnum():  # Toán hạng\n            output.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output.append(stack.pop())\n            stack.pop()  # Loại bỏ '('\n        else:  # Toán tử\n            while (stack and stack[-1] != '(' and\n                   precedence.get(stack[-1], 0) >= precedence.get(char, 0)):\n                output.append(stack.pop())\n            stack.append(char)\n    \n    while stack:\n        output.append(stack.pop())\n    \n    return ''.join(output)\n\n# Test\nprint(infix_to_postfix(\"A+B*C\"))  # ABC*+\n```\n\n**c) Tính giá trị biểu thức Postfix:**\n\n```python\ndef evaluate_postfix(expression):\n    stack = []\n    \n    for char in expression:\n        if char.isdigit():\n            stack.append(int(char))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            \n            if char == '+':\n                stack.append(a + b)\n            elif char == '-':\n                stack.append(a - b)\n            elif char == '*':\n                stack.append(a * b)\n            elif char == '/':\n                stack.append(a // b)\n    \n    return stack.pop()\n\n# Test\nprint(evaluate_postfix(\"23*5+\"))  # 11\n```\n\n**d) Thuật toán quay lui (Backtracking):**\nStack được sử dụng trong các thuật toán quay lui như giải mê cung, N-Queens, sudoku solver.\n\n**e) Đánh giá biểu thức số học và biên dịch:**\nCompiler sử dụng stack để parse và đánh giá các biểu thức.\n\n---\n\n### 2. Queue (Hàng đợi)\n\n#### 2.1. Khái niệm cơ bản\n\nQueue là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **FIFO (First In First Out)** - \"vào trước ra trước\". Phần tử được thêm vào đầu tiên sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Hàng người xếp hàng mua vé: Người đến trước được phục vụ trước\n- Hàng đợi in ấn: Tài liệu gửi in trước sẽ được in trước\n- Hàng đợi xử lý trong hệ thống: CPU scheduling, disk scheduling\n\n#### 2.2. Các thao tác cơ bản\n\n**a) Enqueue (Thêm vào):** Thêm phần tử vào cuối queue\n- Độ phức tạp: O(1)\n\n**b) Dequeue (Lấy ra):** Xóa và trả về phần tử ở đầu queue\n- Độ phức tạp: O(1)\n\n**c) Front/Peek:** Xem phần tử ở đầu queue mà không xóa\n- Độ phức tạp: O(1)\n\n**d) Rear:** Xem phần tử ở cuối queue\n- Độ phức tạp: O(1)\n\n**e) isEmpty:** Kiểm tra queue có rỗng không\n- Độ phức tạp: O(1)\n\n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Thao tác Push trên Stack có độ phức tạp thời gian O(1).\n- Phép toán Pop trên Stack yêu cầu Stack không được rỗng, nếu không sẽ xảy ra điều kiện Stack Underflow."
        },
        "output_without_context": {
            "question": "Trong mô hình Stack, thao tác 'push' được sử dụng để làm gì?",
            "answer": "Thao tác 'push' được sử dụng để thêm một phần tử vào đỉnh của Stack."
        }
    },
    {
        "topic_description": "Tìm hiểu cách triển khai Stack bằng danh sách liên kết và phân tích hiệu suất của các thao tác trong trường hợp xấu nhất. Nội dung giúp học sinh đánh giá độ hiệu quả và tính khả thi của việc dùng danh sách liên kết cho Stack.",
        "output_with_context": {
            "question": "Khi triển khai Stack bằng danh sách liên kết, thao tác nào có độ phức tạp thời gian là O(1) và cho phép thêm phần tử vào đỉnh Stack?",
            "answer": "Push",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n**f) Size:** Trả về số lượng phần tử trong queue\n- Độ phức tạp: O(1)\n\n#### 2.3. Cài đặt Queue\n\n**Cách 1: Sử dụng mảng (Circular Queue)**\n\n```python\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = -1\n        self.rear = -1\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        if self.is_full():\n            raise Exception(\"Queue is full\")\n        \n        if self.front == -1:  # Queue rỗng\n            self.front = 0\n        \n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = item\n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.queue[self.front]\n        \n        if self.front == self.rear:  # Chỉ còn 1 phần tử\n            self.front = -1\n            self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue[self.front]\n    \n    def is_empty(self):\n        return self.front == -1\n    \n    def is_full(self):\n        return (self.rear + 1) % self.capacity == self.front\n    \n    def size(self):\n        return self.size_count\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass QueueLinkedList:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        new_node = Node(item)\n        \n        if self.rear is None:  # Queue rỗng\n            self.front = self.rear = new_node\n        else:\n            self.rear.next = new_node\n            self.rear = new_node\n        \n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.front.data\n        self.front = self.front.next\n        \n        if self.front is None:  # Queue trở nên rỗng\n            self.rear = None\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.front.data\n    \n    def is_empty(self):\n        return self.front is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 2.4. Các loại Queue đặc biệt\n\n**a) Deque (Double-ended Queue):**\nCho phép thêm và xóa phần tử ở cả hai đầu.\n\n```python\nfrom collections import deque\n\ndq = deque()\ndq.append(1)      # Thêm vào phải\ndq.appendleft(2)  # Thêm vào trái\ndq.pop()          # Xóa từ phải\ndq.popleft()      # Xóa từ trái\n```\n\n**b) Priority Queue (Hàng đợi ưu tiên):**\nMỗi phần tử có một độ ưu tiên, phần tử có độ ưu tiên cao nhất được xử lý trước.\n\n```python\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, item, priority):\n        heapq.heappush(self.heap, (priority, item))\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Priority Queue is empty\")\n        return heapq.heappop(self.heap)[1]\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 2.5. Ứng dụng của Queue\n\n**a) BFS (Breadth-First Search) trong đồ thị:**\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    \n\n**Các khái niệm quan trọng:**\n- Linked List (danh sách liên kết) là một cấu trúc dữ liệu tuyến tính trong đó các phần tử không được lưu trữ tại các vị trí bộ nhớ liên tiếp. Mỗi phần tử (node) chứa dữ liệu và một con trỏ (hoặc liên kết) trỏ đến node tiếp theo trong chuỗi. Linked List không hỗ trợ random access hiệu quả. Merge Sort thường tốt hơn Quicksort và có thể được áp dụng hiệu quả cho Linked List.\n- Linked List là một cấu trúc dữ liệu tuyến tính, trong đó các phần tử không được lưu trữ ở các vị trí bộ nhớ liền kề. Mỗi phần tử (node) chứa dữ liệu và một con trỏ trỏ đến node tiếp theo. Trong BST, khi cây bị suy biến (ví dụ, chỉ chèn các phần tử tăng dần), nó có thể trở thành một dạng Linked List, dẫn đến độ phức tạp O(n) cho các phép toán.\n- Linked List (danh sách liên kết) là một cấu trúc dữ liệu tuyến tính trong đó các phần tử không được lưu trữ ở các vị trí bộ nhớ liên tiếp. Mỗi phần tử (node) chứa dữ liệu và một con trỏ đến node tiếp theo. Phép Search có độ phức tạp O(n), Insert O(1) (thêm vào đầu hoặc cuối nếu có con trỏ tail), Delete O(n) (cần tìm node trước đó). Không duy trì thứ tự sorted.\n\n**Mối quan hệ:**\n- Stack có thể được cài đặt bằng Linked List.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\n# Test\nprint(is_valid_parentheses(\"()[]{}\"))  # True\nprint(is_valid_parentheses(\"([)]\"))    # False\n```\n\n**b) Chuyển đổi biểu thức Infix sang Postfix:**\n\n```python\ndef infix_to_postfix(expression):\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    stack = []\n    output = []\n    \n    for char in expression:\n        if char.isalnum():  # Toán hạng\n            output.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output.append(stack.pop())\n            stack.pop()  # Loại bỏ '('\n        else:  # Toán tử\n            while (stack and stack[-1] != '(' and\n                   precedence.get(stack[-1], 0) >= precedence.get(char, 0)):\n                output.append(stack.pop())\n            stack.append(char)\n    \n    while stack:\n        output.append(stack.pop())\n    \n    return ''.join(output)\n\n# Test\nprint(infix_to_postfix(\"A+B*C\"))  # ABC*+\n```\n\n**c) Tính giá trị biểu thức Postfix:**\n\n```python\ndef evaluate_postfix(expression):\n    stack = []\n    \n    for char in expression:\n        if char.isdigit():\n            stack.append(int(char))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            \n            if char == '+':\n                stack.append(a + b)\n            elif char == '-':\n                stack.append(a - b)\n            elif char == '*':\n                stack.append(a * b)\n            elif char == '/':\n                stack.append(a // b)\n    \n    return stack.pop()\n\n# Test\nprint(evaluate_postfix(\"23*5+\"))  # 11\n```\n\n**d) Thuật toán quay lui (Backtracking):**\nStack được sử dụng trong các thuật toán quay lui như giải mê cung, N-Queens, sudoku solver.\n\n**e) Đánh giá biểu thức số học và biên dịch:**\nCompiler sử dụng stack để parse và đánh giá các biểu thức.\n\n---\n\n### 2. Queue (Hàng đợi)\n\n#### 2.1. Khái niệm cơ bản\n\nQueue là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **FIFO (First In First Out)** - \"vào trước ra trước\". Phần tử được thêm vào đầu tiên sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Hàng người xếp hàng mua vé: Người đến trước được phục vụ trước\n- Hàng đợi in ấn: Tài liệu gửi in trước sẽ được in trước\n- Hàng đợi xử lý trong hệ thống: CPU scheduling, disk scheduling\n\n#### 2.2. Các thao tác cơ bản\n\n**a) Enqueue (Thêm vào):** Thêm phần tử vào cuối queue\n- Độ phức tạp: O(1)\n\n**b) Dequeue (Lấy ra):** Xóa và trả về phần tử ở đầu queue\n- Độ phức tạp: O(1)\n\n**c) Front/Peek:** Xem phần tử ở đầu queue mà không xóa\n- Độ phức tạp: O(1)\n\n**d) Rear:** Xem phần tử ở cuối queue\n- Độ phức tạp: O(1)\n\n**e) isEmpty:** Kiểm tra queue có rỗng không\n- Độ phức tạp: O(1)\n\n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n\n**Mối quan hệ:**\n- Stack có thể được cài đặt bằng Linked List.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n\n## Stack & Queue\n\n### 1. Stack (Ngăn xếp)\n\n#### 1.1. Khái niệm cơ bản\n\nStack là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **LIFO (Last In First Out)** - \"vào sau ra trước\". Điều này có nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Chồng sách: Cuốn sách đặt lên trên cùng sẽ là cuốn được lấy ra đầu tiên\n- Lịch sử trình duyệt: Nút \"Back\" đưa bạn về trang trước đó theo thứ tự ngược lại\n- Undo/Redo trong text editor\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Push (Đẩy):** Thêm một phần tử vào đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Tăng con trở top lên 1 và thêm phần tử\n\n**b) Pop (Lấy ra):** Xóa và trả về phần tử ở đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Lấy phần tử tại top và giảm top xuống 1\n\n**c) Peek/Top:** Xem phần tử ở đỉnh stack mà không xóa\n- Độ phức tạp: O(1)\n\n**d) isEmpty:** Kiểm tra stack có rỗng không\n- Độ phức tạp: O(1)\n\n**e) Size:** Trả về số lượng phần tử trong stack\n- Độ phức tạp: O(1)\n\n#### 1.3. Cài đặt Stack\n\n**Cách 1: Sử dụng mảng (Array)**\n\n```python\nclass Stack:\n    def __init__(self, capacity=100):\n        self.capacity = capacity\n        self.stack = []\n        self.top = -1\n    \n    def push(self, item):\n        if self.top >= self.capacity - 1:\n            raise Exception(\"Stack Overflow\")\n        self.stack.append(item)\n        self.top += 1\n        return True\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.stack[self.top]\n        self.stack.pop()\n        self.top -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.stack[self.top]\n    \n    def is_empty(self):\n        return self.top == -1\n    \n    def size(self):\n        return self.top + 1\n    \n    def display(self):\n        if self.is_empty():\n            print(\"Stack is empty\")\n        else:\n            print(\"Stack elements:\", end=\" \")\n            for i in range(self.top, -1, -1):\n                print(self.stack[i], end=\" \")\n            print()\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass StackLinkedList:\n    def __init__(self):\n        self.head = None\n        self.size_count = 0\n    \n    def push(self, item):\n        new_node = Node(item)\n        new_node.next = self.head\n        self.head = new_node\n        self.size_count += 1\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.head.data\n        self.head = self.head.next\n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.head.data\n    \n    def is_empty(self):\n        return self.head is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 1.4. Ứng dụng của Stack\n\n**a) Kiểm tra dấu ngoặc hợp lệ:**\n\n```python\ndef is_valid_parentheses(s):\n    stack = []\n\n**Các khái niệm quan trọng:**\n- Linked List (danh sách liên kết) là một cấu trúc dữ liệu tuyến tính, trong đó các phần tử (node) không nhất thiết phải được lưu trữ liên tiếp trong bộ nhớ. Mỗi node chứa dữ liệu và một con trỏ (hoặc tham chiếu) đến node tiếp theo. Khi cài đặt Stack bằng Linked List, việc thêm/xóa phần tử ở đầu danh sách rất hiệu quả, giúp tránh được vấn đề Stack Overflow do giới hạn dung lượng cố định của mảng.\n- Linked List là một cấu trúc dữ liệu tuyến tính trong đó các phần tử không được lưu trữ liền kề trong bộ nhớ. Mỗi phần tử (node) chứa dữ liệu và một con trỏ (hoặc tham chiếu) đến node tiếp theo. Cài đặt Queue bằng Linked List cho phép kích thước động và các phép toán enqueue, dequeue, peek, is_empty, size đều có độ phức tạp O(1).\n- Linked List (danh sách liên kết) là một cấu trúc dữ liệu tuyến tính trong đó các phần tử không được lưu trữ ở các vị trí bộ nhớ liên tiếp. Mỗi phần tử (node) chứa dữ liệu và một con trỏ đến node tiếp theo. Phép Search có độ phức tạp O(n), Insert O(1) (thêm vào đầu hoặc cuối nếu có con trỏ tail), Delete O(n) (cần tìm node trước đó). Không duy trì thứ tự sorted.\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Linked List (danh sách liên kết) là một cấu trúc dữ liệu tuyến tính trong đó các phần tử không được lưu trữ tại các vị trí bộ nhớ liên tiếp. Mỗi phần tử (node) chứa dữ liệu và một con trỏ (hoặc liên kết) trỏ đến node tiếp theo trong chuỗi. Linked List không hỗ trợ random access hiệu quả. Merge Sort thường tốt hơn Quicksort và có thể được áp dụng hiệu quả cho Linked List.\n- Linked List là một cấu trúc dữ liệu tuyến tính, trong đó các phần tử không được lưu trữ ở các vị trí bộ nhớ liền kề. Mỗi phần tử (node) chứa dữ liệu và một con trỏ trỏ đến node tiếp theo. Trong BST, khi cây bị suy biến (ví dụ, chỉ chèn các phần tử tăng dần), nó có thể trở thành một dạng Linked List, dẫn đến độ phức tạp O(n) cho các phép toán.\n\n**Mối quan hệ:**\n- Stack có thể được cài đặt bằng Linked List."
        },
        "output_without_context": {
            "question": "Khi triển khai Stack bằng danh sách liên kết, thao tác nào có thể dẫn đến hiệu suất tồi tệ nhất trong trường hợp xấu nhất?",
            "answer": "Thao tác tìm kiếm phần tử."
        }
    },
    {
        "topic_description": "Khảo sát ứng dụng thực tế của Stack trong các lĩnh vực như xác thực cú pháp, chức năng hoàn tác trong ứng dụng, và xử lý biểu thức toán học. Học sinh sẽ được yêu cầu kết nối lý thuyết với thực tiễn thông qua các ví dụ cụ thể.",
        "output_with_context": {
            "question": "Trong ngữ cảnh của Stack, thao tác nào sau đây được sử dụng để thêm một phần tử vào đỉnh của Stack?",
            "answer": "Push",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return result\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\nprint(bfs(graph, 'A'))  # ['A', 'B', 'C', 'D', 'E', 'F']\n```\n\n**b) Quản lý tài nguyên chia sẻ:**\n- CPU scheduling\n- Disk scheduling\n- Printer queue\n\n**c) Xử lý bất đồng bộ:**\n- Message queue trong các hệ thống phân tán\n- Event handling trong GUI\n\n**d) Cache implementation:**\n- LRU (Least Recently Used) cache sử dụng kết hợp queue và hash map\n\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n```\n\n#### 2.6. So sánh Stack và Queue\n\n| Đặc điểm | Stack | Queue |\n|----------|-------|-------|\n| Nguyên tắc | LIFO | FIFO |\n| Thao tác chính | Push, Pop | Enqueue, Dequeue |\n| Truy cập | Chỉ ở đỉnh (top) | Ở đầu (front) và cuối (rear) |\n| Ứng dụng | Backtracking, Expression evaluation | BFS, Scheduling |\n| Cài đặt | Array, Linked List | Array (Circular), Linked List |\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Compiler sử dụng Stack để phân tích cú pháp và đánh giá các biểu thức số học trong quá trình biên dịch.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n\n## Stack & Queue\n\n### 1. Stack (Ngăn xếp)\n\n#### 1.1. Khái niệm cơ bản\n\nStack là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **LIFO (Last In First Out)** - \"vào sau ra trước\". Điều này có nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Chồng sách: Cuốn sách đặt lên trên cùng sẽ là cuốn được lấy ra đầu tiên\n- Lịch sử trình duyệt: Nút \"Back\" đưa bạn về trang trước đó theo thứ tự ngược lại\n- Undo/Redo trong text editor\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Push (Đẩy):** Thêm một phần tử vào đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Tăng con trở top lên 1 và thêm phần tử\n\n**b) Pop (Lấy ra):** Xóa và trả về phần tử ở đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Lấy phần tử tại top và giảm top xuống 1\n\n**c) Peek/Top:** Xem phần tử ở đỉnh stack mà không xóa\n- Độ phức tạp: O(1)\n\n**d) isEmpty:** Kiểm tra stack có rỗng không\n- Độ phức tạp: O(1)\n\n**e) Size:** Trả về số lượng phần tử trong stack\n- Độ phức tạp: O(1)\n\n#### 1.3. Cài đặt Stack\n\n**Cách 1: Sử dụng mảng (Array)**\n\n```python\nclass Stack:\n    def __init__(self, capacity=100):\n        self.capacity = capacity\n        self.stack = []\n        self.top = -1\n    \n    def push(self, item):\n        if self.top >= self.capacity - 1:\n            raise Exception(\"Stack Overflow\")\n        self.stack.append(item)\n        self.top += 1\n        return True\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.stack[self.top]\n        self.stack.pop()\n        self.top -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.stack[self.top]\n    \n    def is_empty(self):\n        return self.top == -1\n    \n    def size(self):\n        return self.top + 1\n    \n    def display(self):\n        if self.is_empty():\n            print(\"Stack is empty\")\n        else:\n            print(\"Stack elements:\", end=\" \")\n            for i in range(self.top, -1, -1):\n                print(self.stack[i], end=\" \")\n            print()\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass StackLinkedList:\n    def __init__(self):\n        self.head = None\n        self.size_count = 0\n    \n    def push(self, item):\n        new_node = Node(item)\n        new_node.next = self.head\n        self.head = new_node\n        self.size_count += 1\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.head.data\n        self.head = self.head.next\n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.head.data\n    \n    def is_empty(self):\n        return self.head is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 1.4. Ứng dụng của Stack\n\n**a) Kiểm tra dấu ngoặc hợp lệ:**\n\n```python\ndef is_valid_parentheses(s):\n    stack = []\n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Compiler sử dụng Stack để phân tích cú pháp và đánh giá các biểu thức số học trong quá trình biên dịch.\n- Stack được sử dụng để giải quyết bài toán đánh giá biểu thức.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n**f) Size:** Trả về số lượng phần tử trong queue\n- Độ phức tạp: O(1)\n\n#### 2.3. Cài đặt Queue\n\n**Cách 1: Sử dụng mảng (Circular Queue)**\n\n```python\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = -1\n        self.rear = -1\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        if self.is_full():\n            raise Exception(\"Queue is full\")\n        \n        if self.front == -1:  # Queue rỗng\n            self.front = 0\n        \n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = item\n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.queue[self.front]\n        \n        if self.front == self.rear:  # Chỉ còn 1 phần tử\n            self.front = -1\n            self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue[self.front]\n    \n    def is_empty(self):\n        return self.front == -1\n    \n    def is_full(self):\n        return (self.rear + 1) % self.capacity == self.front\n    \n    def size(self):\n        return self.size_count\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass QueueLinkedList:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        new_node = Node(item)\n        \n        if self.rear is None:  # Queue rỗng\n            self.front = self.rear = new_node\n        else:\n            self.rear.next = new_node\n            self.rear = new_node\n        \n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.front.data\n        self.front = self.front.next\n        \n        if self.front is None:  # Queue trở nên rỗng\n            self.rear = None\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.front.data\n    \n    def is_empty(self):\n        return self.front is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 2.4. Các loại Queue đặc biệt\n\n**a) Deque (Double-ended Queue):**\nCho phép thêm và xóa phần tử ở cả hai đầu.\n\n```python\nfrom collections import deque\n\ndq = deque()\ndq.append(1)      # Thêm vào phải\ndq.appendleft(2)  # Thêm vào trái\ndq.pop()          # Xóa từ phải\ndq.popleft()      # Xóa từ trái\n```\n\n**b) Priority Queue (Hàng đợi ưu tiên):**\nMỗi phần tử có một độ ưu tiên, phần tử có độ ưu tiên cao nhất được xử lý trước.\n\n```python\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, item, priority):\n        heapq.heappush(self.heap, (priority, item))\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Priority Queue is empty\")\n        return heapq.heappop(self.heap)[1]\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 2.5. Ứng dụng của Queue\n\n**a) BFS (Breadth-First Search) trong đồ thị:**\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    \n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Compiler sử dụng Stack để phân tích cú pháp và đánh giá các biểu thức số học trong quá trình biên dịch.\n- Stack được sử dụng để giải quyết bài toán đánh giá biểu thức.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\n# Test\nprint(is_valid_parentheses(\"()[]{}\"))  # True\nprint(is_valid_parentheses(\"([)]\"))    # False\n```\n\n**b) Chuyển đổi biểu thức Infix sang Postfix:**\n\n```python\ndef infix_to_postfix(expression):\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    stack = []\n    output = []\n    \n    for char in expression:\n        if char.isalnum():  # Toán hạng\n            output.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output.append(stack.pop())\n            stack.pop()  # Loại bỏ '('\n        else:  # Toán tử\n            while (stack and stack[-1] != '(' and\n                   precedence.get(stack[-1], 0) >= precedence.get(char, 0)):\n                output.append(stack.pop())\n            stack.append(char)\n    \n    while stack:\n        output.append(stack.pop())\n    \n    return ''.join(output)\n\n# Test\nprint(infix_to_postfix(\"A+B*C\"))  # ABC*+\n```\n\n**c) Tính giá trị biểu thức Postfix:**\n\n```python\ndef evaluate_postfix(expression):\n    stack = []\n    \n    for char in expression:\n        if char.isdigit():\n            stack.append(int(char))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            \n            if char == '+':\n                stack.append(a + b)\n            elif char == '-':\n                stack.append(a - b)\n            elif char == '*':\n                stack.append(a * b)\n            elif char == '/':\n                stack.append(a // b)\n    \n    return stack.pop()\n\n# Test\nprint(evaluate_postfix(\"23*5+\"))  # 11\n```\n\n**d) Thuật toán quay lui (Backtracking):**\nStack được sử dụng trong các thuật toán quay lui như giải mê cung, N-Queens, sudoku solver.\n\n**e) Đánh giá biểu thức số học và biên dịch:**\nCompiler sử dụng stack để parse và đánh giá các biểu thức.\n\n---\n\n### 2. Queue (Hàng đợi)\n\n#### 2.1. Khái niệm cơ bản\n\nQueue là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **FIFO (First In First Out)** - \"vào trước ra trước\". Phần tử được thêm vào đầu tiên sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Hàng người xếp hàng mua vé: Người đến trước được phục vụ trước\n- Hàng đợi in ấn: Tài liệu gửi in trước sẽ được in trước\n- Hàng đợi xử lý trong hệ thống: CPU scheduling, disk scheduling\n\n#### 2.2. Các thao tác cơ bản\n\n**a) Enqueue (Thêm vào):** Thêm phần tử vào cuối queue\n- Độ phức tạp: O(1)\n\n**b) Dequeue (Lấy ra):** Xóa và trả về phần tử ở đầu queue\n- Độ phức tạp: O(1)\n\n**c) Front/Peek:** Xem phần tử ở đầu queue mà không xóa\n- Độ phức tạp: O(1)\n\n**d) Rear:** Xem phần tử ở cuối queue\n- Độ phức tạp: O(1)\n\n**e) isEmpty:** Kiểm tra queue có rỗng không\n- Độ phức tạp: O(1)\n\n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Compiler sử dụng Stack để phân tích cú pháp và đánh giá các biểu thức số học trong quá trình biên dịch."
        },
        "output_without_context": {
            "question": "Trong ứng dụng thực tế, Stack thường được sử dụng để thực hiện chức năng nào trong xử lý biểu thức toán học?",
            "answer": "Quản lý thứ tự thực hiện các phép toán."
        }
    },
    {
        "topic_description": "Chủ đề này giải thích cách thức hoạt động của Stack sử dụng mảng có thể thay đổi kích thước và cách điều chỉnh kích thước mảng phù hợp. Học sinh sẽ phải hiểu quy trình resize và ảnh hưởng của nó đến hiệu suất của Stack.",
        "output_with_context": {
            "question": "Khi cài đặt Stack bằng mảng có thể thay đổi kích thước, điều gì xảy ra khi số lượng phần tử vượt quá dung lượng đã định của mảng?",
            "answer": "Stack Overflow",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n\n## Stack & Queue\n\n### 1. Stack (Ngăn xếp)\n\n#### 1.1. Khái niệm cơ bản\n\nStack là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **LIFO (Last In First Out)** - \"vào sau ra trước\". Điều này có nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Chồng sách: Cuốn sách đặt lên trên cùng sẽ là cuốn được lấy ra đầu tiên\n- Lịch sử trình duyệt: Nút \"Back\" đưa bạn về trang trước đó theo thứ tự ngược lại\n- Undo/Redo trong text editor\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Push (Đẩy):** Thêm một phần tử vào đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Tăng con trở top lên 1 và thêm phần tử\n\n**b) Pop (Lấy ra):** Xóa và trả về phần tử ở đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Lấy phần tử tại top và giảm top xuống 1\n\n**c) Peek/Top:** Xem phần tử ở đỉnh stack mà không xóa\n- Độ phức tạp: O(1)\n\n**d) isEmpty:** Kiểm tra stack có rỗng không\n- Độ phức tạp: O(1)\n\n**e) Size:** Trả về số lượng phần tử trong stack\n- Độ phức tạp: O(1)\n\n#### 1.3. Cài đặt Stack\n\n**Cách 1: Sử dụng mảng (Array)**\n\n```python\nclass Stack:\n    def __init__(self, capacity=100):\n        self.capacity = capacity\n        self.stack = []\n        self.top = -1\n    \n    def push(self, item):\n        if self.top >= self.capacity - 1:\n            raise Exception(\"Stack Overflow\")\n        self.stack.append(item)\n        self.top += 1\n        return True\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.stack[self.top]\n        self.stack.pop()\n        self.top -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.stack[self.top]\n    \n    def is_empty(self):\n        return self.top == -1\n    \n    def size(self):\n        return self.top + 1\n    \n    def display(self):\n        if self.is_empty():\n            print(\"Stack is empty\")\n        else:\n            print(\"Stack elements:\", end=\" \")\n            for i in range(self.top, -1, -1):\n                print(self.stack[i], end=\" \")\n            print()\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass StackLinkedList:\n    def __init__(self):\n        self.head = None\n        self.size_count = 0\n    \n    def push(self, item):\n        new_node = Node(item)\n        new_node.next = self.head\n        self.head = new_node\n        self.size_count += 1\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.head.data\n        self.head = self.head.next\n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.head.data\n    \n    def is_empty(self):\n        return self.head is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 1.4. Ứng dụng của Stack\n\n**a) Kiểm tra dấu ngoặc hợp lệ:**\n\n```python\ndef is_valid_parentheses(s):\n    stack = []\n\n**Các khái niệm quan trọng:**\n- Array (mảng) là một cấu trúc dữ liệu tuyến tính, tập hợp các phần tử cùng kiểu dữ liệu được lưu trữ trong các ô nhớ liên tiếp. Các phần tử được truy cập thông qua chỉ số (index). Khi cài đặt Stack bằng mảng, kích thước của mảng thường được định trước, dẫn đến khả năng xảy ra Stack Overflow nếu vượt quá dung lượng.\n- Stack Overflow là một điều kiện lỗi xảy ra khi cố gắng thêm một phần tử vào một Stack đã đầy (khi cài đặt bằng mảng có giới hạn dung lượng). Điều này thường dẫn đến việc chương trình bị lỗi hoặc dừng đột ngột.\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Stack có thể được cài đặt bằng Array.\n- Cài đặt Stack bằng Array có thể dẫn đến điều kiện Stack Overflow nếu số lượng phần tử vượt quá dung lượng mảng đã định.\n- Stack có thể được cài đặt bằng cách sử dụng cấu trúc dữ liệu Array (mảng).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return result\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\nprint(bfs(graph, 'A'))  # ['A', 'B', 'C', 'D', 'E', 'F']\n```\n\n**b) Quản lý tài nguyên chia sẻ:**\n- CPU scheduling\n- Disk scheduling\n- Printer queue\n\n**c) Xử lý bất đồng bộ:**\n- Message queue trong các hệ thống phân tán\n- Event handling trong GUI\n\n**d) Cache implementation:**\n- LRU (Least Recently Used) cache sử dụng kết hợp queue và hash map\n\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n```\n\n#### 2.6. So sánh Stack và Queue\n\n| Đặc điểm | Stack | Queue |\n|----------|-------|-------|\n| Nguyên tắc | LIFO | FIFO |\n| Thao tác chính | Push, Pop | Enqueue, Dequeue |\n| Truy cập | Chỉ ở đỉnh (top) | Ở đầu (front) và cuối (rear) |\n| Ứng dụng | Backtracking, Expression evaluation | BFS, Scheduling |\n| Cài đặt | Array, Linked List | Array (Circular), Linked List |\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Stack có thể được cài đặt bằng cách sử dụng cấu trúc dữ liệu Array (mảng).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n**f) Size:** Trả về số lượng phần tử trong queue\n- Độ phức tạp: O(1)\n\n#### 2.3. Cài đặt Queue\n\n**Cách 1: Sử dụng mảng (Circular Queue)**\n\n```python\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = -1\n        self.rear = -1\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        if self.is_full():\n            raise Exception(\"Queue is full\")\n        \n        if self.front == -1:  # Queue rỗng\n            self.front = 0\n        \n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = item\n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.queue[self.front]\n        \n        if self.front == self.rear:  # Chỉ còn 1 phần tử\n            self.front = -1\n            self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue[self.front]\n    \n    def is_empty(self):\n        return self.front == -1\n    \n    def is_full(self):\n        return (self.rear + 1) % self.capacity == self.front\n    \n    def size(self):\n        return self.size_count\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass QueueLinkedList:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        new_node = Node(item)\n        \n        if self.rear is None:  # Queue rỗng\n            self.front = self.rear = new_node\n        else:\n            self.rear.next = new_node\n            self.rear = new_node\n        \n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.front.data\n        self.front = self.front.next\n        \n        if self.front is None:  # Queue trở nên rỗng\n            self.rear = None\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.front.data\n    \n    def is_empty(self):\n        return self.front is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 2.4. Các loại Queue đặc biệt\n\n**a) Deque (Double-ended Queue):**\nCho phép thêm và xóa phần tử ở cả hai đầu.\n\n```python\nfrom collections import deque\n\ndq = deque()\ndq.append(1)      # Thêm vào phải\ndq.appendleft(2)  # Thêm vào trái\ndq.pop()          # Xóa từ phải\ndq.popleft()      # Xóa từ trái\n```\n\n**b) Priority Queue (Hàng đợi ưu tiên):**\nMỗi phần tử có một độ ưu tiên, phần tử có độ ưu tiên cao nhất được xử lý trước.\n\n```python\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, item, priority):\n        heapq.heappush(self.heap, (priority, item))\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Priority Queue is empty\")\n        return heapq.heappop(self.heap)[1]\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 2.5. Ứng dụng của Queue\n\n**a) BFS (Breadth-First Search) trong đồ thị:**\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    \n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Stack có thể được cài đặt bằng cách sử dụng cấu trúc dữ liệu Array (mảng)."
        },
        "output_without_context": {
            "question": "Khi nào quy trình resize mảng trong Stack có thể ảnh hưởng đến hiệu suất của nó?",
            "answer": "Khi số lượng phần tử trong Stack vượt quá kích thước hiện tại của mảng."
        }
    },
    {
        "topic_description": "Khám phá khái niệm tự động ép kiểu (autoboxing) trong Stack tham số hóa. Học sinh sẽ cần hiểu cách autoboxing giảm thiểu lỗi thời gian chạy và cách áp dụng nó trong các tình huống cụ thể mà không cần ép kiểu thủ công.",
        "output_with_context": {
            "question": "Tại sao tự động ép kiểu (autoboxing) trong Stack tham số hóa lại quan trọng trong việc giảm thiểu lỗi thời gian chạy trong lập trình?",
            "answer": "Tự động ép kiểu giúp giảm thiểu lỗi thời gian chạy bằng cách tự động chuyển đổi giữa kiểu dữ liệu nguyên thủy và kiểu đối tượng mà không cần ép kiểu thủ công.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Học Máy (Machine Learning)\n## Học Sâu (Deep Learning)\n  - **CutMix:** Cắt và dán vùng từ ảnh khác\n  - **CutOut:** Che ngẫu nhiên một vùng của ảnh\n  - **AutoAugment:** Tự động học policy augmentation tốt nhất\n\n**Cho văn bản (NLP):**\n- Synonym replacement (thay từ đồng nghĩa)\n- Random insertion/deletion\n- Back-translation (dịch qua lại)\n- Paraphrasing\n\n**Cho âm thanh:**\n- Time stretching\n- Pitch shifting\n- Adding noise\n- Time masking, frequency masking\n\n**Lưu ý:**\n- Augmentation phải giữ nguyên nhãn\n- Cần domain knowledge (ví dụ: không flip chữ số)\n- On-the-fly augmentation trong training (không pre-generate)\n\n**5. Batch Normalization:**\n\nKỹ thuật chuẩn hóa activation của mỗi layer, được giới thiệu bởi Ioffe & Szegedy (2015).\n\n**Công thức:**\n\nVới một mini-batch:\n$$\\mu_B = \frac{1}{m}\\sum_{i=1}^{m}x_i \\quad \text{(mean của batch)}$$\n$$\\sigma_B^2 = \frac{1}{m}\\sum_{i=1}^{m}(x_i - \\mu_B)^2 \\quad \text{(variance của batch)}$$\n\n**Normalize:**\n$$\\hat{x}_i = \frac{x_i - \\mu_B}{\\sqrt{\\sigma_B^2 + \\epsilon}}$$\n\n**Scale and shift** (learnable parameters):\n$$y_i = \\gamma\\hat{x}_i + \beta$$\n\n**Tại sao hiệu quả:**\n- **Giảm Internal Covariate Shift:** Phân phối input của mỗi layer ổn định hơn\n- **Cho phép learning rate cao hơn:** Training nhanh hơn 5-10 lần\n- **Regularization effect:** Thêm noise từ batch statistics\n- **Giảm nhạy cảm với weight initialization**\n\n**Vị trí đặt:**\n- Thường đặt **sau** linear/conv layer, **trước** activation function\n- Có thể đặt sau activation (ít phổ biến hơn)\n\n**Ưu điểm:**\n- Tăng tốc training đáng kể\n- Cho phép sử dụng activation functions có vanishing gradient (sigmoid, tanh)\n- Giảm overfitting (có thể giảm dropout)\n- Mô hình ít nhạy cảm với hyperparameters\n\n**Nhược điểm:**\n- **Phụ thuộc batch size:** Không hoạt động tốt với batch nhỏ\n- Khác nhau giữa training và inference (cần lưu running statistics)\n- Không phù hợp với RNNs\n- Thêm computational cost\n\n**Inference time:**\nSử dụng moving average của mean và variance từ training:\n$$\\mu_{test} = E[\\mu_B], \\quad \\sigma_{test}^2 = E[\\sigma_B^2]$$\n\n**6. Layer Normalization:**\n\nThay thế cho Batch Normalization, chuẩn hóa theo features thay vì batch.\n\n**Công thức:**\nVới một sample, normalize across features:\n$$\\mu = \frac{1}{H}\\sum_{i=1}^{H}x_i$$\n$$\\sigma^2 = \frac{1}{H}\\sum_{i=1}^{H}(x_i - \\mu)^2$$\n$$\\hat{x}_i = \frac{x_i - \\mu}{\\sqrt{\\sigma^2 + \\epsilon}}$$\n$$y_i = \\gamma\\hat{x}_i + \beta$$\n\n**Ưu điểm so với Batch Norm:**\n- **Không phụ thuộc batch size** → hoạt động với batch size = 1\n- **Giống nhau giữa training và inference** → không cần lưu running statistics\n- **Phù hợp với RNNs** và sequence models\n- Hoạt động tốt với Transformers\n\n\n**Các khái niệm quan trọng:**\n- Time stretching là một kỹ thuật augmentation cho dữ liệu âm thanh bằng cách thay đổi tốc độ phát lại của âm thanh mà không làm thay đổi cao độ. Kỹ thuật này giúp mô hình trở nên mạnh mẽ hơn trước các biến thể về tốc độ nói hoặc nhịp điệu.\n\n**Nội dung từ tài liệu:**\n# Học Máy (Machine Learning)\n## Lựa Chọn Đặc Trưng & Tối Ưu Hóa Mô Hình\n- Grid search toàn pipeline\n\n**2. Feature Union:**\n\n```python\nfrom sklearn.pipeline import FeatureUnion\n\nfeature_union = FeatureUnion([\n    ('numeric', numeric_pipeline),\n    ('text', text_pipeline),\n    ('categorical', categorical_pipeline)\n])\n```\n\n**Đặc điểm:**\n- Parallel processing\n- Combine different feature types\n- Modular design\n\n**3. Caching:**\n\n```python\npipeline = Pipeline([...], memory='cache_folder')\n```\n\n**Ưu điểm:**\n- Cache intermediate results\n- Speed up grid search\n- Reuse computations\n\n### Early Stopping\n\nCho iterative algorithms (gradient descent, boosting).\n\n**Nguyên lý:**\n- Monitor validation performance\n- Stop khi performance degrades\n- Prevents overfitting\n\n**Thuật toán:**\n1. Set patience (số epochs không cải thiện)\n2. Track best validation score\n3. Each epoch:\n   - Evaluate validation\n   - If improved: Reset counter, save model\n   - If not: Increment counter\n4. If counter > patience: Stop\n\n**Ưu điểm:**\n- Automatic regularization\n- Save training time\n- Prevent overfitting\n\n**Tham số:**\n- **patience:** Số epochs chờ (5-20)\n- **min_delta:** Minimum improvement (0.001-0.01)\n- **restore_best_weights:** Restore model tốt nhất\n\n**Áp dụng:**\n- Neural Networks (most common)\n- Gradient Boosting\n- Iterative algorithms\n\n### Chiến Lược Regularization\n\n**1. L1 (Lasso):**\n- Feature selection\n- Sparse solutions\n- $\\lambda||w||_1$\n\n**2. L2 (Ridge):**\n- Shrinks coefficients\n- Handles multicollinearity\n- $\\lambda||w||_2^2$\n\n**3. Elastic Net:**\n- Combines L1 và L2\n- $\\lambda_1||w||_1 + \\lambda_2||w||_2^2$\n\n**4. Dropout (Neural Networks):**\n- Randomly drop units during training\n- Rate: 0.2-0.5\n- Forces redundancy\n- Reduces co-adaptation\n\n**5. Data Augmentation:**\n- Artificially expand training set\n- Transformations:\n  - Images: Rotation, flip, crop, brightness\n  - Text: Synonym replacement, back-translation\n  - Audio: Time stretch, pitch shift, noise\n\n**Ưu điểm:**\n- More data without collecting\n- Improve generalization\n- Reduce overfitting\n\n### AutoML\n\nAutomated machine learning systems.\n\n**Tools:**\n- **Auto-sklearn:** Automated sklearn\n- **H2O AutoML:** Enterprise-grade\n- **Google AutoML:** Cloud-based\n- **TPOT:** Genetic programming\n- **AutoKeras:** Automated deep learning\n\n**Tự động hóa:**\n1. **Feature preprocessing:**\n   - Scaling, encoding, imputation\n   - Feature engineering\n\n2. **Algorithm selection:**\n   - Try multiple algorithms\n   - Ensemble automatically\n\n3. **Hyperparameter tuning:**\n   - Bayesian optimization\n   - Meta-learning\n\n4. **Model ensembling:**\n   - Combine best models\n   - Stacking, voting\n\n**Ưu điểm:**\n- Save time\n- Good baseline\n- Accessible to non-experts\n- Try many approaches\n\n**Nhược điểm:**\n- Black box\n- Computational expensive\n- May not find best solution\n- Limited customization\n- Overkill cho simple problems\n\n**Khi nào dùng:**\n- Starting point\n- Baseline comparison\n- Limited ML expertise\n- Have computational resources\n\n**Best practices:**\n- Set time/resource limits\n- Understand results\n- Use as starting point, tune further\n- Validate on hold-out set\n\n### Best Practices\n\n**1. Start Simple:**\n- Begin với simple model (Linear, Logistic)\n- Establish baseline\n- Increase complexity nếu cần\n\n**2. Establish Baseline:**\n- Random prediction\n- Mean/Mode prediction\n- Simple rule-based\n- Must beat baseline\n\n**3. Feature Importance:**\n- Understand which features matter\n- Remove useless features\n- Focus effort on important features\n\n**4. Iterate:**\n- Continuous improvement cycle\n- Experiment → Analyze → Refine\n- Keep track of experiments\n\n**5. Monitor Multiple Metrics:**\n- Không chỉ một metric\n\n**Các khái niệm quan trọng:**\n- AutoML (Automated Machine Learning) là một hệ thống tự động hóa các tác vụ trong quy trình Machine Learning, bao gồm tiền xử lý đặc trưng, lựa chọn thuật toán, điều chỉnh siêu tham số và kết hợp mô hình. AutoML giúp giảm thiểu công sức thủ công, cung cấp một điểm khởi đầu tốt và làm cho ML dễ tiếp cận hơn đối với những người không chuyên về ML, mặc dù có thể tốn kém về mặt tính toán và đôi khi là \"hộp đen\".\n\n**Mối quan hệ:**\n- AutoML tự động hóa quy trình Feature preprocessing, bao gồm scaling, encoding, imputation và feature engineering, để chuẩn bị dữ liệu cho mô hình học máy.\n- AutoML tự động hóa quy trình Hyperparameter tuning bằng cách sử dụng các kỹ thuật như Bayesian optimization và meta-learning để tìm kiếm siêu tham số tối ưu.\n- AutoML tự động hóa quy trình Algorithm selection bằng cách thử nghiệm nhiều thuật toán khác nhau và kết hợp chúng để tìm ra giải pháp tối ưu.\n- AutoML tự động hóa quy trình Model ensembling bằng cách kết hợp các mô hình tốt nhất đã được huấn luyện để tạo ra một mô hình mạnh mẽ hơn với hiệu suất dự đoán vượt trội.\n\n**Nội dung từ tài liệu:**\n# Học Máy (Machine Learning)\n## Học Sâu (Deep Learning)\n- **KL Divergence:** $KL(q_{\\phi}(z|x) || p(z))$ - Regularization, đảm bảo latent distribution gần prior $p(z) = \\mathcal{N}(0, I)$\n- $\beta$: Hyperparameter kiểm soát trade-off (β-VAE)\n\n**Tại sao KL divergence:**\n- Force latent space có cấu trúc tốt (continuous, smooth)\n- Cho phép generate by sampling $z \\sim \\mathcal{N}(0, I)$\n- Regularization effect\n\n**Ưu điểm VAE:**\n- **Generative:** Có thể tạo dữ liệu mới\n- **Smooth latent space:** Interpolation giữa samples có ý nghĩa\n- **Probabilistic framework:** Principled, có foundation lý thuyết\n\n**Nhược điểm:**\n- Reconstructions thường blurry (do Gaussian assumption)\n- Phức tạp hơn vanilla autoencoder\n\n**Ứng dụng:**\n- Image generation\n- Data augmentation\n- Anomaly detection (outliers có reconstruction error cao)\n- Semi-supervised learning\n\n**5. Contractive Autoencoder:**\n\nThêm penalty trên **derivative của latent representation** theo input.\n\n$$L = ||x - \\hat{x}||^2 + \\lambda ||\frac{\\partial f}{\\partial x}||_F^2$$\n\n**Mục tiêu:**\n- Latent representation **robust to small changes** trong input\n- Locally \"contract\" space\n\n**Lợi ích:**\n- Learn representations insensitive to small perturbations\n- Regularization effect\n\n**6. Convolutional Autoencoder:**\n\nSử dụng convolutional và pooling layers thay vì fully connected.\n\n**Encoder:**\n```\nConv → Pool → Conv → Pool → ...\n```\n\n**Decoder:**\n```\nConvTranspose (Upsampling) → ConvTranspose → ...\n```\n\n**Ưu điểm:**\n- **Ít parameters hơn** với images\n- **Preserve spatial structure**\n- Hiệu quả hơn với image data\n\n**Ứng dụng:**\n- Image compression\n- Image denoising\n- Super-resolution\n\n**Ứng Dụng Thực Tế của Autoencoders:**\n\n**1. Dimensionality Reduction:**\n- Alternative to PCA\n- Non-linear transformations\n- Visualization trong 2D/3D (t-SNE trên latent space)\n\n**2. Anomaly Detection:**\n- Train trên normal data\n- Anomalies có reconstruction error cao\n- Applications: Fraud detection, defect detection, network intrusion\n\n**3. Denoising:**\n- Remove noise từ images, audio, signals\n- Medical imaging\n- Old photo restoration\n\n**4. Feature Learning:**\n- Pre-training cho supervised tasks\n- Transfer learning\n- Extract meaningful representations\n\n**5. Generative Modeling (VAE):**\n- Generate new faces, artwork\n- Data augmentation\n- Creative applications\n\n**6. Image Compression:**\n- Learn compression schemes tốt hơn traditional methods\n- JPEG alternative\n\n**7. Information Retrieval:**\n- Semantic hashing\n- Similar image search (search trong latent space)\n\n**So sánh các loại Autoencoders:**\n\n| Type | Goal | Output | Use Case |\n|------|------|--------|----------|\n| Vanilla | Dim reduction | Deterministic | Compression, features |\n| Sparse | Interpretability | Sparse code | Feature learning |\n| Denoising | Robustness | Denoised | Denoising, robust features |\n| VAE | Generation | Probabilistic | Generation, sampling |\n| Contractive | Stability | Robust code | Robust representations |\n\n### Mạng Đối Sinh (Generative Adversarial Networks - GANs)\n\nGANs là framework cho generative models được phát minh bởi Ian Goodfellow et al. (2014). Ý tưởng: Hai mạng nơ-ron \"cạnh tranh\" với nhau để cải thiện.\n\n**Ẩn dụ:** \n- Generator giống như **tên làm tiền giả**\n- Discriminator giống như **cảnh sát phát hiện tiền giả**\n- Qua thời gian, cả hai đều giỏi hơn → tiền giả ngày càng thật\n\n**Các Thành Phần:**\n\n\n**Các khái niệm quan trọng:**\n- Feature learning (học đặc trưng) là quá trình tự động khám phá và trích xuất các biểu diễn hoặc đặc trưng hữu ích từ dữ liệu thô. Autoencoder là một công cụ mạnh mẽ cho feature learning, thực hiện quá trình này bằng cách học một biểu diễn nén (latent code) chứa các đặc trưng quan trọng của dữ liệu đầu vào. Autoencoders có thể được sử dụng để tiền huấn luyện (pre-training) cho các tác vụ có giám sát hoặc trong học chuyển giao (transfer learning) để trích xuất các biểu diễn có ý nghĩa.\n\n**Mối quan hệ:**\n- Feature Learning thông qua Autoencoders cho phép Pre-training các mô hình cho các tác vụ có giám sát.\n- Feature Learning thông qua Autoencoders hỗ trợ Transfer learning bằng cách trích xuất các biểu diễn có ý nghĩa.\n\n**Nội dung từ tài liệu:**\n# Học Máy (Machine Learning)\n## Học Không Giám Sát (Unsupervised Learning)\n- Matrix factorization (NMF, SVD)\n\n**5. Topic Modeling:**\n- Document clustering\n- Automatic tagging\n- Content organization\n- Trend detection\n\n**6. Gene Expression Analysis:**\n- Group similar genes\n- Identify cancer subtypes\n- Drug discovery\n- Understanding diseases\n\n**7. Social Network Analysis:**\n- Community detection\n- Influencer identification\n- Link prediction\n- Recommendation\n\n**8. Data Preprocessing:**\n- Feature extraction (PCA, ICA)\n- Noise reduction (autoencoders)\n- Data compression\n- Dimensionality reduction\n\n**9. Market Basket Analysis:**\n- Product recommendations\n- Store layout\n- Promotions\n- Cross-selling\n\n**10. Image Segmentation:**\n- Medical imaging\n- Object detection preparation\n- Video processing\n- Computer vision preprocessing\n\n---\n\n## Học Sâu (Deep Learning)\n\n### Giới Thiệu về Học Sâu\n\nHọc sâu (Deep Learning) là một nhánh con của học máy sử dụng mạng nơ-ron nhân tạo với nhiều lớp ẩn để học các biểu diễn phân cấp của dữ liệu. Khác với các phương pháp học máy truyền thống, học sâu có khả năng tự động trích xuất đặc trưng từ dữ liệu thô mà không cần kỹ thuật đặc trưng thủ công.\n\n**Đặc điểm chính:**\n- **Học biểu diễn phân cấp:** Các lớp đầu học các đặc trưng cấp thấp (cạnh, góc), các lớp sau học đặc trưng cấp cao hơn (hình dạng, đối tượng)\n- **Khả năng xử lý dữ liệu lớn:** Hiệu suất tăng theo lượng dữ liệu\n- **End-to-end learning:** Học trực tiếp từ đầu vào thô đến đầu ra mong muốn\n- **Tự động trích xuất đặc trưng:** Không cần thiết kế đặc trưng thủ công\n\n**Ứng dụng đã cách mạng hóa:**\n- Thị giác máy tính (nhận dạng ảnh, phát hiện đối tượng)\n- Xử lý ngôn ngữ tự nhiên (dịch máy, chatbot, sinh văn bản)\n- Nhận dạng giọng nói (trợ lý ảo, chuyển đổi giọng nói thành văn bản)\n- Y tế (chẩn đoán hình ảnh, phát triển thuốc)\n- Tự động hóa (xe tự lái, robot)\n\n### Mạng Nơ-ron Nhân Tạo (Artificial Neural Networks - ANN)\n\nMạng nơ-ron nhân tạo được lấy cảm hứng từ cách thức hoạt động của não người, trong đó các nơ-ron sinh học truyền tín hiệu cho nhau thông qua các synapse.\n\n### Perceptron - Đơn Vị Cơ Bản\n\nPerceptron là đơn vị mạng nơ-ron đơn giản nhất, được phát minh bởi Frank Rosenblatt năm 1958.\n\n**Công thức:**\n$$y = \\sigma(w^Tx + b)$$\n\nTrong đó:\n- $x = [x_1, x_2, ..., x_n]^T$: Vector đầu vào (các đặc trưng)\n- $w = [w_1, w_2, ..., w_n]^T$: Vector trọng số (weights)\n- $b$: Hệ số điều chỉnh (bias) - cho phép dịch chuyển hàm quyết định\n- $\\sigma$: Hàm kích hoạt (activation function)\n- $y$: Đầu ra dự đoán\n\n\n**Các khái niệm quan trọng:**\n- Automatic tagging là một ứng dụng của học không giám sát, tự động gán các thẻ (tags) hoặc từ khóa cho tài liệu hoặc dữ liệu khác dựa trên nội dung của chúng, hỗ trợ phân loại và tìm kiếm.\n\n**Mối quan hệ:**\n- Topic Modeling áp dụng Automatic tagging để gán nhãn tự động cho tài liệu."
        },
        "output_without_context": {
            "question": "Tại sao autoboxing trong Stack tham số hóa được coi là một phương pháp hiệu quả trong việc giảm thiểu lỗi thời gian chạy?",
            "answer": "Bởi vì nó tự động chuyển đổi giữa kiểu nguyên thủy và đối tượng mà không cần ép kiểu thủ công."
        }
    },
    {
        "topic_description": "Nắm vững công nghệ đánh giá biểu thức số học qua thuật toán dùng hai Stack. Học sinh sẽ được giới thiệu từng bước trong thuật toán và cần phản ánh hiểu biết của mình qua các tình huống cụ thể liên quan đến toán tử và giá trị.",
        "output_with_context": {
            "question": "Trong thuật toán đánh giá biểu thức số học sử dụng hai Stack, khi gặp một toán tử, thao tác nào cần được thực hiện để tính toán giá trị biểu thức?",
            "answer": "Lấy hai toán hạng trên cùng từ Stack, thực hiện phép toán và đẩy kết quả trở lại Stack.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return result\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\nprint(bfs(graph, 'A'))  # ['A', 'B', 'C', 'D', 'E', 'F']\n```\n\n**b) Quản lý tài nguyên chia sẻ:**\n- CPU scheduling\n- Disk scheduling\n- Printer queue\n\n**c) Xử lý bất đồng bộ:**\n- Message queue trong các hệ thống phân tán\n- Event handling trong GUI\n\n**d) Cache implementation:**\n- LRU (Least Recently Used) cache sử dụng kết hợp queue và hash map\n\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n```\n\n#### 2.6. So sánh Stack và Queue\n\n| Đặc điểm | Stack | Queue |\n|----------|-------|-------|\n| Nguyên tắc | LIFO | FIFO |\n| Thao tác chính | Push, Pop | Enqueue, Dequeue |\n| Truy cập | Chỉ ở đỉnh (top) | Ở đầu (front) và cuối (rear) |\n| Ứng dụng | Backtracking, Expression evaluation | BFS, Scheduling |\n| Cài đặt | Array, Linked List | Array (Circular), Linked List |\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Expression evaluation là bài toán đánh giá giá trị của một biểu thức toán học, thường sử dụng Stack để xử lý các toán tử và toán hạng.\n\n**Mối quan hệ:**\n- Stack được sử dụng để giải quyết bài toán đánh giá biểu thức.\n- Thuật toán evaluate_postfix sử dụng Stack để lưu trữ các toán hạng và kết quả trung gian trong quá trình tính giá trị biểu thức hậu tố.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\n# Test\nprint(is_valid_parentheses(\"()[]{}\"))  # True\nprint(is_valid_parentheses(\"([)]\"))    # False\n```\n\n**b) Chuyển đổi biểu thức Infix sang Postfix:**\n\n```python\ndef infix_to_postfix(expression):\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    stack = []\n    output = []\n    \n    for char in expression:\n        if char.isalnum():  # Toán hạng\n            output.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output.append(stack.pop())\n            stack.pop()  # Loại bỏ '('\n        else:  # Toán tử\n            while (stack and stack[-1] != '(' and\n                   precedence.get(stack[-1], 0) >= precedence.get(char, 0)):\n                output.append(stack.pop())\n            stack.append(char)\n    \n    while stack:\n        output.append(stack.pop())\n    \n    return ''.join(output)\n\n# Test\nprint(infix_to_postfix(\"A+B*C\"))  # ABC*+\n```\n\n**c) Tính giá trị biểu thức Postfix:**\n\n```python\ndef evaluate_postfix(expression):\n    stack = []\n    \n    for char in expression:\n        if char.isdigit():\n            stack.append(int(char))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            \n            if char == '+':\n                stack.append(a + b)\n            elif char == '-':\n                stack.append(a - b)\n            elif char == '*':\n                stack.append(a * b)\n            elif char == '/':\n                stack.append(a // b)\n    \n    return stack.pop()\n\n# Test\nprint(evaluate_postfix(\"23*5+\"))  # 11\n```\n\n**d) Thuật toán quay lui (Backtracking):**\nStack được sử dụng trong các thuật toán quay lui như giải mê cung, N-Queens, sudoku solver.\n\n**e) Đánh giá biểu thức số học và biên dịch:**\nCompiler sử dụng stack để parse và đánh giá các biểu thức.\n\n---\n\n### 2. Queue (Hàng đợi)\n\n#### 2.1. Khái niệm cơ bản\n\nQueue là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **FIFO (First In First Out)** - \"vào trước ra trước\". Phần tử được thêm vào đầu tiên sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Hàng người xếp hàng mua vé: Người đến trước được phục vụ trước\n- Hàng đợi in ấn: Tài liệu gửi in trước sẽ được in trước\n- Hàng đợi xử lý trong hệ thống: CPU scheduling, disk scheduling\n\n#### 2.2. Các thao tác cơ bản\n\n**a) Enqueue (Thêm vào):** Thêm phần tử vào cuối queue\n- Độ phức tạp: O(1)\n\n**b) Dequeue (Lấy ra):** Xóa và trả về phần tử ở đầu queue\n- Độ phức tạp: O(1)\n\n**c) Front/Peek:** Xem phần tử ở đầu queue mà không xóa\n- Độ phức tạp: O(1)\n\n**d) Rear:** Xem phần tử ở cuối queue\n- Độ phức tạp: O(1)\n\n**e) isEmpty:** Kiểm tra queue có rỗng không\n- Độ phức tạp: O(1)\n\n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- evaluate_postfix là thuật toán tính giá trị của biểu thức hậu tố (Postfix) sử dụng Stack. Thuật toán duyệt qua biểu thức, nếu gặp toán hạng thì đẩy vào stack, nếu gặp toán tử thì lấy hai toán hạng trên cùng từ stack ra để thực hiện phép toán, sau đó đẩy kết quả trở lại stack. Độ phức tạp thời gian O(n) với n là độ dài biểu thức, độ phức tạp không gian O(n) cho stack.\n\n**Mối quan hệ:**\n- Stack được sử dụng để giải quyết bài toán đánh giá biểu thức.\n- Thuật toán evaluate_postfix sử dụng Stack để lưu trữ các toán hạng và kết quả trung gian trong quá trình tính giá trị biểu thức hậu tố.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n**f) Size:** Trả về số lượng phần tử trong queue\n- Độ phức tạp: O(1)\n\n#### 2.3. Cài đặt Queue\n\n**Cách 1: Sử dụng mảng (Circular Queue)**\n\n```python\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = -1\n        self.rear = -1\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        if self.is_full():\n            raise Exception(\"Queue is full\")\n        \n        if self.front == -1:  # Queue rỗng\n            self.front = 0\n        \n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = item\n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.queue[self.front]\n        \n        if self.front == self.rear:  # Chỉ còn 1 phần tử\n            self.front = -1\n            self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue[self.front]\n    \n    def is_empty(self):\n        return self.front == -1\n    \n    def is_full(self):\n        return (self.rear + 1) % self.capacity == self.front\n    \n    def size(self):\n        return self.size_count\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass QueueLinkedList:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        new_node = Node(item)\n        \n        if self.rear is None:  # Queue rỗng\n            self.front = self.rear = new_node\n        else:\n            self.rear.next = new_node\n            self.rear = new_node\n        \n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.front.data\n        self.front = self.front.next\n        \n        if self.front is None:  # Queue trở nên rỗng\n            self.rear = None\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.front.data\n    \n    def is_empty(self):\n        return self.front is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 2.4. Các loại Queue đặc biệt\n\n**a) Deque (Double-ended Queue):**\nCho phép thêm và xóa phần tử ở cả hai đầu.\n\n```python\nfrom collections import deque\n\ndq = deque()\ndq.append(1)      # Thêm vào phải\ndq.appendleft(2)  # Thêm vào trái\ndq.pop()          # Xóa từ phải\ndq.popleft()      # Xóa từ trái\n```\n\n**b) Priority Queue (Hàng đợi ưu tiên):**\nMỗi phần tử có một độ ưu tiên, phần tử có độ ưu tiên cao nhất được xử lý trước.\n\n```python\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, item, priority):\n        heapq.heappush(self.heap, (priority, item))\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Priority Queue is empty\")\n        return heapq.heappop(self.heap)[1]\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 2.5. Ứng dụng của Queue\n\n**a) BFS (Breadth-First Search) trong đồ thị:**\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    \n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n\n**Mối quan hệ:**\n- Stack được sử dụng để giải quyết bài toán đánh giá biểu thức.\n- Thuật toán evaluate_postfix sử dụng Stack để lưu trữ các toán hạng và kết quả trung gian trong quá trình tính giá trị biểu thức hậu tố.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n\n## Stack & Queue\n\n### 1. Stack (Ngăn xếp)\n\n#### 1.1. Khái niệm cơ bản\n\nStack là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **LIFO (Last In First Out)** - \"vào sau ra trước\". Điều này có nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Chồng sách: Cuốn sách đặt lên trên cùng sẽ là cuốn được lấy ra đầu tiên\n- Lịch sử trình duyệt: Nút \"Back\" đưa bạn về trang trước đó theo thứ tự ngược lại\n- Undo/Redo trong text editor\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Push (Đẩy):** Thêm một phần tử vào đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Tăng con trở top lên 1 và thêm phần tử\n\n**b) Pop (Lấy ra):** Xóa và trả về phần tử ở đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Lấy phần tử tại top và giảm top xuống 1\n\n**c) Peek/Top:** Xem phần tử ở đỉnh stack mà không xóa\n- Độ phức tạp: O(1)\n\n**d) isEmpty:** Kiểm tra stack có rỗng không\n- Độ phức tạp: O(1)\n\n**e) Size:** Trả về số lượng phần tử trong stack\n- Độ phức tạp: O(1)\n\n#### 1.3. Cài đặt Stack\n\n**Cách 1: Sử dụng mảng (Array)**\n\n```python\nclass Stack:\n    def __init__(self, capacity=100):\n        self.capacity = capacity\n        self.stack = []\n        self.top = -1\n    \n    def push(self, item):\n        if self.top >= self.capacity - 1:\n            raise Exception(\"Stack Overflow\")\n        self.stack.append(item)\n        self.top += 1\n        return True\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.stack[self.top]\n        self.stack.pop()\n        self.top -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.stack[self.top]\n    \n    def is_empty(self):\n        return self.top == -1\n    \n    def size(self):\n        return self.top + 1\n    \n    def display(self):\n        if self.is_empty():\n            print(\"Stack is empty\")\n        else:\n            print(\"Stack elements:\", end=\" \")\n            for i in range(self.top, -1, -1):\n                print(self.stack[i], end=\" \")\n            print()\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass StackLinkedList:\n    def __init__(self):\n        self.head = None\n        self.size_count = 0\n    \n    def push(self, item):\n        new_node = Node(item)\n        new_node.next = self.head\n        self.head = new_node\n        self.size_count += 1\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.head.data\n        self.head = self.head.next\n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.head.data\n    \n    def is_empty(self):\n        return self.head is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 1.4. Ứng dụng của Stack\n\n**a) Kiểm tra dấu ngoặc hợp lệ:**\n\n```python\ndef is_valid_parentheses(s):\n    stack = []\n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n\n**Mối quan hệ:**\n- Stack được sử dụng để giải quyết bài toán đánh giá biểu thức.\n- Thuật toán evaluate_postfix sử dụng Stack để lưu trữ các toán hạng và kết quả trung gian trong quá trình tính giá trị biểu thức hậu tố."
        },
        "output_without_context": {
            "question": "Trong thuật toán hai stack của Dijkstra để đánh giá biểu thức số học, khi nào bạn nên sử dụng stack cho toán hạng và khi nào sử dụng stack cho toán tử?",
            "answer": "Sử dụng stack cho toán hạng khi gặp giá trị số và sử dụng stack cho toán tử khi gặp toán tử trong biểu thức."
        }
    }
]