[
    {
        "topic_description": "Khái niệm cây tìm kiếm nhị phân (BST) được định nghĩa và cách hoạt động của nó. Học sinh cần hiểu cấu trúc, cách chèn và tìm kiếm trong BST. Câu hỏi có thể kiểm tra định nghĩa của BST và phân tích chi phí của các hoạt động căn bản trong BST.",
        "output_with_context": {
            "question": "Cây tìm kiếm nhị phân (BST) là gì?",
            "answer": "Cây nhị phân mà trong đó mỗi node có giá trị nhỏ hơn node gốc ở cây con trái và lớn hơn node gốc ở cây con phải.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n        Chiều cao = số cạnh dài nhất từ root đến lá\n        \"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return -1\n        \n        left_height = self.height(node.left)\n        right_height = self.height(node.right)\n        \n        return max(left_height, right_height) + 1\n```\n\n#### 5.3. Count nodes\n\n```python\n    def count_nodes(self, node=None):\n        \"\"\"Đếm số node trong cây\"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return 0\n        \n        return 1 + self.count_nodes(node.left) + self.count_nodes(node.right)\n```\n\n#### 5.4. Lowest Common Ancestor (LCA)\n\n```python\n    def lca(self, val1, val2):\n        \"\"\"\n        Tìm node tổ tiên chung thấp nhất của 2 node\n        \"\"\"\n        def find_lca(node, val1, val2):\n            if node is None:\n                return None\n            \n            # Cả 2 đều nhỏ hơn root, LCA ở bên trái\n            if val1 < node.val and val2 < node.val:\n                return find_lca(node.left, val1, val2)\n            \n            # Cả 2 đều lớn hơn root, LCA ở bên phải\n            if val1 > node.val and val2 > node.val:\n                return find_lca(node.right, val1, val2)\n            \n            # Một bên trái, một bên phải hoặc một trong hai là root\n            return node\n        \n        return find_lca(self.root, val1, val2)\n```\n\n#### 5.5. Kth Smallest Element\n\n```python\n    def kth_smallest(self, k):\n        \"\"\"\n        Tìm phần tử nhỏ thứ k\n        Sử dụng inorder traversal\n        \"\"\"\n        def inorder(node):\n            if node is None:\n                return\n            \n            # Duyệt trái\n            inorder(node.left)\n            \n            # Xử lý node\n            self.count += 1\n            if self.count == k:\n                self.result = node.val\n                return\n            \n            # Duyệt phải\n            inorder(node.right)\n        \n        self.count = 0\n        self.result = None\n        inorder(self.root)\n        return self.result\n```\n\n#### 5.6. Range Sum\n\n```python\n    def range_sum(self, low, high):\n        \"\"\"\n        Tính tổng các node có giá trị trong [low, high]\n        \"\"\"\n        def sum_range(node):\n            if node is None:\n                return 0\n            \n            total = 0\n            \n            # Nếu node trong range\n            if low <= node.val <= high:\n                total += node.val\n            \n            # Tìm trong cây con trái nếu cần\n            if node.val > low:\n                total += sum_range(node.left)\n            \n            # Tìm trong cây con phải nếu cần\n            if node.val < high:\n                total += sum_range(node.right)\n            \n            return total\n        \n        return sum_range(self.root)\n```\n\n---\n\n### 6. Ứng dụng thực tế\n\n#### 6.1. Build BST từ Array\n\n```python\ndef build_bst_from_array(arr):\n    \"\"\"Xây dựng BST từ mảng\"\"\"\n    bst = BST()\n    for val in arr:\n        bst.insert(val)\n    return bst\n\n# Test\narr = [8, 3, 10, 1, 6, 14, 4, 7, 13]\nbst = build_bst_from_array(arr)\nprint(\"Inorder:\", bst.inorder())\n```\n\n#### 6.2. Build Balanced BST từ Sorted Array\n\n```python\ndef sorted_array_to_bst(arr):\n    \"\"\"\n    Xây dựng BST cân bằng từ mảng đã sắp xếp\n    Chọn phần tử giữa làm root\n    \"\"\"\n    def build(left, right):\n        if left > right:\n            return None\n        \n        mid = (left + right) // 2\n        node = TreeNode(arr[mid])\n        \n        node.left = build(left, mid - 1)\n        node.right = build(mid + 1, right)\n        \n        return node\n    \n    bst = BST()\n\n**Các khái niệm quan trọng:**\n- TreeNode là một thành phần cơ bản của cấu trúc dữ liệu cây, đại diện cho một node (hoặc nút) trong cây nhị phân. Mỗi TreeNode thường chứa một giá trị (val) và các con trỏ (left, right) trỏ đến các node con trái và phải của nó. Trong Cây tìm kiếm nhị phân (BST), TreeNode được sử dụng để xây dựng cây.\n- build_bst_from_array là thuật toán xây dựng một Binary Search Tree từ một mảng các phần tử. Thuật toán này hoạt động bằng cách lặp qua từng phần tử trong mảng và chèn chúng vào BST bằng phép toán insert cơ bản của BST.\n\n**Mối quan hệ:**\n- Thuật toán build_bst_from_array xây dựng một Binary Search Tree từ một mảng.\n- Thuật toán build_bst_from_array có độ phức tạp thời gian O(n²) trong trường hợp xấu nhất khi mảng đầu vào đã được sắp xếp (tăng hoặc giảm), dẫn đến BST bị suy biến thành dạng danh sách liên kết, và mỗi phép chèn mất O(n).\n- Thuật toán build_bst_from_array có độ phức tạp thời gian O(n log n) trong trường hợp trung bình khi các phần tử được chèn tạo thành một BST tương đối cân bằng, với mỗi phép chèn mất O(log n).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n| Delete | O(log n) | O(log n) avg, O(n) worst | O(n) |\n| Build | O(n) | O(n log n) | O(n log n) |\n\n**Khi nào dùng Heap?**\n- ✅ Cần extract min/max nhiều lần\n- ✅ Priority Queue\n- ✅ Tìm k largest/smallest elements\n- ✅ Median trong stream\n- ✅ Scheduling problems\n\n**Khi nào không dùng Heap?**\n- ❌ Cần search phần tử cụ thể (dùng BST)\n- ❌ Cần duyệt theo thứ tự (dùng BST)\n- ❌ Cần truy cập ngẫu nhiên (dùng array)\n\n---\n\n## Binary Search Tree \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Binary Search Tree (BST)** là một cây nhị phân có tính chất đặc biệt:\n- Tất cả các node trong cây con trái có giá trị **< node gốc**\n- Tất cả các node trong cây con phải có giá trị **> node gốc**\n- Cây con trái và cây con phải cũng là BST\n\n**Ví dụ BST hợp lệ:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  7 13\n```\n\n**Không phải BST:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  9 13    <- 9 > 8, không thể ở cây con trái\n```\n\n#### 1.2. Tính chất quan trọng\n\n**a) Duyệt Inorder cho thứ tự tăng dần:**\n- Duyệt BST theo Inorder (Left-Root-Right) cho dãy số tăng dần\n- Ví dụ trên: 1, 3, 4, 6, 7, 8, 10, 13, 14\n\n**b) Tìm kiếm hiệu quả:**\n- Có thể loại bỏ 1 nửa cây ở mỗi bước\n- Average case: O(log n)\n- Worst case: O(n) - cây thoái hóa thành linked list\n\n**c) Dynamic data structure:**\n- Dễ dàng insert và delete\n- Không cần biết trước kích thước\n\n#### 1.3. Ứng dụng\n\n- **Database indexing:** B-Tree, B+ Tree (biến thể của BST)\n- **File system:** Tổ chức thư mục\n- **Expression parsing:** Cây biểu thức\n- **Priority Queue:** Có thể implement bằng BST\n- **Auto-complete:** Trie (dạng đặc biệt của cây)\n\n---\n\n### 2. Cấu trúc Node và BST\n\n#### 2.1. Định nghĩa Node\n\n```python\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n    \n    def __repr__(self):\n        return f\"Node({self.val})\"\n```\n\n#### 2.2. Lớp BST\n\n```python\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def is_empty(self):\n        return self.root is None\n    \n    def get_root(self):\n        return self.root\n```\n\n---\n\n### 3. Các thao tác cơ bản\n\n#### 3.1. Search (Tìm kiếm)\n\n```python\n    def search(self, val):\n        \"\"\"\n        Tìm node có giá trị val\n        Time: O(h) với h là chiều cao cây\n        Average: O(log n), Worst: O(n)\n        \"\"\"\n        return self._search_recursive(self.root, val)\n    \n\n**Các khái niệm quan trọng:**\n- Search là phép toán tìm kiếm một phần tử hoặc giá trị cụ thể trong cấu trúc dữ liệu. Trong Binary Search Tree (BST), phép toán này bắt đầu từ gốc, so sánh giá trị cần tìm với giá trị của node hiện tại. Nếu giá trị cần tìm nhỏ hơn, di chuyển sang cây con trái; nếu lớn hơn, di chuyển sang cây con phải. Nếu bằng, phần tử được tìm thấy. Độ phức tạp thời gian của Search trong BST là O(h), trong đó h là chiều cao của cây. Cụ thể: Best case là O(1) (tìm thấy ở gốc), Average case là O(log n) (đối với cây cân bằng), và Worst case là O(n) (đối với cây thoái hóa). Đối với Min/Max Heap, độ phức tạp của Search là O(n), khiến chúng không hiệu quả cho việc tìm kiếm phần tử cụ thể. Trong Sorted Array, Search có độ phức tạp O(log n) khi sử dụng tìm kiếm nhị phân.\n- TreeNode là một thành phần cơ bản của cấu trúc dữ liệu cây, đại diện cho một node (hoặc nút) trong cây nhị phân. Mỗi TreeNode thường chứa một giá trị (val) và các con trỏ (left, right) trỏ đến các node con trái và phải của nó. Trong Cây tìm kiếm nhị phân (BST), TreeNode được sử dụng để xây dựng cây.\n\n**Mối quan hệ:**\n- Array (sorted) có độ phức tạp O(log n) cho phép toán Search.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n    def _search_recursive(self, node, val):\n        # Base case\n        if node is None or node.val == val:\n            return node\n        \n        # Tìm trong cây con trái\n        if val < node.val:\n            return self._search_recursive(node.left, val)\n        \n        # Tìm trong cây con phải\n        return self._search_recursive(node.right, val)\n    \n    # Cách 2: Iterative\n    def search_iterative(self, val):\n        \"\"\"Tìm kiếm không đệ quy\"\"\"\n        current = self.root\n        \n        while current is not None:\n            if val == current.val:\n                return current\n            elif val < current.val:\n                current = current.left\n            else:\n                current = current.right\n        \n        return None\n```\n\n**Minh họa:**\n```\nTìm 6 trong BST:\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n\nBước 1: 6 < 8, đi sang trái\nBước 2: 6 > 3, đi sang phải\nBước 3: 6 == 6, tìm thấy!\n```\n\n#### 3.2. Insert (Thêm node)\n\n```python\n    def insert(self, val):\n        \"\"\"\n        Thêm node mới với giá trị val\n        Time: O(h)\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(val)\n        else:\n            self._insert_recursive(self.root, val)\n    \n    def _insert_recursive(self, node, val):\n        # Nếu giá trị nhỏ hơn, chèn vào trái\n        if val < node.val:\n            if node.left is None:\n                node.left = TreeNode(val)\n            else:\n                self._insert_recursive(node.left, val)\n        \n        # Nếu giá trị lớn hơn, chèn vào phải\n        elif val > node.val:\n            if node.right is None:\n                node.right = TreeNode(val)\n            else:\n                self._insert_recursive(node.right, val)\n        \n        # Nếu bằng, không làm gì (hoặc update)\n    \n    # Cách 2: Iterative\n    def insert_iterative(self, val):\n        \"\"\"Thêm node không đệ quy\"\"\"\n        new_node = TreeNode(val)\n        \n        if self.root is None:\n            self.root = new_node\n            return\n        \n        current = self.root\n        while True:\n            if val < current.val:\n                if current.left is None:\n                    current.left = new_node\n                    break\n                current = current.left\n            elif val > current.val:\n                if current.right is None:\n                    current.right = new_node\n                    break\n                current = current.right\n            else:\n                break  # Đã tồn tại\n```\n\n**Minh họa:**\n```\nInsert 5 vào BST:\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n\nBước 1: 5 < 8, đi trái\nBước 2: 5 > 3, đi phải\nBước 3: 5 < 6, chèn vào trái của 6\n\nKết quả:\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       /\n      5\n```\n\n#### 3.3. Find Min và Find Max\n\n```python\n    def find_min(self, node=None):\n        \"\"\"\n        Tìm node có giá trị nhỏ nhất\n        Đi sang trái cho đến hết\n        Time: O(h)\n        \"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return None\n        \n        while node.left is not None:\n            node = node.left\n        \n        return node\n    \n    def find_max(self, node=None):\n        \"\"\"\n        Tìm node có giá trị lớn nhất\n        Đi sang phải cho đến hết\n        Time: O(h)\n        \"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return None\n        \n        while node.right is not None:\n            node = node.right\n        \n        return node\n```\n\n#### 3.4. Delete (Xóa node)\n\n\n**Các khái niệm quan trọng:**\n- Search là phép toán tìm kiếm một phần tử hoặc giá trị cụ thể trong cấu trúc dữ liệu. Trong Binary Search Tree (BST), phép toán này bắt đầu từ gốc, so sánh giá trị cần tìm với giá trị của node hiện tại. Nếu giá trị cần tìm nhỏ hơn, di chuyển sang cây con trái; nếu lớn hơn, di chuyển sang cây con phải. Nếu bằng, phần tử được tìm thấy. Độ phức tạp thời gian của Search trong BST là O(h), trong đó h là chiều cao của cây. Cụ thể: Best case là O(1) (tìm thấy ở gốc), Average case là O(log n) (đối với cây cân bằng), và Worst case là O(n) (đối với cây thoái hóa). Đối với Min/Max Heap, độ phức tạp của Search là O(n), khiến chúng không hiệu quả cho việc tìm kiếm phần tử cụ thể. Trong Sorted Array, Search có độ phức tạp O(log n) khi sử dụng tìm kiếm nhị phân.\n- TreeNode là một thành phần cơ bản của cấu trúc dữ liệu cây, đại diện cho một node (hoặc nút) trong cây nhị phân. Mỗi TreeNode thường chứa một giá trị (val) và các con trỏ (left, right) trỏ đến các node con trái và phải của nó. Trong Cây tìm kiếm nhị phân (BST), TreeNode được sử dụng để xây dựng cây.\n\n**Mối quan hệ:**\n- Array (sorted) có độ phức tạp O(log n) cho phép toán Search.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n    bst.root = build(0, len(arr) - 1)\n    return bst\n\n# Test\narr = [1, 2, 3, 4, 5, 6, 7]\nbst = sorted_array_to_bst(arr)\nprint(\"Level order:\", bst.level_order())  # [4, 2, 6, 1, 3, 5, 7]\n```\n\n#### 6.3. Serialize và Deserialize BST\n\n```python\ndef serialize(root):\n    \"\"\"Chuyển BST thành string\"\"\"\n    def preorder(node):\n        if node is None:\n            result.append('#')\n            return\n        result.append(str(node.val))\n        preorder(node.left)\n        preorder(node.right)\n    \n    result = []\n    preorder(root)\n    return ','.join(result)\n\ndef deserialize(data):\n    \"\"\"Xây dựng lại BST từ string\"\"\"\n    def build():\n        val = next(vals)\n        if val == '#':\n            return None\n        \n        node = TreeNode(int(val))\n        node.left = build()\n        node.right = build()\n        return node\n    \n    vals = iter(data.split(','))\n    return build()\n\n# Test\nbst = build_bst_from_array([8, 3, 10, 1, 6, 14])\nserialized = serialize(bst.root)\nprint(\"Serialized:\", serialized)\n\nroot = deserialize(serialized)\nbst2 = BST()\nbst2.root = root\nprint(\"Inorder after deserialize:\", bst2.inorder())\n```\n\n---\n\n### 7. Phân tích độ phức tạp\n\n| Thao tác | Average | Worst | Best |\n|----------|---------|-------|------|\n| Search | O(log n) | O(n) | O(1) |\n| Insert | O(log n) | O(n) | O(1) |\n| Delete | O(log n) | O(n) | O(1) |\n| Find Min/Max | O(log n) | O(n) | O(1) |\n| Inorder | O(n) | O(n) | O(n) |\n| Space | O(n) | O(n) | O(n) |\n\n**Worst case xảy ra khi:** Cây thoái hóa thành linked list (insert các phần tử đã sắp xếp)\n\n```\nCây cân bằng:        Cây thoái hóa:\n      4                   1\n     / \\                   \\\n    2   6                   2\n   / \\ / \\                   \\\n  1  3 5  7                   3\n                               \\\n                                4\nHeight: log n              Height: n\n```\n\n**Giải pháp:** Sử dụng **Self-balancing BST** như AVL Tree, Red-Black Tree\n\n---\n\n### 8. So sánh với các cấu trúc khác\n\n| Cấu trúc | Search | Insert | Delete | Sorted | Space |\n|----------|--------|--------|--------|--------|-------|\n| Array (unsorted) | O(n) | O(1) | O(n) | ❌ | O(n) |\n| Array (sorted) | O(log n) | O(n) | O(n) | ✅ | O(n) |\n| Linked List | O(n) | O(1) | O(n) | ❌ | O(n) |\n| BST | O(log n) | O(log n) | O(log n) | ✅ | O(n) |\n| Hash Table | O(1) | O(1) | O(1) | ❌ | O(n) |\n\n**Khi nào dùng BST?**\n- ✅ Cần duy trì thứ tự sorted\n- ✅ Cần range query (tìm trong khoảng)\n- ✅ Cần tìm successor/predecessor\n- ✅ Dynamic data (thêm/xóa thường xuyên)\n- ✅ Cần kth smallest/largest\n\n**Khi nào không dùng BST?**\n- ❌ Chỉ cần search nhanh → Hash Table\n- ❌ Truy cập theo index → Array\n- ❌ Dữ liệu đã sắp xếp → Sorted Array\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Search là phép toán tìm kiếm một phần tử hoặc giá trị cụ thể trong cấu trúc dữ liệu. Trong Binary Search Tree (BST), phép toán này bắt đầu từ gốc, so sánh giá trị cần tìm với giá trị của node hiện tại. Nếu giá trị cần tìm nhỏ hơn, di chuyển sang cây con trái; nếu lớn hơn, di chuyển sang cây con phải. Nếu bằng, phần tử được tìm thấy. Độ phức tạp thời gian của Search trong BST là O(h), trong đó h là chiều cao của cây. Cụ thể: Best case là O(1) (tìm thấy ở gốc), Average case là O(log n) (đối với cây cân bằng), và Worst case là O(n) (đối với cây thoái hóa). Đối với Min/Max Heap, độ phức tạp của Search là O(n), khiến chúng không hiệu quả cho việc tìm kiếm phần tử cụ thể. Trong Sorted Array, Search có độ phức tạp O(log n) khi sử dụng tìm kiếm nhị phân.\n- Find Min/Max là phép toán tìm phần tử nhỏ nhất hoặc lớn nhất trong cấu trúc dữ liệu Binary Search Tree (BST). Để tìm giá trị nhỏ nhất (Min), phép toán di chuyển từ gốc xuống node con trái cho đến khi không còn node con trái nào nữa, vì node nhỏ nhất luôn nằm ở tận cùng bên trái của cây. Tương tự, để tìm giá trị lớn nhất (Max), phép toán đi theo nhánh phải nhất. Độ phức tạp thời gian của phép toán này là O(h), trong đó h là chiều cao của cây. Cụ thể, Best case là O(1) (nếu phần tử min/max là gốc), Average case là O(log n) (đối với cây cân bằng), và Worst case là O(n) (đối với cây thoái hóa).\n\n**Mối quan hệ:**\n- Array (sorted) có độ phức tạp O(log n) cho phép toán Search."
        },
        "output_without_context": {
            "question": "Cây tìm kiếm nhị phân (BST) là gì?",
            "answer": "Cây tìm kiếm nhị phân là một cấu trúc dữ liệu cây trong đó mỗi nút có tối đa hai con, với giá trị của nút con bên trái nhỏ hơn giá trị của nút cha và giá trị của nút con bên phải lớn hơn giá trị của nút cha."
        }
    },
    {
        "topic_description": "Chủ đề này khám phá cách biểu diễn cấu trúc BST trong Java. Học sinh nên hiểu cách xây dựng Node và BST class, cũng như ý nghĩa của các thành phần trong mã. Câu hỏi có thể kiểm tra kiến thức về các thành phần và định nghĩa trong Java.",
        "output_with_context": {
            "question": "Trong cấu trúc dữ liệu cây nhị phân tìm kiếm (BST), điều kiện nào sau đây là đúng với một node gốc?",
            "answer": "Tất cả các node trong cây con trái có giá trị nhỏ hơn node gốc và tất cả các node trong cây con phải có giá trị lớn hơn node gốc.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n| Delete | O(log n) | O(log n) avg, O(n) worst | O(n) |\n| Build | O(n) | O(n log n) | O(n log n) |\n\n**Khi nào dùng Heap?**\n- ✅ Cần extract min/max nhiều lần\n- ✅ Priority Queue\n- ✅ Tìm k largest/smallest elements\n- ✅ Median trong stream\n- ✅ Scheduling problems\n\n**Khi nào không dùng Heap?**\n- ❌ Cần search phần tử cụ thể (dùng BST)\n- ❌ Cần duyệt theo thứ tự (dùng BST)\n- ❌ Cần truy cập ngẫu nhiên (dùng array)\n\n---\n\n## Binary Search Tree \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Binary Search Tree (BST)** là một cây nhị phân có tính chất đặc biệt:\n- Tất cả các node trong cây con trái có giá trị **< node gốc**\n- Tất cả các node trong cây con phải có giá trị **> node gốc**\n- Cây con trái và cây con phải cũng là BST\n\n**Ví dụ BST hợp lệ:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  7 13\n```\n\n**Không phải BST:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  9 13    <- 9 > 8, không thể ở cây con trái\n```\n\n#### 1.2. Tính chất quan trọng\n\n**a) Duyệt Inorder cho thứ tự tăng dần:**\n- Duyệt BST theo Inorder (Left-Root-Right) cho dãy số tăng dần\n- Ví dụ trên: 1, 3, 4, 6, 7, 8, 10, 13, 14\n\n**b) Tìm kiếm hiệu quả:**\n- Có thể loại bỏ 1 nửa cây ở mỗi bước\n- Average case: O(log n)\n- Worst case: O(n) - cây thoái hóa thành linked list\n\n**c) Dynamic data structure:**\n- Dễ dàng insert và delete\n- Không cần biết trước kích thước\n\n#### 1.3. Ứng dụng\n\n- **Database indexing:** B-Tree, B+ Tree (biến thể của BST)\n- **File system:** Tổ chức thư mục\n- **Expression parsing:** Cây biểu thức\n- **Priority Queue:** Có thể implement bằng BST\n- **Auto-complete:** Trie (dạng đặc biệt của cây)\n\n---\n\n### 2. Cấu trúc Node và BST\n\n#### 2.1. Định nghĩa Node\n\n```python\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n    \n    def __repr__(self):\n        return f\"Node({self.val})\"\n```\n\n#### 2.2. Lớp BST\n\n```python\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def is_empty(self):\n        return self.root is None\n    \n    def get_root(self):\n        return self.root\n```\n\n---\n\n### 3. Các thao tác cơ bản\n\n#### 3.1. Search (Tìm kiếm)\n\n```python\n    def search(self, val):\n        \"\"\"\n        Tìm node có giá trị val\n        Time: O(h) với h là chiều cao cây\n        Average: O(log n), Worst: O(n)\n        \"\"\"\n        return self._search_recursive(self.root, val)\n    \n\n**Các khái niệm quan trọng:**\n- Root là node trên cùng của một cấu trúc dữ liệu cây. Trong BST, root là điểm bắt đầu cho tất cả các phép toán như tìm kiếm, chèn, xóa. Nếu root là None, cây được coi là rỗng.\n- TreeNode là một thành phần cơ bản của cấu trúc dữ liệu cây, đại diện cho một node (hoặc nút) trong cây nhị phân. Mỗi TreeNode thường chứa một giá trị (val) và các con trỏ (left, right) trỏ đến các node con trái và phải của nó. Trong Cây tìm kiếm nhị phân (BST), TreeNode được sử dụng để xây dựng cây.\n- get_root là phép toán trả về node gốc của cấu trúc dữ liệu cây. Đối với BST, get_root trả về node root hiện tại của cây.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n    def _search_recursive(self, node, val):\n        # Base case\n        if node is None or node.val == val:\n            return node\n        \n        # Tìm trong cây con trái\n        if val < node.val:\n            return self._search_recursive(node.left, val)\n        \n        # Tìm trong cây con phải\n        return self._search_recursive(node.right, val)\n    \n    # Cách 2: Iterative\n    def search_iterative(self, val):\n        \"\"\"Tìm kiếm không đệ quy\"\"\"\n        current = self.root\n        \n        while current is not None:\n            if val == current.val:\n                return current\n            elif val < current.val:\n                current = current.left\n            else:\n                current = current.right\n        \n        return None\n```\n\n**Minh họa:**\n```\nTìm 6 trong BST:\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n\nBước 1: 6 < 8, đi sang trái\nBước 2: 6 > 3, đi sang phải\nBước 3: 6 == 6, tìm thấy!\n```\n\n#### 3.2. Insert (Thêm node)\n\n```python\n    def insert(self, val):\n        \"\"\"\n        Thêm node mới với giá trị val\n        Time: O(h)\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(val)\n        else:\n            self._insert_recursive(self.root, val)\n    \n    def _insert_recursive(self, node, val):\n        # Nếu giá trị nhỏ hơn, chèn vào trái\n        if val < node.val:\n            if node.left is None:\n                node.left = TreeNode(val)\n            else:\n                self._insert_recursive(node.left, val)\n        \n        # Nếu giá trị lớn hơn, chèn vào phải\n        elif val > node.val:\n            if node.right is None:\n                node.right = TreeNode(val)\n            else:\n                self._insert_recursive(node.right, val)\n        \n        # Nếu bằng, không làm gì (hoặc update)\n    \n    # Cách 2: Iterative\n    def insert_iterative(self, val):\n        \"\"\"Thêm node không đệ quy\"\"\"\n        new_node = TreeNode(val)\n        \n        if self.root is None:\n            self.root = new_node\n            return\n        \n        current = self.root\n        while True:\n            if val < current.val:\n                if current.left is None:\n                    current.left = new_node\n                    break\n                current = current.left\n            elif val > current.val:\n                if current.right is None:\n                    current.right = new_node\n                    break\n                current = current.right\n            else:\n                break  # Đã tồn tại\n```\n\n**Minh họa:**\n```\nInsert 5 vào BST:\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n\nBước 1: 5 < 8, đi trái\nBước 2: 5 > 3, đi phải\nBước 3: 5 < 6, chèn vào trái của 6\n\nKết quả:\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       /\n      5\n```\n\n#### 3.3. Find Min và Find Max\n\n```python\n    def find_min(self, node=None):\n        \"\"\"\n        Tìm node có giá trị nhỏ nhất\n        Đi sang trái cho đến hết\n        Time: O(h)\n        \"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return None\n        \n        while node.left is not None:\n            node = node.left\n        \n        return node\n    \n    def find_max(self, node=None):\n        \"\"\"\n        Tìm node có giá trị lớn nhất\n        Đi sang phải cho đến hết\n        Time: O(h)\n        \"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return None\n        \n        while node.right is not None:\n            node = node.right\n        \n        return node\n```\n\n#### 3.4. Delete (Xóa node)\n\n\n**Các khái niệm quan trọng:**\n- TreeNode là một thành phần cơ bản của cấu trúc dữ liệu cây, đại diện cho một node (hoặc nút) trong cây nhị phân. Mỗi TreeNode thường chứa một giá trị (val) và các con trỏ (left, right) trỏ đến các node con trái và phải của nó. Trong Cây tìm kiếm nhị phân (BST), TreeNode được sử dụng để xây dựng cây.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n        Chiều cao = số cạnh dài nhất từ root đến lá\n        \"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return -1\n        \n        left_height = self.height(node.left)\n        right_height = self.height(node.right)\n        \n        return max(left_height, right_height) + 1\n```\n\n#### 5.3. Count nodes\n\n```python\n    def count_nodes(self, node=None):\n        \"\"\"Đếm số node trong cây\"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return 0\n        \n        return 1 + self.count_nodes(node.left) + self.count_nodes(node.right)\n```\n\n#### 5.4. Lowest Common Ancestor (LCA)\n\n```python\n    def lca(self, val1, val2):\n        \"\"\"\n        Tìm node tổ tiên chung thấp nhất của 2 node\n        \"\"\"\n        def find_lca(node, val1, val2):\n            if node is None:\n                return None\n            \n            # Cả 2 đều nhỏ hơn root, LCA ở bên trái\n            if val1 < node.val and val2 < node.val:\n                return find_lca(node.left, val1, val2)\n            \n            # Cả 2 đều lớn hơn root, LCA ở bên phải\n            if val1 > node.val and val2 > node.val:\n                return find_lca(node.right, val1, val2)\n            \n            # Một bên trái, một bên phải hoặc một trong hai là root\n            return node\n        \n        return find_lca(self.root, val1, val2)\n```\n\n#### 5.5. Kth Smallest Element\n\n```python\n    def kth_smallest(self, k):\n        \"\"\"\n        Tìm phần tử nhỏ thứ k\n        Sử dụng inorder traversal\n        \"\"\"\n        def inorder(node):\n            if node is None:\n                return\n            \n            # Duyệt trái\n            inorder(node.left)\n            \n            # Xử lý node\n            self.count += 1\n            if self.count == k:\n                self.result = node.val\n                return\n            \n            # Duyệt phải\n            inorder(node.right)\n        \n        self.count = 0\n        self.result = None\n        inorder(self.root)\n        return self.result\n```\n\n#### 5.6. Range Sum\n\n```python\n    def range_sum(self, low, high):\n        \"\"\"\n        Tính tổng các node có giá trị trong [low, high]\n        \"\"\"\n        def sum_range(node):\n            if node is None:\n                return 0\n            \n            total = 0\n            \n            # Nếu node trong range\n            if low <= node.val <= high:\n                total += node.val\n            \n            # Tìm trong cây con trái nếu cần\n            if node.val > low:\n                total += sum_range(node.left)\n            \n            # Tìm trong cây con phải nếu cần\n            if node.val < high:\n                total += sum_range(node.right)\n            \n            return total\n        \n        return sum_range(self.root)\n```\n\n---\n\n### 6. Ứng dụng thực tế\n\n#### 6.1. Build BST từ Array\n\n```python\ndef build_bst_from_array(arr):\n    \"\"\"Xây dựng BST từ mảng\"\"\"\n    bst = BST()\n    for val in arr:\n        bst.insert(val)\n    return bst\n\n# Test\narr = [8, 3, 10, 1, 6, 14, 4, 7, 13]\nbst = build_bst_from_array(arr)\nprint(\"Inorder:\", bst.inorder())\n```\n\n#### 6.2. Build Balanced BST từ Sorted Array\n\n```python\ndef sorted_array_to_bst(arr):\n    \"\"\"\n    Xây dựng BST cân bằng từ mảng đã sắp xếp\n    Chọn phần tử giữa làm root\n    \"\"\"\n    def build(left, right):\n        if left > right:\n            return None\n        \n        mid = (left + right) // 2\n        node = TreeNode(arr[mid])\n        \n        node.left = build(left, mid - 1)\n        node.right = build(mid + 1, right)\n        \n        return node\n    \n    bst = BST()\n\n**Các khái niệm quan trọng:**\n- TreeNode là một thành phần cơ bản của cấu trúc dữ liệu cây, đại diện cho một node (hoặc nút) trong cây nhị phân. Mỗi TreeNode thường chứa một giá trị (val) và các con trỏ (left, right) trỏ đến các node con trái và phải của nó. Trong Cây tìm kiếm nhị phân (BST), TreeNode được sử dụng để xây dựng cây.\n- build_bst_from_array là thuật toán xây dựng một Binary Search Tree từ một mảng các phần tử. Thuật toán này hoạt động bằng cách lặp qua từng phần tử trong mảng và chèn chúng vào BST bằng phép toán insert cơ bản của BST.\n\n**Mối quan hệ:**\n- Thuật toán build_bst_from_array xây dựng một Binary Search Tree từ một mảng.\n- Thuật toán build_bst_from_array có độ phức tạp thời gian O(n²) trong trường hợp xấu nhất khi mảng đầu vào đã được sắp xếp (tăng hoặc giảm), dẫn đến BST bị suy biến thành dạng danh sách liên kết, và mỗi phép chèn mất O(n).\n- Thuật toán build_bst_from_array có độ phức tạp thời gian O(n log n) trong trường hợp trung bình khi các phần tử được chèn tạo thành một BST tương đối cân bằng, với mỗi phép chèn mất O(log n).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n    bst.root = build(0, len(arr) - 1)\n    return bst\n\n# Test\narr = [1, 2, 3, 4, 5, 6, 7]\nbst = sorted_array_to_bst(arr)\nprint(\"Level order:\", bst.level_order())  # [4, 2, 6, 1, 3, 5, 7]\n```\n\n#### 6.3. Serialize và Deserialize BST\n\n```python\ndef serialize(root):\n    \"\"\"Chuyển BST thành string\"\"\"\n    def preorder(node):\n        if node is None:\n            result.append('#')\n            return\n        result.append(str(node.val))\n        preorder(node.left)\n        preorder(node.right)\n    \n    result = []\n    preorder(root)\n    return ','.join(result)\n\ndef deserialize(data):\n    \"\"\"Xây dựng lại BST từ string\"\"\"\n    def build():\n        val = next(vals)\n        if val == '#':\n            return None\n        \n        node = TreeNode(int(val))\n        node.left = build()\n        node.right = build()\n        return node\n    \n    vals = iter(data.split(','))\n    return build()\n\n# Test\nbst = build_bst_from_array([8, 3, 10, 1, 6, 14])\nserialized = serialize(bst.root)\nprint(\"Serialized:\", serialized)\n\nroot = deserialize(serialized)\nbst2 = BST()\nbst2.root = root\nprint(\"Inorder after deserialize:\", bst2.inorder())\n```\n\n---\n\n### 7. Phân tích độ phức tạp\n\n| Thao tác | Average | Worst | Best |\n|----------|---------|-------|------|\n| Search | O(log n) | O(n) | O(1) |\n| Insert | O(log n) | O(n) | O(1) |\n| Delete | O(log n) | O(n) | O(1) |\n| Find Min/Max | O(log n) | O(n) | O(1) |\n| Inorder | O(n) | O(n) | O(n) |\n| Space | O(n) | O(n) | O(n) |\n\n**Worst case xảy ra khi:** Cây thoái hóa thành linked list (insert các phần tử đã sắp xếp)\n\n```\nCây cân bằng:        Cây thoái hóa:\n      4                   1\n     / \\                   \\\n    2   6                   2\n   / \\ / \\                   \\\n  1  3 5  7                   3\n                               \\\n                                4\nHeight: log n              Height: n\n```\n\n**Giải pháp:** Sử dụng **Self-balancing BST** như AVL Tree, Red-Black Tree\n\n---\n\n### 8. So sánh với các cấu trúc khác\n\n| Cấu trúc | Search | Insert | Delete | Sorted | Space |\n|----------|--------|--------|--------|--------|-------|\n| Array (unsorted) | O(n) | O(1) | O(n) | ❌ | O(n) |\n| Array (sorted) | O(log n) | O(n) | O(n) | ✅ | O(n) |\n| Linked List | O(n) | O(1) | O(n) | ❌ | O(n) |\n| BST | O(log n) | O(log n) | O(log n) | ✅ | O(n) |\n| Hash Table | O(1) | O(1) | O(1) | ❌ | O(n) |\n\n**Khi nào dùng BST?**\n- ✅ Cần duy trì thứ tự sorted\n- ✅ Cần range query (tìm trong khoảng)\n- ✅ Cần tìm successor/predecessor\n- ✅ Dynamic data (thêm/xóa thường xuyên)\n- ✅ Cần kth smallest/largest\n\n**Khi nào không dùng BST?**\n- ❌ Chỉ cần search nhanh → Hash Table\n- ❌ Truy cập theo index → Array\n- ❌ Dữ liệu đã sắp xếp → Sorted Array\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Self-balancing BST (Cây tìm kiếm nhị phân tự cân bằng) là một loại BST đặc biệt có khả năng tự động điều chỉnh cấu trúc của nó (thông qua các phép quay) sau mỗi lần chèn hoặc xóa để đảm bảo rằng chiều cao của cây luôn được giữ ở mức logarit. Điều này giúp duy trì độ phức tạp O(log n) cho các phép toán cơ bản trong mọi trường hợp, tránh được worst case O(n) của BST thông thường. Ví dụ bao gồm AVL Tree và Red-Black Tree.\n\n**Mối quan hệ:**\n- Red-Black Tree là một loại Self-balancing BST.\n- AVL Tree là một loại Self-balancing BST."
        },
        "output_without_context": {
            "question": "Trong Java, lớp nào được sử dụng để biểu diễn một nút trong cấu trúc cây nhị phân tìm kiếm (BST)?",
            "answer": "Node"
        }
    },
    {
        "topic_description": "Khái niệm về chi phí tìm kiếm và chèn trong BST được đề cập. Câu hỏi có thể giúp kiểm tra khả năng hiểu biết về chi phí của các phép toán căn bản và cách hình dạng của cây ảnh hưởng tới hiệu suất.",
        "output_with_context": {
            "question": "Trong một cây tìm kiếm nhị phân (BST), độ phức tạp thời gian trung bình của phép toán tìm kiếm là bao nhiêu khi cây được cân bằng?",
            "answer": "O(log n)",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n    def _search_recursive(self, node, val):\n        # Base case\n        if node is None or node.val == val:\n            return node\n        \n        # Tìm trong cây con trái\n        if val < node.val:\n            return self._search_recursive(node.left, val)\n        \n        # Tìm trong cây con phải\n        return self._search_recursive(node.right, val)\n    \n    # Cách 2: Iterative\n    def search_iterative(self, val):\n        \"\"\"Tìm kiếm không đệ quy\"\"\"\n        current = self.root\n        \n        while current is not None:\n            if val == current.val:\n                return current\n            elif val < current.val:\n                current = current.left\n            else:\n                current = current.right\n        \n        return None\n```\n\n**Minh họa:**\n```\nTìm 6 trong BST:\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n\nBước 1: 6 < 8, đi sang trái\nBước 2: 6 > 3, đi sang phải\nBước 3: 6 == 6, tìm thấy!\n```\n\n#### 3.2. Insert (Thêm node)\n\n```python\n    def insert(self, val):\n        \"\"\"\n        Thêm node mới với giá trị val\n        Time: O(h)\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(val)\n        else:\n            self._insert_recursive(self.root, val)\n    \n    def _insert_recursive(self, node, val):\n        # Nếu giá trị nhỏ hơn, chèn vào trái\n        if val < node.val:\n            if node.left is None:\n                node.left = TreeNode(val)\n            else:\n                self._insert_recursive(node.left, val)\n        \n        # Nếu giá trị lớn hơn, chèn vào phải\n        elif val > node.val:\n            if node.right is None:\n                node.right = TreeNode(val)\n            else:\n                self._insert_recursive(node.right, val)\n        \n        # Nếu bằng, không làm gì (hoặc update)\n    \n    # Cách 2: Iterative\n    def insert_iterative(self, val):\n        \"\"\"Thêm node không đệ quy\"\"\"\n        new_node = TreeNode(val)\n        \n        if self.root is None:\n            self.root = new_node\n            return\n        \n        current = self.root\n        while True:\n            if val < current.val:\n                if current.left is None:\n                    current.left = new_node\n                    break\n                current = current.left\n            elif val > current.val:\n                if current.right is None:\n                    current.right = new_node\n                    break\n                current = current.right\n            else:\n                break  # Đã tồn tại\n```\n\n**Minh họa:**\n```\nInsert 5 vào BST:\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n\nBước 1: 5 < 8, đi trái\nBước 2: 5 > 3, đi phải\nBước 3: 5 < 6, chèn vào trái của 6\n\nKết quả:\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       /\n      5\n```\n\n#### 3.3. Find Min và Find Max\n\n```python\n    def find_min(self, node=None):\n        \"\"\"\n        Tìm node có giá trị nhỏ nhất\n        Đi sang trái cho đến hết\n        Time: O(h)\n        \"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return None\n        \n        while node.left is not None:\n            node = node.left\n        \n        return node\n    \n    def find_max(self, node=None):\n        \"\"\"\n        Tìm node có giá trị lớn nhất\n        Đi sang phải cho đến hết\n        Time: O(h)\n        \"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return None\n        \n        while node.right is not None:\n            node = node.right\n        \n        return node\n```\n\n#### 3.4. Delete (Xóa node)\n\n\n**Các khái niệm quan trọng:**\n- Search là phép toán tìm kiếm một phần tử hoặc giá trị cụ thể trong cấu trúc dữ liệu. Trong Binary Search Tree (BST), phép toán này bắt đầu từ gốc, so sánh giá trị cần tìm với giá trị của node hiện tại. Nếu giá trị cần tìm nhỏ hơn, di chuyển sang cây con trái; nếu lớn hơn, di chuyển sang cây con phải. Nếu bằng, phần tử được tìm thấy. Độ phức tạp thời gian của Search trong BST là O(h), trong đó h là chiều cao của cây. Cụ thể: Best case là O(1) (tìm thấy ở gốc), Average case là O(log n) (đối với cây cân bằng), và Worst case là O(n) (đối với cây thoái hóa). Đối với Min/Max Heap, độ phức tạp của Search là O(n), khiến chúng không hiệu quả cho việc tìm kiếm phần tử cụ thể. Trong Sorted Array, Search có độ phức tạp O(log n) khi sử dụng tìm kiếm nhị phân.\n- Find Min/Max là phép toán tìm phần tử nhỏ nhất hoặc lớn nhất trong cấu trúc dữ liệu Binary Search Tree (BST). Để tìm giá trị nhỏ nhất (Min), phép toán di chuyển từ gốc xuống node con trái cho đến khi không còn node con trái nào nữa, vì node nhỏ nhất luôn nằm ở tận cùng bên trái của cây. Tương tự, để tìm giá trị lớn nhất (Max), phép toán đi theo nhánh phải nhất. Độ phức tạp thời gian của phép toán này là O(h), trong đó h là chiều cao của cây. Cụ thể, Best case là O(1) (nếu phần tử min/max là gốc), Average case là O(log n) (đối với cây cân bằng), và Worst case là O(n) (đối với cây thoái hóa).\n- Search là phép toán tìm kiếm giá trị liên kết với một khóa cụ thể trong Hash Table (ví dụ: Python Dictionary). Quá trình này bao gồm việc sử dụng hàm băm để tính toán chỉ mục (vị trí ban đầu) và sau đó áp dụng các kỹ thuật giải quyết va chạm (như Linear Probing hoặc Quadratic Probing) để tìm kiếm khóa nếu có va chạm. Nếu tìm thấy khóa, giá trị tương ứng sẽ được trả về; nếu không, một ngoại lệ KeyError sẽ được ném ra. Độ phức tạp thời gian trung bình của phép toán này là O(1), nhưng trong trường hợp xấu nhất, độ phức tạp có thể là O(n).\n\n**Mối quan hệ:**\n- Phép toán Find Min trong Binary Search Tree có độ phức tạp thời gian O(h), trong đó h là chiều cao của cây.\n- Array (unsorted) có độ phức tạp O(n) cho phép toán Search.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n| Delete | O(log n) | O(log n) avg, O(n) worst | O(n) |\n| Build | O(n) | O(n log n) | O(n log n) |\n\n**Khi nào dùng Heap?**\n- ✅ Cần extract min/max nhiều lần\n- ✅ Priority Queue\n- ✅ Tìm k largest/smallest elements\n- ✅ Median trong stream\n- ✅ Scheduling problems\n\n**Khi nào không dùng Heap?**\n- ❌ Cần search phần tử cụ thể (dùng BST)\n- ❌ Cần duyệt theo thứ tự (dùng BST)\n- ❌ Cần truy cập ngẫu nhiên (dùng array)\n\n---\n\n## Binary Search Tree \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Binary Search Tree (BST)** là một cây nhị phân có tính chất đặc biệt:\n- Tất cả các node trong cây con trái có giá trị **< node gốc**\n- Tất cả các node trong cây con phải có giá trị **> node gốc**\n- Cây con trái và cây con phải cũng là BST\n\n**Ví dụ BST hợp lệ:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  7 13\n```\n\n**Không phải BST:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  9 13    <- 9 > 8, không thể ở cây con trái\n```\n\n#### 1.2. Tính chất quan trọng\n\n**a) Duyệt Inorder cho thứ tự tăng dần:**\n- Duyệt BST theo Inorder (Left-Root-Right) cho dãy số tăng dần\n- Ví dụ trên: 1, 3, 4, 6, 7, 8, 10, 13, 14\n\n**b) Tìm kiếm hiệu quả:**\n- Có thể loại bỏ 1 nửa cây ở mỗi bước\n- Average case: O(log n)\n- Worst case: O(n) - cây thoái hóa thành linked list\n\n**c) Dynamic data structure:**\n- Dễ dàng insert và delete\n- Không cần biết trước kích thước\n\n#### 1.3. Ứng dụng\n\n- **Database indexing:** B-Tree, B+ Tree (biến thể của BST)\n- **File system:** Tổ chức thư mục\n- **Expression parsing:** Cây biểu thức\n- **Priority Queue:** Có thể implement bằng BST\n- **Auto-complete:** Trie (dạng đặc biệt của cây)\n\n---\n\n### 2. Cấu trúc Node và BST\n\n#### 2.1. Định nghĩa Node\n\n```python\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n    \n    def __repr__(self):\n        return f\"Node({self.val})\"\n```\n\n#### 2.2. Lớp BST\n\n```python\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def is_empty(self):\n        return self.root is None\n    \n    def get_root(self):\n        return self.root\n```\n\n---\n\n### 3. Các thao tác cơ bản\n\n#### 3.1. Search (Tìm kiếm)\n\n```python\n    def search(self, val):\n        \"\"\"\n        Tìm node có giá trị val\n        Time: O(h) với h là chiều cao cây\n        Average: O(log n), Worst: O(n)\n        \"\"\"\n        return self._search_recursive(self.root, val)\n    \n\n**Các khái niệm quan trọng:**\n- Search là phép toán tìm kiếm một phần tử hoặc giá trị cụ thể trong cấu trúc dữ liệu. Trong Binary Search Tree (BST), phép toán này bắt đầu từ gốc, so sánh giá trị cần tìm với giá trị của node hiện tại. Nếu giá trị cần tìm nhỏ hơn, di chuyển sang cây con trái; nếu lớn hơn, di chuyển sang cây con phải. Nếu bằng, phần tử được tìm thấy. Độ phức tạp thời gian của Search trong BST là O(h), trong đó h là chiều cao của cây. Cụ thể: Best case là O(1) (tìm thấy ở gốc), Average case là O(log n) (đối với cây cân bằng), và Worst case là O(n) (đối với cây thoái hóa). Đối với Min/Max Heap, độ phức tạp của Search là O(n), khiến chúng không hiệu quả cho việc tìm kiếm phần tử cụ thể. Trong Sorted Array, Search có độ phức tạp O(log n) khi sử dụng tìm kiếm nhị phân.\n- Search là phép toán tìm kiếm giá trị liên kết với một khóa cụ thể trong Hash Table (ví dụ: Python Dictionary). Quá trình này bao gồm việc sử dụng hàm băm để tính toán chỉ mục (vị trí ban đầu) và sau đó áp dụng các kỹ thuật giải quyết va chạm (như Linear Probing hoặc Quadratic Probing) để tìm kiếm khóa nếu có va chạm. Nếu tìm thấy khóa, giá trị tương ứng sẽ được trả về; nếu không, một ngoại lệ KeyError sẽ được ném ra. Độ phức tạp thời gian trung bình của phép toán này là O(1), nhưng trong trường hợp xấu nhất, độ phức tạp có thể là O(n).\n- h là ký hiệu cho chiều cao của cây. Độ phức tạp của các phép toán trên cây nhị phân thường được biểu diễn theo h. Trong BST, độ phức tạp của phép toán Search là O(h).\n\n**Mối quan hệ:**\n- Array (unsorted) có độ phức tạp O(n) cho phép toán Search.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n        return -1\n    \n    def remove(self, key):\n        \"\"\"Time: O(n/k)\"\"\"\n        index = self._hash(key)\n        \n        for i, (k, v) in enumerate(self.buckets[index]):\n            if k == key:\n                self.buckets[index].pop(i)\n                return\n\n# Test\nhashmap = MyHashMap()\nhashmap.put(1, 1)\nhashmap.put(2, 2)\nprint(hashmap.get(1))    # 1\nhashmap.put(2, 1)\nprint(hashmap.get(2))    # 1\nhashmap.remove(2)\nprint(hashmap.get(2))    # -1\n```\n\n---\n\n### 6. Python Dictionary\n\nPython's `dict` là hash table được tối ưu cao:\n\n```python\n# Tạo dictionary\nd = {}\nd = dict()\nd = {'apple': 5, 'banana': 3}\n\n# Thao tác cơ bản\nd['cherry'] = 2        # Insert/Update - O(1)\nvalue = d['apple']     # Get - O(1)\ndel d['banana']        # Delete - O(1)\nexists = 'apple' in d  # Contains - O(1)\n\n# Methods\nkeys = d.keys()        # Tất cả keys\nvalues = d.values()    # Tất cả values\nitems = d.items()      # Tất cả (key, value) pairs\n\n# Get với default\nvalue = d.get('grape', 0)  # Trả về 0 nếu không tìm thấy\n\n# Duyệt\nfor key in d:\n    print(key, d[key])\n\nfor key, value in d.items():\n    print(key, value)\n\n# Counter\nfrom collections import Counter\nwords = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']\ncount = Counter(words)\nprint(count)  # Counter({'apple': 3, 'banana': 2, 'cherry': 1})\n\n# DefaultDict\nfrom collections import defaultdict\ndd = defaultdict(int)  # Default value = 0\ndd['apple'] += 1\n\ndd_list = defaultdict(list)  # Default value = []\ndd_list['fruits'].append('apple')\n```\n\n---\n\n### 7. Phân tích độ phức tạp\n\n| Thao tác | Average | Worst | Space |\n|----------|---------|-------|-------|\n| Insert | O(1) | O(n) | O(n) |\n| Search | O(1) | O(n) | O(n) |\n| Delete | O(1) | O(n) | O(n) |\n\n**Worst case:** Khi tất cả keys hash về cùng index (collision)\n\n**Load factor ảnh hưởng:**\n- α < 0.7: Performance tốt\n- α > 0.7: Nên resize\n\n---\n\n### 8. Khi nào dùng Hash Table?\n\n**Nên dùng:**\n- ✅ Cần lookup/insert/delete nhanh O(1)\n- ✅ Không cần thứ tự\n- ✅ Unique keys\n- ✅ Counting, frequency\n- ✅ Caching\n\n**Không nên dùng:**\n- ❌ Cần duy trì thứ tự → BST, Sorted Array\n- ❌ Cần range query → BST\n- ❌ Cần min/max → Heap\n- ❌ Memory bị hạn chế → Array\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Search là phép toán tìm kiếm một phần tử hoặc giá trị cụ thể trong cấu trúc dữ liệu. Trong Binary Search Tree (BST), phép toán này bắt đầu từ gốc, so sánh giá trị cần tìm với giá trị của node hiện tại. Nếu giá trị cần tìm nhỏ hơn, di chuyển sang cây con trái; nếu lớn hơn, di chuyển sang cây con phải. Nếu bằng, phần tử được tìm thấy. Độ phức tạp thời gian của Search trong BST là O(h), trong đó h là chiều cao của cây. Cụ thể: Best case là O(1) (tìm thấy ở gốc), Average case là O(log n) (đối với cây cân bằng), và Worst case là O(n) (đối với cây thoái hóa). Đối với Min/Max Heap, độ phức tạp của Search là O(n), khiến chúng không hiệu quả cho việc tìm kiếm phần tử cụ thể. Trong Sorted Array, Search có độ phức tạp O(log n) khi sử dụng tìm kiếm nhị phân.\n- Search là phép toán tìm kiếm giá trị liên kết với một khóa cụ thể trong Hash Table (ví dụ: Python Dictionary). Quá trình này bao gồm việc sử dụng hàm băm để tính toán chỉ mục (vị trí ban đầu) và sau đó áp dụng các kỹ thuật giải quyết va chạm (như Linear Probing hoặc Quadratic Probing) để tìm kiếm khóa nếu có va chạm. Nếu tìm thấy khóa, giá trị tương ứng sẽ được trả về; nếu không, một ngoại lệ KeyError sẽ được ném ra. Độ phức tạp thời gian trung bình của phép toán này là O(1), nhưng trong trường hợp xấu nhất, độ phức tạp có thể là O(n).\n\n**Mối quan hệ:**\n- Array (unsorted) có độ phức tạp O(n) cho phép toán Search.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n    bst.root = build(0, len(arr) - 1)\n    return bst\n\n# Test\narr = [1, 2, 3, 4, 5, 6, 7]\nbst = sorted_array_to_bst(arr)\nprint(\"Level order:\", bst.level_order())  # [4, 2, 6, 1, 3, 5, 7]\n```\n\n#### 6.3. Serialize và Deserialize BST\n\n```python\ndef serialize(root):\n    \"\"\"Chuyển BST thành string\"\"\"\n    def preorder(node):\n        if node is None:\n            result.append('#')\n            return\n        result.append(str(node.val))\n        preorder(node.left)\n        preorder(node.right)\n    \n    result = []\n    preorder(root)\n    return ','.join(result)\n\ndef deserialize(data):\n    \"\"\"Xây dựng lại BST từ string\"\"\"\n    def build():\n        val = next(vals)\n        if val == '#':\n            return None\n        \n        node = TreeNode(int(val))\n        node.left = build()\n        node.right = build()\n        return node\n    \n    vals = iter(data.split(','))\n    return build()\n\n# Test\nbst = build_bst_from_array([8, 3, 10, 1, 6, 14])\nserialized = serialize(bst.root)\nprint(\"Serialized:\", serialized)\n\nroot = deserialize(serialized)\nbst2 = BST()\nbst2.root = root\nprint(\"Inorder after deserialize:\", bst2.inorder())\n```\n\n---\n\n### 7. Phân tích độ phức tạp\n\n| Thao tác | Average | Worst | Best |\n|----------|---------|-------|------|\n| Search | O(log n) | O(n) | O(1) |\n| Insert | O(log n) | O(n) | O(1) |\n| Delete | O(log n) | O(n) | O(1) |\n| Find Min/Max | O(log n) | O(n) | O(1) |\n| Inorder | O(n) | O(n) | O(n) |\n| Space | O(n) | O(n) | O(n) |\n\n**Worst case xảy ra khi:** Cây thoái hóa thành linked list (insert các phần tử đã sắp xếp)\n\n```\nCây cân bằng:        Cây thoái hóa:\n      4                   1\n     / \\                   \\\n    2   6                   2\n   / \\ / \\                   \\\n  1  3 5  7                   3\n                               \\\n                                4\nHeight: log n              Height: n\n```\n\n**Giải pháp:** Sử dụng **Self-balancing BST** như AVL Tree, Red-Black Tree\n\n---\n\n### 8. So sánh với các cấu trúc khác\n\n| Cấu trúc | Search | Insert | Delete | Sorted | Space |\n|----------|--------|--------|--------|--------|-------|\n| Array (unsorted) | O(n) | O(1) | O(n) | ❌ | O(n) |\n| Array (sorted) | O(log n) | O(n) | O(n) | ✅ | O(n) |\n| Linked List | O(n) | O(1) | O(n) | ❌ | O(n) |\n| BST | O(log n) | O(log n) | O(log n) | ✅ | O(n) |\n| Hash Table | O(1) | O(1) | O(1) | ❌ | O(n) |\n\n**Khi nào dùng BST?**\n- ✅ Cần duy trì thứ tự sorted\n- ✅ Cần range query (tìm trong khoảng)\n- ✅ Cần tìm successor/predecessor\n- ✅ Dynamic data (thêm/xóa thường xuyên)\n- ✅ Cần kth smallest/largest\n\n**Khi nào không dùng BST?**\n- ❌ Chỉ cần search nhanh → Hash Table\n- ❌ Truy cập theo index → Array\n- ❌ Dữ liệu đã sắp xếp → Sorted Array\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Search là phép toán tìm kiếm một phần tử hoặc giá trị cụ thể trong cấu trúc dữ liệu. Trong Binary Search Tree (BST), phép toán này bắt đầu từ gốc, so sánh giá trị cần tìm với giá trị của node hiện tại. Nếu giá trị cần tìm nhỏ hơn, di chuyển sang cây con trái; nếu lớn hơn, di chuyển sang cây con phải. Nếu bằng, phần tử được tìm thấy. Độ phức tạp thời gian của Search trong BST là O(h), trong đó h là chiều cao của cây. Cụ thể: Best case là O(1) (tìm thấy ở gốc), Average case là O(log n) (đối với cây cân bằng), và Worst case là O(n) (đối với cây thoái hóa). Đối với Min/Max Heap, độ phức tạp của Search là O(n), khiến chúng không hiệu quả cho việc tìm kiếm phần tử cụ thể. Trong Sorted Array, Search có độ phức tạp O(log n) khi sử dụng tìm kiếm nhị phân.\n- Search là phép toán tìm kiếm giá trị liên kết với một khóa cụ thể trong Hash Table (ví dụ: Python Dictionary). Quá trình này bao gồm việc sử dụng hàm băm để tính toán chỉ mục (vị trí ban đầu) và sau đó áp dụng các kỹ thuật giải quyết va chạm (như Linear Probing hoặc Quadratic Probing) để tìm kiếm khóa nếu có va chạm. Nếu tìm thấy khóa, giá trị tương ứng sẽ được trả về; nếu không, một ngoại lệ KeyError sẽ được ném ra. Độ phức tạp thời gian trung bình của phép toán này là O(1), nhưng trong trường hợp xấu nhất, độ phức tạp có thể là O(n).\n\n**Mối quan hệ:**\n- Array (unsorted) có độ phức tạp O(n) cho phép toán Search."
        },
        "output_without_context": {
            "question": "Trong một cây nhị phân tìm kiếm (BST), chi phí trung bình để tìm kiếm một phần tử là bao nhiêu nếu cây có chiều cao h?",
            "answer": "O(h)"
        }
    },
    {
        "topic_description": "Khả năng hiểu và thiết kế thuật toán xóa các nút trong BST. Chủ đề này cũng kiểm tra kiến thức của học sinh về các trường hợp khác nhau khi xóa một nút. Câu hỏi có thể liên quan đến các bước và phân tích độ phức tạp của thuật toán xóa.",
        "output_with_context": {
            "question": "Khi xóa một nút trong cây nhị phân tìm kiếm (BST), trường hợp nào sau đây yêu cầu tìm kiếm và thay thế giá trị của nút cần xóa bằng giá trị của nút nhỏ nhất trong cây con bên phải?",
            "answer": "Khi xóa nút có hai con.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \nXóa node là thao tác phức tạp nhất, có 3 trường hợp:\n\n```python\n    def delete(self, val):\n        \"\"\"\n        Xóa node có giá trị val\n        Time: O(h)\n        \"\"\"\n        self.root = self._delete_recursive(self.root, val)\n    \n    def _delete_recursive(self, node, val):\n        # Base case\n        if node is None:\n            return None\n        \n        # Tìm node cần xóa\n        if val < node.val:\n            node.left = self._delete_recursive(node.left, val)\n        elif val > node.val:\n            node.right = self._delete_recursive(node.right, val)\n        else:\n            # Tìm thấy node cần xóa\n            \n            # Trường hợp 1: Node lá (không có con)\n            if node.left is None and node.right is None:\n                return None\n            \n            # Trường hợp 2a: Chỉ có con phải\n            if node.left is None:\n                return node.right\n            \n            # Trường hợp 2b: Chỉ có con trái\n            if node.right is None:\n                return node.left\n            \n            # Trường hợp 3: Có cả 2 con\n            # Tìm successor (node nhỏ nhất trong cây con phải)\n            successor = self.find_min(node.right)\n            \n            # Copy giá trị successor vào node hiện tại\n            node.val = successor.val\n            \n            # Xóa successor\n            node.right = self._delete_recursive(node.right, successor.val)\n        \n        return node\n```\n\n**Minh họa 3 trường hợp:**\n\n**Trường hợp 1: Xóa node lá (1)**\n```\nBefore:          After:\n    8               8\n   / \\             / \\\n  3   10          3   10\n / \\    \\          \\    \\\n1   6   14          6   14\n```\n\n**Trường hợp 2: Xóa node có 1 con (10)**\n```\nBefore:          After:\n    8               8\n   / \\             / \\\n  3   10          3   14\n / \\    \\        / \\\n1   6   14      1   6\n```\n\n**Trường hợp 3: Xóa node có 2 con (3)**\n```\nBefore:          After:\n    8               8\n   / \\             / \\\n  3   10          4   10\n / \\    \\        / \\    \\\n1   6   14      1   6   14\n   / \\             /\n  4  7            7\n\nBước 1: Tìm successor = 4 (min của cây con phải)\nBước 2: Copy 4 vào vị trí 3\nBước 3: Xóa 4 ở vị trí cũ\n```\n\n---\n\n### 4. Các phép duyệt cây (Tree Traversal)\n\n#### 4.1. Inorder Traversal (Left-Root-Right)\n\n```python\n    def inorder(self, node=None, result=None):\n        \"\"\"\n        Duyệt Inorder: Trái - Gốc - Phải\n        BST: cho thứ tự tăng dần\n        \"\"\"\n        if result is None:\n            result = []\n        if node is None:\n            node = self.root\n        \n        if node is not None:\n            self.inorder(node.left, result)\n            result.append(node.val)\n            self.inorder(node.right, result)\n        \n        return result\n    \n    # Iterative với stack\n    def inorder_iterative(self):\n        \"\"\"Inorder không đệ quy\"\"\"\n        result = []\n        stack = []\n        current = self.root\n        \n        while current or stack:\n            # Đi sang trái hết cỡ\n            while current:\n                stack.append(current)\n                current = current.left\n            \n            # Xử lý node\n            current = stack.pop()\n            result.append(current.val)\n            \n            # Đi sang phải\n            current = current.right\n        \n        return result\n```\n\n#### 4.2. Preorder Traversal (Root-Left-Right)\n\n```python\n    def preorder(self, node=None, result=None):\n        \"\"\"\n\n**Các khái niệm quan trọng:**\n- Delete là một phép toán xóa một phần tử (node) khỏi cấu trúc dữ liệu. Trong Binary Search Tree (BST), đây là một trong những thao tác phức tạp nhất, yêu cầu xử lý ba trường hợp khác nhau tùy thuộc vào số lượng con của node cần xóa: node không có con, có một con, hoặc có hai con. Trường hợp node có hai con thường được xử lý bằng cách thay thế node cần xóa bằng node nhỏ nhất trong cây con phải (hoặc lớn nhất trong cây con trái). Độ phức tạp thời gian của phép toán Delete trong BST là O(h), trong đó h là chiều cao của cây. Cụ thể, độ phức tạp là O(1) trong trường hợp tốt nhất, O(log n) trong trường hợp trung bình (cây cân bằng), và O(n) trong trường hợp xấu nhất (cây thoái hóa/suy biến). Trong Binary Heap, phép toán Delete (thường là extract min/max) có độ phức tạp thời gian O(log n).\n- Delete/remove là phép toán xóa một cặp khóa-giá trị khỏi Hash Table dựa trên khóa được cung cấp. Quá trình này bao gồm việc tính toán chỉ mục bằng hàm băm, sau đó duyệt qua danh sách (trong trường hợp Chaining) hoặc chuỗi thăm dò (trong trường hợp Open Addressing) tại chỉ mục đó để tìm và xóa cặp khóa-giá trị. Trong Chaining, việc xóa tương đối dễ dàng bằng cách xóa node khỏi linked list. Trong Open Addressing, việc xóa phức tạp hơn và thường không xóa vật lý phần tử mà thay vào đó sử dụng một \"marker\" (đánh dấu) như \"DELETED\" để chỉ ra rằng vị trí đó đã bị xóa nhưng không thực sự trống. Điều này giúp duy trì chuỗi thăm dò cho các phép tìm kiếm tiếp theo và tránh làm gián đoạn chúng. Sau khi tìm thấy và đánh dấu/xóa, số lượng phần tử (count) sẽ giảm đi. Nếu khóa không tồn tại, một ngoại lệ KeyError được ném ra. Trong Python Dictionary, độ phức tạp thời gian trung bình của phép toán này là O(1). Trong trường hợp xấu nhất, độ phức tạp có thể là O(n) hoặc O(n/k).\n- Node có 1 con là một node trong cây chỉ có một node con (hoặc con trái hoặc con phải). Khi xóa một node có 1 con, node con đó sẽ thay thế vị trí của node bị xóa.\n\n**Mối quan hệ:**\n- Phép toán delete có độ phức tạp thời gian O(h), trong đó h là chiều cao của cây. Best case O(log n), Worst case O(n).\n- Phép toán delete giải quyết bài toán xóa một node khỏi Binary Search Tree trong khi vẫn duy trì các tính chất của BST.\n- Phép toán delete yêu cầu xử lý trường hợp node có 1 con bằng cách thay thế node bị xóa bằng node con của nó.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n    def __init__(self, size=10):\n        self.size = size\n        self.table = [[] for _ in range(size)]\n        self.count = 0\n    \n    def hash_function(self, key):\n        \"\"\"Hash function đơn giản\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def insert(self, key, value):\n        \"\"\"\n        Thêm hoặc cập nhật key-value\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        # Kiểm tra key đã tồn tại chưa\n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                # Update giá trị\n                self.table[index][i] = (key, value)\n                return\n        \n        # Thêm mới\n        self.table[index].append((key, value))\n        self.count += 1\n        \n        # Resize nếu load factor quá cao\n        if self.load_factor() > 0.7:\n            self._resize()\n    \n    def search(self, key):\n        \"\"\"\n        Tìm giá trị theo key\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        for k, v in self.table[index]:\n            if k == key:\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def delete(self, key):\n        \"\"\"\n        Xóa key-value\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                self.table[index].pop(i)\n                self.count -= 1\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def contains(self, key):\n        \"\"\"Kiểm tra key có tồn tại không\"\"\"\n        try:\n            self.search(key)\n            return True\n        except KeyError:\n            return False\n    \n    def load_factor(self):\n        \"\"\"Tính load factor = n / m\"\"\"\n        return self.count / self.size\n    \n    def _resize(self):\n        \"\"\"Tăng kích thước bảng khi load factor cao\"\"\"\n        old_table = self.table\n        self.size *= 2\n        self.table = [[] for _ in range(self.size)]\n        self.count = 0\n        \n        # Rehash tất cả phần tử\n        for bucket in old_table:\n            for key, value in bucket:\n                self.insert(key, value)\n    \n    def __str__(self):\n        result = []\n        for i, bucket in enumerate(self.table):\n            if bucket:\n                result.append(f\"Index {i}: {bucket}\")\n        return \"\n\".join(result) if result else \"Empty hash table\"\n```\n\n#### 2.3. Test Chaining\n\n```python\n# Test\nht = HashTableChaining(size=5)\n\n# Insert\nht.insert(\"apple\", 5)\nht.insert(\"banana\", 3)\nht.insert(\"cherry\", 2)\nht.insert(\"date\", 8)\nht.insert(\"elderberry\", 7)\n\nprint(\"Hash Table:\")\nprint(ht)\nprint(f\"\nLoad factor: {ht.load_factor():.2f}\")\n\n# Search\nprint(f\"\nSearch 'apple': {ht.search('apple')}\")\nprint(f\"Contains 'grape': {ht.contains('grape')}\")\n\n# Update\nht.insert(\"apple\", 10)\nprint(f\"Updated 'apple': {ht.search('apple')}\")\n\n# Delete\nht.delete(\"banana\")\nprint(f\"\nAfter deleting 'banana':\")\nprint(ht)\n```\n\n---\n\n### 3. Open Addressing\n\n#### 3.1. Ý tưởng\n\nKhi collision xảy ra, tìm slot trống khác trong cùng bảng băm bằng **probing**.\n\n**Các phương pháp probing:**\n1. **Linear Probing:** h(k, i) = (h(k) + i) mod m\n2. **Quadratic Probing:** h(k, i) = (h(k) + c₁·i + c₂·i²) mod m\n3. **Double Hashing:** h(k, i) = (h₁(k) + i·h₂(k)) mod m\n\n\n**Các khái niệm quan trọng:**\n- Delete là một phép toán xóa một phần tử (node) khỏi cấu trúc dữ liệu. Trong Binary Search Tree (BST), đây là một trong những thao tác phức tạp nhất, yêu cầu xử lý ba trường hợp khác nhau tùy thuộc vào số lượng con của node cần xóa: node không có con, có một con, hoặc có hai con. Trường hợp node có hai con thường được xử lý bằng cách thay thế node cần xóa bằng node nhỏ nhất trong cây con phải (hoặc lớn nhất trong cây con trái). Độ phức tạp thời gian của phép toán Delete trong BST là O(h), trong đó h là chiều cao của cây. Cụ thể, độ phức tạp là O(1) trong trường hợp tốt nhất, O(log n) trong trường hợp trung bình (cây cân bằng), và O(n) trong trường hợp xấu nhất (cây thoái hóa/suy biến). Trong Binary Heap, phép toán Delete (thường là extract min/max) có độ phức tạp thời gian O(log n).\n- Delete/remove là phép toán xóa một cặp khóa-giá trị khỏi Hash Table dựa trên khóa được cung cấp. Quá trình này bao gồm việc tính toán chỉ mục bằng hàm băm, sau đó duyệt qua danh sách (trong trường hợp Chaining) hoặc chuỗi thăm dò (trong trường hợp Open Addressing) tại chỉ mục đó để tìm và xóa cặp khóa-giá trị. Trong Chaining, việc xóa tương đối dễ dàng bằng cách xóa node khỏi linked list. Trong Open Addressing, việc xóa phức tạp hơn và thường không xóa vật lý phần tử mà thay vào đó sử dụng một \"marker\" (đánh dấu) như \"DELETED\" để chỉ ra rằng vị trí đó đã bị xóa nhưng không thực sự trống. Điều này giúp duy trì chuỗi thăm dò cho các phép tìm kiếm tiếp theo và tránh làm gián đoạn chúng. Sau khi tìm thấy và đánh dấu/xóa, số lượng phần tử (count) sẽ giảm đi. Nếu khóa không tồn tại, một ngoại lệ KeyError được ném ra. Trong Python Dictionary, độ phức tạp thời gian trung bình của phép toán này là O(1). Trong trường hợp xấu nhất, độ phức tạp có thể là O(n) hoặc O(n/k).\n\n**Mối quan hệ:**\n- Phép toán delete có độ phức tạp thời gian O(h), trong đó h là chiều cao của cây. Best case O(log n), Worst case O(n).\n- Phép toán delete giải quyết bài toán xóa một node khỏi Binary Search Tree trong khi vẫn duy trì các tính chất của BST."
        },
        "output_without_context": {
            "question": "Trong thuật toán xóa nút trong cây nhị phân tìm kiếm (BST), trường hợp nào sau đây yêu cầu phải thay thế nút bị xóa bằng nút nhỏ nhất trong cây con bên phải của nó?",
            "answer": "Khi nút bị xóa có hai con."
        }
    },
    {
        "topic_description": "Khái niệm về phân tích toán học của các hoạt động trong BST, như tìm kiếm và chèn. Học sinh cần biết công thức và cách tính toán dựa trên chiều cao của BST. Câu hỏi có thể kiểm tra khả năng áp dụng công thức vào các ví dụ thực tiễn.",
        "output_with_context": {
            "question": "Chiều cao của một cây nhị phân tìm kiếm (BST) được tính bằng công thức nào?",
            "answer": "height(node) = max(height(node.left), height(node.right)) + 1",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n        Chiều cao = số cạnh dài nhất từ root đến lá\n        \"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return -1\n        \n        left_height = self.height(node.left)\n        right_height = self.height(node.right)\n        \n        return max(left_height, right_height) + 1\n```\n\n#### 5.3. Count nodes\n\n```python\n    def count_nodes(self, node=None):\n        \"\"\"Đếm số node trong cây\"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return 0\n        \n        return 1 + self.count_nodes(node.left) + self.count_nodes(node.right)\n```\n\n#### 5.4. Lowest Common Ancestor (LCA)\n\n```python\n    def lca(self, val1, val2):\n        \"\"\"\n        Tìm node tổ tiên chung thấp nhất của 2 node\n        \"\"\"\n        def find_lca(node, val1, val2):\n            if node is None:\n                return None\n            \n            # Cả 2 đều nhỏ hơn root, LCA ở bên trái\n            if val1 < node.val and val2 < node.val:\n                return find_lca(node.left, val1, val2)\n            \n            # Cả 2 đều lớn hơn root, LCA ở bên phải\n            if val1 > node.val and val2 > node.val:\n                return find_lca(node.right, val1, val2)\n            \n            # Một bên trái, một bên phải hoặc một trong hai là root\n            return node\n        \n        return find_lca(self.root, val1, val2)\n```\n\n#### 5.5. Kth Smallest Element\n\n```python\n    def kth_smallest(self, k):\n        \"\"\"\n        Tìm phần tử nhỏ thứ k\n        Sử dụng inorder traversal\n        \"\"\"\n        def inorder(node):\n            if node is None:\n                return\n            \n            # Duyệt trái\n            inorder(node.left)\n            \n            # Xử lý node\n            self.count += 1\n            if self.count == k:\n                self.result = node.val\n                return\n            \n            # Duyệt phải\n            inorder(node.right)\n        \n        self.count = 0\n        self.result = None\n        inorder(self.root)\n        return self.result\n```\n\n#### 5.6. Range Sum\n\n```python\n    def range_sum(self, low, high):\n        \"\"\"\n        Tính tổng các node có giá trị trong [low, high]\n        \"\"\"\n        def sum_range(node):\n            if node is None:\n                return 0\n            \n            total = 0\n            \n            # Nếu node trong range\n            if low <= node.val <= high:\n                total += node.val\n            \n            # Tìm trong cây con trái nếu cần\n            if node.val > low:\n                total += sum_range(node.left)\n            \n            # Tìm trong cây con phải nếu cần\n            if node.val < high:\n                total += sum_range(node.right)\n            \n            return total\n        \n        return sum_range(self.root)\n```\n\n---\n\n### 6. Ứng dụng thực tế\n\n#### 6.1. Build BST từ Array\n\n```python\ndef build_bst_from_array(arr):\n    \"\"\"Xây dựng BST từ mảng\"\"\"\n    bst = BST()\n    for val in arr:\n        bst.insert(val)\n    return bst\n\n# Test\narr = [8, 3, 10, 1, 6, 14, 4, 7, 13]\nbst = build_bst_from_array(arr)\nprint(\"Inorder:\", bst.inorder())\n```\n\n#### 6.2. Build Balanced BST từ Sorted Array\n\n```python\ndef sorted_array_to_bst(arr):\n    \"\"\"\n    Xây dựng BST cân bằng từ mảng đã sắp xếp\n    Chọn phần tử giữa làm root\n    \"\"\"\n    def build(left, right):\n        if left > right:\n            return None\n        \n        mid = (left + right) // 2\n        node = TreeNode(arr[mid])\n        \n        node.left = build(left, mid - 1)\n        node.right = build(mid + 1, right)\n        \n        return node\n    \n    bst = BST()\n\n**Các khái niệm quan trọng:**\n- Phép toán height (chiều cao) tính chiều cao của một cây nhị phân hoặc một cây con, được định nghĩa là số cạnh dài nhất từ node gốc đến một node lá. Chiều cao của một cây rỗng là -1. Công thức đệ quy: height(node) = max(height(node.left), height(node.right)) + 1.\n\n**Mối quan hệ:**\n- Phép toán height sử dụng kỹ thuật đệ quy để tính chiều cao của cây.\n- Phép toán height được sử dụng để tính chiều cao của một Binary Search Tree.\n- Phép toán height có độ phức tạp thời gian O(n) trong trường hợp xấu nhất khi Binary Search Tree bị suy biến thành dạng danh sách liên kết, vì nó phải duyệt qua tất cả các node trên đường đi dài nhất.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n| Delete | O(log n) | O(log n) avg, O(n) worst | O(n) |\n| Build | O(n) | O(n log n) | O(n log n) |\n\n**Khi nào dùng Heap?**\n- ✅ Cần extract min/max nhiều lần\n- ✅ Priority Queue\n- ✅ Tìm k largest/smallest elements\n- ✅ Median trong stream\n- ✅ Scheduling problems\n\n**Khi nào không dùng Heap?**\n- ❌ Cần search phần tử cụ thể (dùng BST)\n- ❌ Cần duyệt theo thứ tự (dùng BST)\n- ❌ Cần truy cập ngẫu nhiên (dùng array)\n\n---\n\n## Binary Search Tree \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Binary Search Tree (BST)** là một cây nhị phân có tính chất đặc biệt:\n- Tất cả các node trong cây con trái có giá trị **< node gốc**\n- Tất cả các node trong cây con phải có giá trị **> node gốc**\n- Cây con trái và cây con phải cũng là BST\n\n**Ví dụ BST hợp lệ:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  7 13\n```\n\n**Không phải BST:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  9 13    <- 9 > 8, không thể ở cây con trái\n```\n\n#### 1.2. Tính chất quan trọng\n\n**a) Duyệt Inorder cho thứ tự tăng dần:**\n- Duyệt BST theo Inorder (Left-Root-Right) cho dãy số tăng dần\n- Ví dụ trên: 1, 3, 4, 6, 7, 8, 10, 13, 14\n\n**b) Tìm kiếm hiệu quả:**\n- Có thể loại bỏ 1 nửa cây ở mỗi bước\n- Average case: O(log n)\n- Worst case: O(n) - cây thoái hóa thành linked list\n\n**c) Dynamic data structure:**\n- Dễ dàng insert và delete\n- Không cần biết trước kích thước\n\n#### 1.3. Ứng dụng\n\n- **Database indexing:** B-Tree, B+ Tree (biến thể của BST)\n- **File system:** Tổ chức thư mục\n- **Expression parsing:** Cây biểu thức\n- **Priority Queue:** Có thể implement bằng BST\n- **Auto-complete:** Trie (dạng đặc biệt của cây)\n\n---\n\n### 2. Cấu trúc Node và BST\n\n#### 2.1. Định nghĩa Node\n\n```python\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n    \n    def __repr__(self):\n        return f\"Node({self.val})\"\n```\n\n#### 2.2. Lớp BST\n\n```python\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def is_empty(self):\n        return self.root is None\n    \n    def get_root(self):\n        return self.root\n```\n\n---\n\n### 3. Các thao tác cơ bản\n\n#### 3.1. Search (Tìm kiếm)\n\n```python\n    def search(self, val):\n        \"\"\"\n        Tìm node có giá trị val\n        Time: O(h) với h là chiều cao cây\n        Average: O(log n), Worst: O(n)\n        \"\"\"\n        return self._search_recursive(self.root, val)\n    \n\n**Các khái niệm quan trọng:**\n- Expression parsing là quá trình phân tích cú pháp một biểu thức toán học hoặc lập trình để xây dựng một cây biểu thức. Cây biểu thức là một dạng cây nhị phân.\n- h là ký hiệu cho chiều cao của cây. Độ phức tạp của các phép toán trên cây nhị phân thường được biểu diễn theo h. Trong BST, độ phức tạp của phép toán Search là O(h).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n        Duyệt Preorder: Gốc - Trái - Phải\n        Dùng để copy cây, serialize\n        \"\"\"\n        if result is None:\n            result = []\n        if node is None:\n            node = self.root\n        \n        if node is not None:\n            result.append(node.val)\n            self.preorder(node.left, result)\n            self.preorder(node.right, result)\n        \n        return result\n    \n    # Iterative\n    def preorder_iterative(self):\n        \"\"\"Preorder không đệ quy\"\"\"\n        if self.root is None:\n            return []\n        \n        result = []\n        stack = [self.root]\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            # Push phải trước, trái sau (vì stack LIFO)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return result\n```\n\n#### 4.3. Postorder Traversal (Left-Right-Root)\n\n```python\n    def postorder(self, node=None, result=None):\n        \"\"\"\n        Duyệt Postorder: Trái - Phải - Gốc\n        Dùng để xóa cây, tính expression tree\n        \"\"\"\n        if result is None:\n            result = []\n        if node is None:\n            node = self.root\n        \n        if node is not None:\n            self.postorder(node.left, result)\n            self.postorder(node.right, result)\n            result.append(node.val)\n        \n        return result\n```\n\n#### 4.4. Level Order Traversal (BFS)\n\n```python\n    def level_order(self):\n        \"\"\"\n        Duyệt theo từng level (BFS)\n        Sử dụng queue\n        \"\"\"\n        if self.root is None:\n            return []\n        \n        from collections import deque\n        \n        result = []\n        queue = deque([self.root])\n        \n        while queue:\n            node = queue.popleft()\n            result.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        return result\n    \n    # Level by level\n    def level_order_by_level(self):\n        \"\"\"Duyệt theo level, trả về list của list\"\"\"\n        if self.root is None:\n            return []\n        \n        from collections import deque\n        \n        result = []\n        queue = deque([self.root])\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(current_level)\n        \n        return result\n```\n\n**Ví dụ các phép duyệt:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\\n      4  7\n\nInorder:    1, 3, 4, 6, 7, 8, 10, 14\nPreorder:   8, 3, 1, 6, 4, 7, 10, 14\nPostorder:  1, 4, 7, 6, 3, 14, 10, 8\nLevel Order: 8, 3, 10, 1, 6, 14, 4, 7\n```\n\n---\n\n### 5. Các thao tác nâng cao\n\n#### 5.1. Validate BST\n\n```python\n    def is_valid_bst(self):\n        \"\"\"\n        Kiểm tra cây có phải BST hợp lệ không\n        \"\"\"\n        def validate(node, min_val, max_val):\n            if node is None:\n                return True\n            \n            # Kiểm tra ràng buộc\n            if node.val <= min_val or node.val >= max_val:\n                return False\n            \n            # Kiểm tra đệ quy cây con\n            return (validate(node.left, min_val, node.val) and\n                    validate(node.right, node.val, max_val))\n        \n        return validate(self.root, float('-inf'), float('inf'))\n```\n\n#### 5.2. Height của cây\n\n```python\n    def height(self, node=None):\n        \"\"\"\n        Tính chiều cao của cây\n\n**Các khái niệm quan trọng:**\n- Height of Tree là một thuật toán tính chiều cao của cây nhị phân. Chiều cao của một cây là số cạnh trên đường đi dài nhất từ gốc đến một lá. Chiều cao của một cây rỗng là -1, và chiều cao của một cây chỉ có một nút là 0. Thuật toán này thường được triển khai bằng đệ quy.\n- Validate BST là một thuật toán kiểm tra xem một cây nhị phân có phải là một Binary Search Tree hợp lệ hay không. Thuật toán này sử dụng đệ quy và truyền các ràng buộc giá trị tối thiểu (min_val) và tối đa (max_val) cho các cây con để đảm bảo tính chất của BST được duy trì.\n\n**Mối quan hệ:**\n- Validate BST được triển khai bằng kỹ thuật đệ quy.\n- Height of Tree là một thao tác nâng cao được thực hiện trên Binary Search Tree để tính chiều cao của nó.\n- Validate BST là một thao tác nâng cao được thực hiện trên Binary Search Tree để kiểm tra tính hợp lệ của nó.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n    bst.root = build(0, len(arr) - 1)\n    return bst\n\n# Test\narr = [1, 2, 3, 4, 5, 6, 7]\nbst = sorted_array_to_bst(arr)\nprint(\"Level order:\", bst.level_order())  # [4, 2, 6, 1, 3, 5, 7]\n```\n\n#### 6.3. Serialize và Deserialize BST\n\n```python\ndef serialize(root):\n    \"\"\"Chuyển BST thành string\"\"\"\n    def preorder(node):\n        if node is None:\n            result.append('#')\n            return\n        result.append(str(node.val))\n        preorder(node.left)\n        preorder(node.right)\n    \n    result = []\n    preorder(root)\n    return ','.join(result)\n\ndef deserialize(data):\n    \"\"\"Xây dựng lại BST từ string\"\"\"\n    def build():\n        val = next(vals)\n        if val == '#':\n            return None\n        \n        node = TreeNode(int(val))\n        node.left = build()\n        node.right = build()\n        return node\n    \n    vals = iter(data.split(','))\n    return build()\n\n# Test\nbst = build_bst_from_array([8, 3, 10, 1, 6, 14])\nserialized = serialize(bst.root)\nprint(\"Serialized:\", serialized)\n\nroot = deserialize(serialized)\nbst2 = BST()\nbst2.root = root\nprint(\"Inorder after deserialize:\", bst2.inorder())\n```\n\n---\n\n### 7. Phân tích độ phức tạp\n\n| Thao tác | Average | Worst | Best |\n|----------|---------|-------|------|\n| Search | O(log n) | O(n) | O(1) |\n| Insert | O(log n) | O(n) | O(1) |\n| Delete | O(log n) | O(n) | O(1) |\n| Find Min/Max | O(log n) | O(n) | O(1) |\n| Inorder | O(n) | O(n) | O(n) |\n| Space | O(n) | O(n) | O(n) |\n\n**Worst case xảy ra khi:** Cây thoái hóa thành linked list (insert các phần tử đã sắp xếp)\n\n```\nCây cân bằng:        Cây thoái hóa:\n      4                   1\n     / \\                   \\\n    2   6                   2\n   / \\ / \\                   \\\n  1  3 5  7                   3\n                               \\\n                                4\nHeight: log n              Height: n\n```\n\n**Giải pháp:** Sử dụng **Self-balancing BST** như AVL Tree, Red-Black Tree\n\n---\n\n### 8. So sánh với các cấu trúc khác\n\n| Cấu trúc | Search | Insert | Delete | Sorted | Space |\n|----------|--------|--------|--------|--------|-------|\n| Array (unsorted) | O(n) | O(1) | O(n) | ❌ | O(n) |\n| Array (sorted) | O(log n) | O(n) | O(n) | ✅ | O(n) |\n| Linked List | O(n) | O(1) | O(n) | ❌ | O(n) |\n| BST | O(log n) | O(log n) | O(log n) | ✅ | O(n) |\n| Hash Table | O(1) | O(1) | O(1) | ❌ | O(n) |\n\n**Khi nào dùng BST?**\n- ✅ Cần duy trì thứ tự sorted\n- ✅ Cần range query (tìm trong khoảng)\n- ✅ Cần tìm successor/predecessor\n- ✅ Dynamic data (thêm/xóa thường xuyên)\n- ✅ Cần kth smallest/largest\n\n**Khi nào không dùng BST?**\n- ❌ Chỉ cần search nhanh → Hash Table\n- ❌ Truy cập theo index → Array\n- ❌ Dữ liệu đã sắp xếp → Sorted Array\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Kth smallest/largest là bài toán tìm phần tử nhỏ thứ k hoặc lớn thứ k trong một tập hợp dữ liệu. BST có thể được mở rộng để giải quyết bài toán này một cách hiệu quả.\n- Range query là bài toán tìm kiếm tất cả các phần tử trong một khoảng giá trị nhất định. BST rất hiệu quả cho loại bài toán này vì tính chất sắp xếp của nó."
        },
        "output_without_context": {
            "question": "Chiều cao của một cây nhị phân tìm kiếm (BST) có ảnh hưởng như thế nào đến độ phức tạp thời gian của các hoạt động tìm kiếm và chèn?",
            "answer": "Độ phức tạp thời gian của tìm kiếm và chèn trong BST là O(h), với h là chiều cao của cây."
        }
    },
    {
        "topic_description": "Chủ đề này tích hợp kiến thức từ các tuần trước, liên kết khái niệm BST với phân vùng trong thuật toán Quicksort. Học sinh cần so sánh và phân tích cách mà cấu trúc BST ảnh hưởng đến hiệu suất sắp xếp. Câu hỏi có thể kiểm tra khả năng hiểu trừu tượng giữa hai cấu trúc.",
        "output_with_context": {
            "question": "So sánh hiệu suất của thuật toán Quick Sort và cấu trúc dữ liệu Binary Search Tree (BST) trong việc sắp xếp một mảng có nhiều phần tử trùng lặp. Khi nào thì Quick Sort có thể hoạt động kém hơn so với BST?",
            "answer": "Quick Sort có thể hoạt động kém hơn BST trong trường hợp xấu nhất khi dữ liệu đã gần sắp xếp, dẫn đến độ phức tạp O(n²), trong khi BST có thể duy trì hiệu suất O(log n) cho các phép toán tìm kiếm.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n    lt = low       # arr[low..lt-1] < pivot\n    i = low + 1    # arr[lt..i-1] == pivot\n    gt = high      # arr[gt+1..high] > pivot\n    \n    while i <= gt:\n        if arr[i] < pivot:\n            arr[lt], arr[i] = arr[i], arr[lt]\n            lt += 1\n            i += 1\n        elif arr[i] > pivot:\n            arr[i], arr[gt] = arr[gt], arr[i]\n            gt -= 1\n        else:\n            i += 1\n    \n    return lt, gt\n\ndef quick_sort_3way(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort với 3-way partitioning\n    Tối ưu cho mảng có nhiều phần tử trùng\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        lt, gt = three_way_partition(arr, low, high)\n        quick_sort_3way(arr, low, lt - 1)\n        quick_sort_3way(arr, gt + 1, high)\n    \n    return arr\n\n# Test với mảng có nhiều phần tử trùng\narr = [4, 9, 4, 4, 1, 9, 4, 4, 9, 4, 4, 1, 4]\nprint(\"Mảng có nhiều phần tử trùng:\", arr)\nprint(\"Sau 3-way quick sort:\", quick_sort_3way(arr.copy()))\n```\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Quick Select - Tìm phần tử thứ k\n\n```python\ndef quick_select(arr, k):\n    \"\"\"\n    Tìm phần tử thứ k nhỏ nhất (0-indexed)\n    Average: O(n), Worst: O(n²)\n    \"\"\"\n    def select(arr, low, high, k):\n        if low == high:\n            return arr[low]\n        \n        pivot_index = partition(arr, low, high)\n        \n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return select(arr, low, pivot_index - 1, k)\n        else:\n            return select(arr, pivot_index + 1, high, k)\n    \n    return select(arr, 0, len(arr) - 1, k)\n\n# Test\narr = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(f\"Phần tử thứ {k+1} nhỏ nhất:\", quick_select(arr.copy(), k))\n\n# Tìm median\ndef find_median(arr):\n    n = len(arr)\n    if n % 2 == 1:\n        return quick_select(arr, n // 2)\n    else:\n        return (quick_select(arr.copy(), n // 2 - 1) + \n                quick_select(arr.copy(), n // 2)) / 2\n\nprint(\"Median:\", find_median([3, 2, 1, 5, 6, 4]))\n```\n\n#### 5.2. Kth Largest Element\n\n```python\ndef find_kth_largest(arr, k):\n    \"\"\"\n    Tìm phần tử lớn thứ k\n    \"\"\"\n    # Phần tử lớn thứ k = phần tử thứ (n-k) từ trái\n    return quick_select(arr, len(arr) - k)\n\n# Test\narr = [3, 2, 3, 1, 2, 4, 5, 5, 6]\nprint(f\"Phần tử lớn thứ 4:\", find_kth_largest(arr, 4))\n```\n\n---\n\n### 6. So sánh với các thuật toán khác\n\n| Đặc điểm | Quick Sort | Merge Sort | Heap Sort |\n|----------|------------|------------|-----------|\n| **Average Time** | O(n log n) | O(n log n) | O(n log n) |\n| **Worst Time** | O(n²) | O(n log n) | O(n log n) |\n| **Space** | O(log n) | O(n) | O(1) |\n| **Stable** | ❌ | ✅ | ❌ |\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n\n**Mối quan hệ:**\n- Quicksort yêu cầu xem xét Best/Average case để đánh giá hiệu suất thực tế của nó, thường là O(n log n).\n- Quicksort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các mảng con, sắp xếp đệ quy các mảng con đó.\n- Quicksort hoạt động hiệu quả khi sử dụng mảng (array) làm cấu trúc dữ liệu đầu vào do tính chất random access của mảng.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n| **In-place** | ✅ | ❌ | ✅ |\n| **Cache-friendly** | ✅ | ❌ | ⚠️ |\n\n#### 6.1. Khi nào dùng Quick Sort?\n\n**Nên dùng:**\n- ✅ Mảng trong RAM (in-memory sorting)\n- ✅ Cần sorting nhanh nhất average case\n- ✅ Bộ nhớ hạn chế\n- ✅ Random access data (array)\n- ✅ Không cần stable sort\n\n**Không nên dùng:**\n- ❌ Cần đảm bảo O(n log n) worst case\n- ❌ Cần stable sorting\n- ❌ Linked list (Merge Sort tốt hơn)\n- ❌ Dữ liệu đã gần sắp xếp (trừ khi dùng random pivot)\n\n---\n\n### 7. Quick Sort trong thư viện chuẩn\n\n#### 7.1. Python's sorted() và sort()\n\nPython sử dụng **Timsort** (hybrid của Merge Sort và Insertion Sort), không phải Quick Sort, vì:\n- Stable sorting\n- Tốt với dữ liệu có pattern\n- Worst case O(n log n) đảm bảo\n\n#### 7.2. C++ std::sort()\n\nC++ sử dụng **Introsort** (Introspective Sort):\n- Bắt đầu với Quick Sort\n- Chuyển sang Heap Sort nếu đệ quy quá sâu (tránh O(n²))\n- Dùng Insertion Sort cho mảng nhỏ\n\n#### 7.3. Java's Arrays.sort()\n\n- **Primitive types:** Dual-Pivot Quick Sort\n- **Object types:** Timsort (stable)\n\n---\n\n## Priority Queue & Binary Heap\n\n### 1. Giới thiệu Priority Queue\n\n#### 1.1. Khái niệm\n\n**Priority Queue (Hàng đợi ưu tiên)** là một cấu trúc dữ liệu trừu tượng trong đó mỗi phần tử có một độ ưu tiên (priority) được gán cho nó. Phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào.\n\n**Khác với Queue thông thường:**\n- Queue thông thường: FIFO (First In First Out)\n- Priority Queue: Phần tử có priority cao nhất ra trước\n\n**Ví dụ thực tế:**\n- **Hệ thống cấp cứu:** Bệnh nhân nguy kịch được ưu tiên khám trước\n- **CPU Scheduling:** Process có priority cao được xử lý trước\n- **Dijkstra Algorithm:** Chọn đỉnh có khoảng cách nhỏ nhất\n- **A* Search:** Chọn node có f(n) nhỏ nhất\n- **Huffman Coding:** Xây dựng cây mã hóa\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Insert/Enqueue:** Thêm phần tử với priority\n**b) Extract-Max/Min:** Lấy và xóa phần tử có priority cao/thấp nhất\n**c) Peek/Top:** Xem phần tử có priority cao/thấp nhất\n**d) Change Priority:** Thay đổi priority của phần tử\n**e) Delete:** Xóa phần tử bất kỳ\n\n#### 1.3. Các cách cài đặt\n\n| Cài đặt | Insert | Extract-Max | Peek |\n|---------|--------|-------------|------|\n| Array (unsorted) | O(1) | O(n) | O(n) |\n| Array (sorted) | O(n) | O(1) | O(1) |\n| Linked List | O(n) | O(1) | O(1) |\n| **Binary Heap** | **O(log n)** | **O(log n)** | **O(1)** |\n| Fibonacci Heap | O(1) | O(log n) | O(1) |\n\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n\n**Mối quan hệ:**\n- Quicksort yêu cầu xem xét Best/Average case để đánh giá hiệu suất thực tế của nó, thường là O(n log n).\n- Quicksort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các mảng con, sắp xếp đệ quy các mảng con đó.\n- Quicksort hoạt động hiệu quả khi sử dụng mảng (array) làm cấu trúc dữ liệu đầu vào do tính chất random access của mảng.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n[7, 8, 9] [10] []\n\nTiếp tục...\nKết quả: [1, 5, 7, 8, 9, 10]\n```\n\n---\n\n### 2. Thuật toán Quick Sort\n\n#### 2.1. Cài đặt cơ bản (Lomuto Partition)\n\n```python\ndef quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Lomuto partition scheme\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Partition và lấy vị trí pivot\n        pivot_index = partition(arr, low, high)\n        \n        # Đệ quy sắp xếp 2 phần\n        quick_sort(arr, low, pivot_index - 1)\n        quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef partition(arr, low, high):\n    \"\"\"\n    Lomuto partition: Chọn phần tử cuối làm pivot\n    \"\"\"\n    pivot = arr[high]\n    i = low - 1  # Index của phần tử nhỏ hơn\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Đặt pivot vào vị trí đúng\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", quick_sort(arr.copy()))\n```\n\n#### 2.2. Hoare Partition Scheme (Hiệu quả hơn)\n\n```python\ndef quick_sort_hoare(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Hoare partition scheme\n    Hiệu quả hơn Lomuto (ít swap hơn 3 lần)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = hoare_partition(arr, low, high)\n        quick_sort_hoare(arr, low, pivot_index)\n        quick_sort_hoare(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef hoare_partition(arr, low, high):\n    \"\"\"\n    Hoare partition: Pivot ở giữa, 2 con trỏ từ 2 đầu\n    \"\"\"\n    pivot = arr[low]\n    i = low - 1\n    j = high + 1\n    \n    while True:\n        # Tìm phần tử >= pivot từ trái\n        i += 1\n        while arr[i] < pivot:\n            i += 1\n        \n        # Tìm phần tử <= pivot từ phải\n        j -= 1\n        while arr[j] > pivot:\n            j -= 1\n        \n        # Nếu 2 con trỏ gặp nhau\n        if i >= j:\n            return j\n        \n        # Swap\n        arr[i], arr[j] = arr[j], arr[i]\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Hoare Partition:\", quick_sort_hoare(arr.copy()))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Best Case: O(n log n)**\n- Xảy ra khi pivot luôn chia mảng thành 2 phần bằng nhau\n- Độ cao cây đệ quy: log n\n- Mỗi tầng: O(n) cho partition\n- Tổng: O(n log n)\n\n**Average Case: O(n log n)**\n- Với pivot ngẫu nhiên, expected time là O(n log n)\n- Ngay cả khi không chia đều (tỉ lệ 9:1), vẫn là O(n log n)\n\n**Worst Case: O(n²)**\n- Xảy ra khi pivot luôn là phần tử nhỏ nhất hoặc lớn nhất\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n\n**Mối quan hệ:**\n- Quicksort yêu cầu xem xét Best/Average case để đánh giá hiệu suất thực tế của nó, thường là O(n log n).\n- Quicksort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các mảng con, sắp xếp đệ quy các mảng con đó.\n- Quicksort hoạt động hiệu quả khi sử dụng mảng (array) làm cấu trúc dữ liệu đầu vào do tính chất random access của mảng.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n| Delete | O(log n) | O(log n) avg, O(n) worst | O(n) |\n| Build | O(n) | O(n log n) | O(n log n) |\n\n**Khi nào dùng Heap?**\n- ✅ Cần extract min/max nhiều lần\n- ✅ Priority Queue\n- ✅ Tìm k largest/smallest elements\n- ✅ Median trong stream\n- ✅ Scheduling problems\n\n**Khi nào không dùng Heap?**\n- ❌ Cần search phần tử cụ thể (dùng BST)\n- ❌ Cần duyệt theo thứ tự (dùng BST)\n- ❌ Cần truy cập ngẫu nhiên (dùng array)\n\n---\n\n## Binary Search Tree \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Binary Search Tree (BST)** là một cây nhị phân có tính chất đặc biệt:\n- Tất cả các node trong cây con trái có giá trị **< node gốc**\n- Tất cả các node trong cây con phải có giá trị **> node gốc**\n- Cây con trái và cây con phải cũng là BST\n\n**Ví dụ BST hợp lệ:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  7 13\n```\n\n**Không phải BST:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  9 13    <- 9 > 8, không thể ở cây con trái\n```\n\n#### 1.2. Tính chất quan trọng\n\n**a) Duyệt Inorder cho thứ tự tăng dần:**\n- Duyệt BST theo Inorder (Left-Root-Right) cho dãy số tăng dần\n- Ví dụ trên: 1, 3, 4, 6, 7, 8, 10, 13, 14\n\n**b) Tìm kiếm hiệu quả:**\n- Có thể loại bỏ 1 nửa cây ở mỗi bước\n- Average case: O(log n)\n- Worst case: O(n) - cây thoái hóa thành linked list\n\n**c) Dynamic data structure:**\n- Dễ dàng insert và delete\n- Không cần biết trước kích thước\n\n#### 1.3. Ứng dụng\n\n- **Database indexing:** B-Tree, B+ Tree (biến thể của BST)\n- **File system:** Tổ chức thư mục\n- **Expression parsing:** Cây biểu thức\n- **Priority Queue:** Có thể implement bằng BST\n- **Auto-complete:** Trie (dạng đặc biệt của cây)\n\n---\n\n### 2. Cấu trúc Node và BST\n\n#### 2.1. Định nghĩa Node\n\n```python\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n    \n    def __repr__(self):\n        return f\"Node({self.val})\"\n```\n\n#### 2.2. Lớp BST\n\n```python\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def is_empty(self):\n        return self.root is None\n    \n    def get_root(self):\n        return self.root\n```\n\n---\n\n### 3. Các thao tác cơ bản\n\n#### 3.1. Search (Tìm kiếm)\n\n```python\n    def search(self, val):\n        \"\"\"\n        Tìm node có giá trị val\n        Time: O(h) với h là chiều cao cây\n        Average: O(log n), Worst: O(n)\n        \"\"\"\n        return self._search_recursive(self.root, val)\n    \n\n**Các khái niệm quan trọng:**\n- Binary Search Tree (BST) là một cấu trúc dữ liệu cây nhị phân có thứ tự, trong đó mỗi node có tối đa hai node con (trái và phải). Tính chất cốt lõi của BST là: giá trị của tất cả các node trong cây con bên trái của một node phải nhỏ hơn giá trị của node đó, và giá trị của tất cả các node trong cây con bên phải phải lớn hơn giá trị của node đó. Cả cây con trái và cây con phải cũng là các BST. BST là một cấu trúc dữ liệu động, hỗ trợ hiệu quả các phép toán cơ bản như tìm kiếm (Search), chèn (Insert), xóa (Delete), tìm giá trị nhỏ nhất (Min), tìm giá trị lớn nhất (Max), và duyệt cây theo nhiều thứ tự (Inorder, Preorder, Postorder, Level Order). Đặc biệt, duyệt Inorder trên BST sẽ cho kết quả các phần tử theo thứ tự tăng dần. Độ phức tạp trung bình cho các phép toán này là O(log n), nhưng trong trường hợp xấu nhất (khi cây bị suy biến thành dạng danh sách) là O(n). Cấu trúc bộ nhớ của BST bao gồm các node chứa giá trị (val) và con trỏ đến node con trái (left) và node con phải (right). BST phù hợp khi cần duy trì thứ tự của các phần tử hoặc thực hiện các truy vấn phạm vi."
        },
        "output_without_context": {
            "question": "So sánh hiệu suất sắp xếp của cây nhị phân tìm kiếm (BST) và thuật toán Quicksort trong trường hợp dữ liệu đã được sắp xếp trước. Điều nào sau đây là đúng?",
            "answer": "BST có thể có hiệu suất kém hơn Quicksort trong trường hợp dữ liệu đã được sắp xếp trước."
        }
    },
    {
        "topic_description": "Khái niệm về các phép toán có thứ tự trong BST như Min/Max, Floor/Ceiling. Học sinh cần hiểu cách thực hiện các phép toán này và tác động của chúng đến việc duyệt cây. Câu hỏi có thể yêu cầu học sinh xác định hoặc thực hiện các phép toán cụ thể trên BST.",
        "output_with_context": {
            "question": "Trong một cây tìm kiếm nhị phân (BST), để tìm giá trị nhỏ nhất (Min), bạn cần di chuyển từ gốc xuống node nào cho đến khi không còn node con trái nào nữa?",
            "answer": "Node con trái.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n    bst.root = build(0, len(arr) - 1)\n    return bst\n\n# Test\narr = [1, 2, 3, 4, 5, 6, 7]\nbst = sorted_array_to_bst(arr)\nprint(\"Level order:\", bst.level_order())  # [4, 2, 6, 1, 3, 5, 7]\n```\n\n#### 6.3. Serialize và Deserialize BST\n\n```python\ndef serialize(root):\n    \"\"\"Chuyển BST thành string\"\"\"\n    def preorder(node):\n        if node is None:\n            result.append('#')\n            return\n        result.append(str(node.val))\n        preorder(node.left)\n        preorder(node.right)\n    \n    result = []\n    preorder(root)\n    return ','.join(result)\n\ndef deserialize(data):\n    \"\"\"Xây dựng lại BST từ string\"\"\"\n    def build():\n        val = next(vals)\n        if val == '#':\n            return None\n        \n        node = TreeNode(int(val))\n        node.left = build()\n        node.right = build()\n        return node\n    \n    vals = iter(data.split(','))\n    return build()\n\n# Test\nbst = build_bst_from_array([8, 3, 10, 1, 6, 14])\nserialized = serialize(bst.root)\nprint(\"Serialized:\", serialized)\n\nroot = deserialize(serialized)\nbst2 = BST()\nbst2.root = root\nprint(\"Inorder after deserialize:\", bst2.inorder())\n```\n\n---\n\n### 7. Phân tích độ phức tạp\n\n| Thao tác | Average | Worst | Best |\n|----------|---------|-------|------|\n| Search | O(log n) | O(n) | O(1) |\n| Insert | O(log n) | O(n) | O(1) |\n| Delete | O(log n) | O(n) | O(1) |\n| Find Min/Max | O(log n) | O(n) | O(1) |\n| Inorder | O(n) | O(n) | O(n) |\n| Space | O(n) | O(n) | O(n) |\n\n**Worst case xảy ra khi:** Cây thoái hóa thành linked list (insert các phần tử đã sắp xếp)\n\n```\nCây cân bằng:        Cây thoái hóa:\n      4                   1\n     / \\                   \\\n    2   6                   2\n   / \\ / \\                   \\\n  1  3 5  7                   3\n                               \\\n                                4\nHeight: log n              Height: n\n```\n\n**Giải pháp:** Sử dụng **Self-balancing BST** như AVL Tree, Red-Black Tree\n\n---\n\n### 8. So sánh với các cấu trúc khác\n\n| Cấu trúc | Search | Insert | Delete | Sorted | Space |\n|----------|--------|--------|--------|--------|-------|\n| Array (unsorted) | O(n) | O(1) | O(n) | ❌ | O(n) |\n| Array (sorted) | O(log n) | O(n) | O(n) | ✅ | O(n) |\n| Linked List | O(n) | O(1) | O(n) | ❌ | O(n) |\n| BST | O(log n) | O(log n) | O(log n) | ✅ | O(n) |\n| Hash Table | O(1) | O(1) | O(1) | ❌ | O(n) |\n\n**Khi nào dùng BST?**\n- ✅ Cần duy trì thứ tự sorted\n- ✅ Cần range query (tìm trong khoảng)\n- ✅ Cần tìm successor/predecessor\n- ✅ Dynamic data (thêm/xóa thường xuyên)\n- ✅ Cần kth smallest/largest\n\n**Khi nào không dùng BST?**\n- ❌ Chỉ cần search nhanh → Hash Table\n- ❌ Truy cập theo index → Array\n- ❌ Dữ liệu đã sắp xếp → Sorted Array\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Find Min/Max là phép toán tìm phần tử nhỏ nhất hoặc lớn nhất trong cấu trúc dữ liệu Binary Search Tree (BST). Để tìm giá trị nhỏ nhất (Min), phép toán di chuyển từ gốc xuống node con trái cho đến khi không còn node con trái nào nữa, vì node nhỏ nhất luôn nằm ở tận cùng bên trái của cây. Tương tự, để tìm giá trị lớn nhất (Max), phép toán đi theo nhánh phải nhất. Độ phức tạp thời gian của phép toán này là O(h), trong đó h là chiều cao của cây. Cụ thể, Best case là O(1) (nếu phần tử min/max là gốc), Average case là O(log n) (đối với cây cân bằng), và Worst case là O(n) (đối với cây thoái hóa).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n    def _search_recursive(self, node, val):\n        # Base case\n        if node is None or node.val == val:\n            return node\n        \n        # Tìm trong cây con trái\n        if val < node.val:\n            return self._search_recursive(node.left, val)\n        \n        # Tìm trong cây con phải\n        return self._search_recursive(node.right, val)\n    \n    # Cách 2: Iterative\n    def search_iterative(self, val):\n        \"\"\"Tìm kiếm không đệ quy\"\"\"\n        current = self.root\n        \n        while current is not None:\n            if val == current.val:\n                return current\n            elif val < current.val:\n                current = current.left\n            else:\n                current = current.right\n        \n        return None\n```\n\n**Minh họa:**\n```\nTìm 6 trong BST:\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n\nBước 1: 6 < 8, đi sang trái\nBước 2: 6 > 3, đi sang phải\nBước 3: 6 == 6, tìm thấy!\n```\n\n#### 3.2. Insert (Thêm node)\n\n```python\n    def insert(self, val):\n        \"\"\"\n        Thêm node mới với giá trị val\n        Time: O(h)\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(val)\n        else:\n            self._insert_recursive(self.root, val)\n    \n    def _insert_recursive(self, node, val):\n        # Nếu giá trị nhỏ hơn, chèn vào trái\n        if val < node.val:\n            if node.left is None:\n                node.left = TreeNode(val)\n            else:\n                self._insert_recursive(node.left, val)\n        \n        # Nếu giá trị lớn hơn, chèn vào phải\n        elif val > node.val:\n            if node.right is None:\n                node.right = TreeNode(val)\n            else:\n                self._insert_recursive(node.right, val)\n        \n        # Nếu bằng, không làm gì (hoặc update)\n    \n    # Cách 2: Iterative\n    def insert_iterative(self, val):\n        \"\"\"Thêm node không đệ quy\"\"\"\n        new_node = TreeNode(val)\n        \n        if self.root is None:\n            self.root = new_node\n            return\n        \n        current = self.root\n        while True:\n            if val < current.val:\n                if current.left is None:\n                    current.left = new_node\n                    break\n                current = current.left\n            elif val > current.val:\n                if current.right is None:\n                    current.right = new_node\n                    break\n                current = current.right\n            else:\n                break  # Đã tồn tại\n```\n\n**Minh họa:**\n```\nInsert 5 vào BST:\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n\nBước 1: 5 < 8, đi trái\nBước 2: 5 > 3, đi phải\nBước 3: 5 < 6, chèn vào trái của 6\n\nKết quả:\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       /\n      5\n```\n\n#### 3.3. Find Min và Find Max\n\n```python\n    def find_min(self, node=None):\n        \"\"\"\n        Tìm node có giá trị nhỏ nhất\n        Đi sang trái cho đến hết\n        Time: O(h)\n        \"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return None\n        \n        while node.left is not None:\n            node = node.left\n        \n        return node\n    \n    def find_max(self, node=None):\n        \"\"\"\n        Tìm node có giá trị lớn nhất\n        Đi sang phải cho đến hết\n        Time: O(h)\n        \"\"\"\n        if node is None:\n            node = self.root\n        \n        if node is None:\n            return None\n        \n        while node.right is not None:\n            node = node.right\n        \n        return node\n```\n\n#### 3.4. Delete (Xóa node)\n\n\n**Các khái niệm quan trọng:**\n- Find Max là phép toán tìm node có giá trị lớn nhất trong cấu trúc dữ liệu. Trong Binary Search Tree, node lớn nhất luôn nằm ở tận cùng bên phải của cây. Phép toán này di chuyển từ gốc xuống node con phải cho đến khi không còn node con phải nào nữa. Độ phức tạp thời gian là O(h), trong đó h là chiều cao của cây. Best case O(log n), Worst case O(n).\n\n**Mối quan hệ:**\n- Phép toán Find Max có độ phức tạp thời gian O(h).\n- Phép toán Find Max trong Binary Search Tree có độ phức tạp thời gian O(h), trong đó h là chiều cao của cây.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n        Duyệt Preorder: Gốc - Trái - Phải\n        Dùng để copy cây, serialize\n        \"\"\"\n        if result is None:\n            result = []\n        if node is None:\n            node = self.root\n        \n        if node is not None:\n            result.append(node.val)\n            self.preorder(node.left, result)\n            self.preorder(node.right, result)\n        \n        return result\n    \n    # Iterative\n    def preorder_iterative(self):\n        \"\"\"Preorder không đệ quy\"\"\"\n        if self.root is None:\n            return []\n        \n        result = []\n        stack = [self.root]\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            # Push phải trước, trái sau (vì stack LIFO)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return result\n```\n\n#### 4.3. Postorder Traversal (Left-Right-Root)\n\n```python\n    def postorder(self, node=None, result=None):\n        \"\"\"\n        Duyệt Postorder: Trái - Phải - Gốc\n        Dùng để xóa cây, tính expression tree\n        \"\"\"\n        if result is None:\n            result = []\n        if node is None:\n            node = self.root\n        \n        if node is not None:\n            self.postorder(node.left, result)\n            self.postorder(node.right, result)\n            result.append(node.val)\n        \n        return result\n```\n\n#### 4.4. Level Order Traversal (BFS)\n\n```python\n    def level_order(self):\n        \"\"\"\n        Duyệt theo từng level (BFS)\n        Sử dụng queue\n        \"\"\"\n        if self.root is None:\n            return []\n        \n        from collections import deque\n        \n        result = []\n        queue = deque([self.root])\n        \n        while queue:\n            node = queue.popleft()\n            result.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        return result\n    \n    # Level by level\n    def level_order_by_level(self):\n        \"\"\"Duyệt theo level, trả về list của list\"\"\"\n        if self.root is None:\n            return []\n        \n        from collections import deque\n        \n        result = []\n        queue = deque([self.root])\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(current_level)\n        \n        return result\n```\n\n**Ví dụ các phép duyệt:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\\n      4  7\n\nInorder:    1, 3, 4, 6, 7, 8, 10, 14\nPreorder:   8, 3, 1, 6, 4, 7, 10, 14\nPostorder:  1, 4, 7, 6, 3, 14, 10, 8\nLevel Order: 8, 3, 10, 1, 6, 14, 4, 7\n```\n\n---\n\n### 5. Các thao tác nâng cao\n\n#### 5.1. Validate BST\n\n```python\n    def is_valid_bst(self):\n        \"\"\"\n        Kiểm tra cây có phải BST hợp lệ không\n        \"\"\"\n        def validate(node, min_val, max_val):\n            if node is None:\n                return True\n            \n            # Kiểm tra ràng buộc\n            if node.val <= min_val or node.val >= max_val:\n                return False\n            \n            # Kiểm tra đệ quy cây con\n            return (validate(node.left, min_val, node.val) and\n                    validate(node.right, node.val, max_val))\n        \n        return validate(self.root, float('-inf'), float('inf'))\n```\n\n#### 5.2. Height của cây\n\n```python\n    def height(self, node=None):\n        \"\"\"\n        Tính chiều cao của cây\n\n**Các khái niệm quan trọng:**\n- Expression Tree Evaluation là bài toán tính toán giá trị của một biểu thức được biểu diễn dưới dạng cây nhị phân. Duyệt Postorder thường được sử dụng để giải quyết bài toán này vì nó thăm các toán hạng (nút lá) trước, sau đó là toán tử (nút cha), cho phép thực hiện phép tính khi cả hai toán hạng đã có giá trị.\n\n**Mối quan hệ:**\n- Postorder Traversal được dùng để giải quyết bài toán Expression Tree Evaluation."
        },
        "output_without_context": {
            "question": "Trong cây nhị phân tìm kiếm (BST), phép toán nào được sử dụng để tìm giá trị nhỏ nhất trong cây?",
            "answer": "Min"
        }
    },
    {
        "topic_description": "Chủ đề này kiểm tra khả năng duyệt cây theo thứ tự trong BST và cách mà việc duyệt này tạo ra thứ tự các khóa. Học sinh nên thể hiện được hiểu biết về cách thức duyệt cây và ứng dụng của nó trong các thuật toán khác. Câu hỏi có thể yêu cầu viết mã hoặc mô tả quy trình duyệt.",
        "output_with_context": {
            "question": "Duyệt cây theo thứ tự nào trong Binary Search Tree (BST) sẽ cho ra dãy số theo thứ tự tăng dần?",
            "answer": "Inorder (Trái - Gốc - Phải)",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n| Delete | O(log n) | O(log n) avg, O(n) worst | O(n) |\n| Build | O(n) | O(n log n) | O(n log n) |\n\n**Khi nào dùng Heap?**\n- ✅ Cần extract min/max nhiều lần\n- ✅ Priority Queue\n- ✅ Tìm k largest/smallest elements\n- ✅ Median trong stream\n- ✅ Scheduling problems\n\n**Khi nào không dùng Heap?**\n- ❌ Cần search phần tử cụ thể (dùng BST)\n- ❌ Cần duyệt theo thứ tự (dùng BST)\n- ❌ Cần truy cập ngẫu nhiên (dùng array)\n\n---\n\n## Binary Search Tree \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Binary Search Tree (BST)** là một cây nhị phân có tính chất đặc biệt:\n- Tất cả các node trong cây con trái có giá trị **< node gốc**\n- Tất cả các node trong cây con phải có giá trị **> node gốc**\n- Cây con trái và cây con phải cũng là BST\n\n**Ví dụ BST hợp lệ:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  7 13\n```\n\n**Không phải BST:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  9 13    <- 9 > 8, không thể ở cây con trái\n```\n\n#### 1.2. Tính chất quan trọng\n\n**a) Duyệt Inorder cho thứ tự tăng dần:**\n- Duyệt BST theo Inorder (Left-Root-Right) cho dãy số tăng dần\n- Ví dụ trên: 1, 3, 4, 6, 7, 8, 10, 13, 14\n\n**b) Tìm kiếm hiệu quả:**\n- Có thể loại bỏ 1 nửa cây ở mỗi bước\n- Average case: O(log n)\n- Worst case: O(n) - cây thoái hóa thành linked list\n\n**c) Dynamic data structure:**\n- Dễ dàng insert và delete\n- Không cần biết trước kích thước\n\n#### 1.3. Ứng dụng\n\n- **Database indexing:** B-Tree, B+ Tree (biến thể của BST)\n- **File system:** Tổ chức thư mục\n- **Expression parsing:** Cây biểu thức\n- **Priority Queue:** Có thể implement bằng BST\n- **Auto-complete:** Trie (dạng đặc biệt của cây)\n\n---\n\n### 2. Cấu trúc Node và BST\n\n#### 2.1. Định nghĩa Node\n\n```python\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n    \n    def __repr__(self):\n        return f\"Node({self.val})\"\n```\n\n#### 2.2. Lớp BST\n\n```python\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def is_empty(self):\n        return self.root is None\n    \n    def get_root(self):\n        return self.root\n```\n\n---\n\n### 3. Các thao tác cơ bản\n\n#### 3.1. Search (Tìm kiếm)\n\n```python\n    def search(self, val):\n        \"\"\"\n        Tìm node có giá trị val\n        Time: O(h) với h là chiều cao cây\n        Average: O(log n), Worst: O(n)\n        \"\"\"\n        return self._search_recursive(self.root, val)\n    \n\n**Các khái niệm quan trọng:**\n- Traversal là phép toán duyệt qua tất cả các phần tử trong cấu trúc dữ liệu theo một thứ tự nhất định. Trong BST, duyệt Inorder cho kết quả các phần tử theo thứ tự tăng dần. Heap không hỗ trợ duyệt theo thứ tự cụ thể một cách hiệu quả.\n- Inorder traversal là một phương pháp duyệt cây nhị phân theo thứ tự Left-Root-Right. Khi áp dụng cho Binary Search Tree, Inorder traversal sẽ cho ra dãy các phần tử theo thứ tự tăng dần.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \nXóa node là thao tác phức tạp nhất, có 3 trường hợp:\n\n```python\n    def delete(self, val):\n        \"\"\"\n        Xóa node có giá trị val\n        Time: O(h)\n        \"\"\"\n        self.root = self._delete_recursive(self.root, val)\n    \n    def _delete_recursive(self, node, val):\n        # Base case\n        if node is None:\n            return None\n        \n        # Tìm node cần xóa\n        if val < node.val:\n            node.left = self._delete_recursive(node.left, val)\n        elif val > node.val:\n            node.right = self._delete_recursive(node.right, val)\n        else:\n            # Tìm thấy node cần xóa\n            \n            # Trường hợp 1: Node lá (không có con)\n            if node.left is None and node.right is None:\n                return None\n            \n            # Trường hợp 2a: Chỉ có con phải\n            if node.left is None:\n                return node.right\n            \n            # Trường hợp 2b: Chỉ có con trái\n            if node.right is None:\n                return node.left\n            \n            # Trường hợp 3: Có cả 2 con\n            # Tìm successor (node nhỏ nhất trong cây con phải)\n            successor = self.find_min(node.right)\n            \n            # Copy giá trị successor vào node hiện tại\n            node.val = successor.val\n            \n            # Xóa successor\n            node.right = self._delete_recursive(node.right, successor.val)\n        \n        return node\n```\n\n**Minh họa 3 trường hợp:**\n\n**Trường hợp 1: Xóa node lá (1)**\n```\nBefore:          After:\n    8               8\n   / \\             / \\\n  3   10          3   10\n / \\    \\          \\    \\\n1   6   14          6   14\n```\n\n**Trường hợp 2: Xóa node có 1 con (10)**\n```\nBefore:          After:\n    8               8\n   / \\             / \\\n  3   10          3   14\n / \\    \\        / \\\n1   6   14      1   6\n```\n\n**Trường hợp 3: Xóa node có 2 con (3)**\n```\nBefore:          After:\n    8               8\n   / \\             / \\\n  3   10          4   10\n / \\    \\        / \\    \\\n1   6   14      1   6   14\n   / \\             /\n  4  7            7\n\nBước 1: Tìm successor = 4 (min của cây con phải)\nBước 2: Copy 4 vào vị trí 3\nBước 3: Xóa 4 ở vị trí cũ\n```\n\n---\n\n### 4. Các phép duyệt cây (Tree Traversal)\n\n#### 4.1. Inorder Traversal (Left-Root-Right)\n\n```python\n    def inorder(self, node=None, result=None):\n        \"\"\"\n        Duyệt Inorder: Trái - Gốc - Phải\n        BST: cho thứ tự tăng dần\n        \"\"\"\n        if result is None:\n            result = []\n        if node is None:\n            node = self.root\n        \n        if node is not None:\n            self.inorder(node.left, result)\n            result.append(node.val)\n            self.inorder(node.right, result)\n        \n        return result\n    \n    # Iterative với stack\n    def inorder_iterative(self):\n        \"\"\"Inorder không đệ quy\"\"\"\n        result = []\n        stack = []\n        current = self.root\n        \n        while current or stack:\n            # Đi sang trái hết cỡ\n            while current:\n                stack.append(current)\n                current = current.left\n            \n            # Xử lý node\n            current = stack.pop()\n            result.append(current.val)\n            \n            # Đi sang phải\n            current = current.right\n        \n        return result\n```\n\n#### 4.2. Preorder Traversal (Root-Left-Right)\n\n```python\n    def preorder(self, node=None, result=None):\n        \"\"\"\n\n**Các khái niệm quan trọng:**\n- Duyệt Inorder là một thuật toán duyệt cây nhị phân theo thứ tự Trái - Gốc - Phải. Đối với Binary Search Tree, duyệt Inorder sẽ trả về các phần tử theo thứ tự tăng dần.\n- Inorder Traversal là một thuật toán duyệt cây nhị phân theo thứ tự \"Trái - Gốc - Phải\". Khi áp dụng cho Binary Search Tree, Inorder Traversal sẽ trả về các phần tử theo thứ tự tăng dần. Có thể triển khai bằng đệ quy hoặc không đệ quy sử dụng stack. Độ phức tạp thời gian là O(n) vì mỗi node được thăm đúng một lần. Độ phức tạp không gian là O(h) cho đệ quy (do stack call) hoặc O(h) cho iterative (do stack lưu trữ node).\n- Preorder Traversal (Duyệt Preorder) là một thuật toán duyệt cây nhị phân theo thứ tự \"Gốc - Trái - Phải\". Nó thường được sử dụng để tạo bản sao của cây, để serialize (chuyển đổi cây thành một chuỗi tuần tự) nhằm lưu trữ hoặc truyền tải, hoặc để biểu diễn cấu trúc của cây. Thuật toán này có thể được triển khai bằng phương pháp đệ quy hoặc không đệ quy (sử dụng stack). Độ phức tạp thời gian của Preorder Traversal là O(n) vì mỗi node trong cây được thăm đúng một lần. Độ phức tạp không gian là O(h), trong đó 'h' là chiều cao của cây, áp dụng cho cả triển khai đệ quy (do stack call) và không đệ quy (do stack lưu trữ node).\n\n**Mối quan hệ:**\n- Inorder Traversal trên Binary Search Tree đảm bảo trả về các phần tử theo thứ tự tăng dần.\n- Preorder Traversal là một trong các phương pháp duyệt cây được sử dụng trên Binary Search Tree.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n        Duyệt Preorder: Gốc - Trái - Phải\n        Dùng để copy cây, serialize\n        \"\"\"\n        if result is None:\n            result = []\n        if node is None:\n            node = self.root\n        \n        if node is not None:\n            result.append(node.val)\n            self.preorder(node.left, result)\n            self.preorder(node.right, result)\n        \n        return result\n    \n    # Iterative\n    def preorder_iterative(self):\n        \"\"\"Preorder không đệ quy\"\"\"\n        if self.root is None:\n            return []\n        \n        result = []\n        stack = [self.root]\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            # Push phải trước, trái sau (vì stack LIFO)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return result\n```\n\n#### 4.3. Postorder Traversal (Left-Right-Root)\n\n```python\n    def postorder(self, node=None, result=None):\n        \"\"\"\n        Duyệt Postorder: Trái - Phải - Gốc\n        Dùng để xóa cây, tính expression tree\n        \"\"\"\n        if result is None:\n            result = []\n        if node is None:\n            node = self.root\n        \n        if node is not None:\n            self.postorder(node.left, result)\n            self.postorder(node.right, result)\n            result.append(node.val)\n        \n        return result\n```\n\n#### 4.4. Level Order Traversal (BFS)\n\n```python\n    def level_order(self):\n        \"\"\"\n        Duyệt theo từng level (BFS)\n        Sử dụng queue\n        \"\"\"\n        if self.root is None:\n            return []\n        \n        from collections import deque\n        \n        result = []\n        queue = deque([self.root])\n        \n        while queue:\n            node = queue.popleft()\n            result.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        return result\n    \n    # Level by level\n    def level_order_by_level(self):\n        \"\"\"Duyệt theo level, trả về list của list\"\"\"\n        if self.root is None:\n            return []\n        \n        from collections import deque\n        \n        result = []\n        queue = deque([self.root])\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(current_level)\n        \n        return result\n```\n\n**Ví dụ các phép duyệt:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\\n      4  7\n\nInorder:    1, 3, 4, 6, 7, 8, 10, 14\nPreorder:   8, 3, 1, 6, 4, 7, 10, 14\nPostorder:  1, 4, 7, 6, 3, 14, 10, 8\nLevel Order: 8, 3, 10, 1, 6, 14, 4, 7\n```\n\n---\n\n### 5. Các thao tác nâng cao\n\n#### 5.1. Validate BST\n\n```python\n    def is_valid_bst(self):\n        \"\"\"\n        Kiểm tra cây có phải BST hợp lệ không\n        \"\"\"\n        def validate(node, min_val, max_val):\n            if node is None:\n                return True\n            \n            # Kiểm tra ràng buộc\n            if node.val <= min_val or node.val >= max_val:\n                return False\n            \n            # Kiểm tra đệ quy cây con\n            return (validate(node.left, min_val, node.val) and\n                    validate(node.right, node.val, max_val))\n        \n        return validate(self.root, float('-inf'), float('inf'))\n```\n\n#### 5.2. Height của cây\n\n```python\n    def height(self, node=None):\n        \"\"\"\n        Tính chiều cao của cây\n\n**Các khái niệm quan trọng:**\n- Duyệt Inorder là một thuật toán duyệt cây nhị phân theo thứ tự Trái - Gốc - Phải. Đối với Binary Search Tree, duyệt Inorder sẽ trả về các phần tử theo thứ tự tăng dần.\n- Duyệt Level Order là một thuật toán duyệt cây nhị phân theo từng cấp độ, từ trái sang phải. Nó còn được gọi là Breadth-First Search (BFS) trên cây. Thuật toán này sử dụng một hàng đợi (queue) để lưu trữ các nút cần thăm. Nó có thể trả về các nút theo thứ tự từng cấp hoặc trả về một danh sách các danh sách, mỗi danh sách con đại diện cho một cấp độ của cây.\n- Inorder Traversal là một thuật toán duyệt cây nhị phân theo thứ tự \"Trái - Gốc - Phải\". Khi áp dụng cho Binary Search Tree, Inorder Traversal sẽ trả về các phần tử theo thứ tự tăng dần. Có thể triển khai bằng đệ quy hoặc không đệ quy sử dụng stack. Độ phức tạp thời gian là O(n) vì mỗi node được thăm đúng một lần. Độ phức tạp không gian là O(h) cho đệ quy (do stack call) hoặc O(h) cho iterative (do stack lưu trữ node).\n- Preorder Traversal (Duyệt Preorder) là một thuật toán duyệt cây nhị phân theo thứ tự \"Gốc - Trái - Phải\". Nó thường được sử dụng để tạo bản sao của cây, để serialize (chuyển đổi cây thành một chuỗi tuần tự) nhằm lưu trữ hoặc truyền tải, hoặc để biểu diễn cấu trúc của cây. Thuật toán này có thể được triển khai bằng phương pháp đệ quy hoặc không đệ quy (sử dụng stack). Độ phức tạp thời gian của Preorder Traversal là O(n) vì mỗi node trong cây được thăm đúng một lần. Độ phức tạp không gian là O(h), trong đó 'h' là chiều cao của cây, áp dụng cho cả triển khai đệ quy (do stack call) và không đệ quy (do stack lưu trữ node).\n\n**Mối quan hệ:**\n- Inorder Traversal trên Binary Search Tree đảm bảo trả về các phần tử theo thứ tự tăng dần.\n- Preorder Traversal là một trong các phương pháp duyệt cây được sử dụng trên Binary Search Tree.\n- Level Order Traversal là một trong các phương pháp duyệt cây được sử dụng trên Binary Search Tree.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n    bst.root = build(0, len(arr) - 1)\n    return bst\n\n# Test\narr = [1, 2, 3, 4, 5, 6, 7]\nbst = sorted_array_to_bst(arr)\nprint(\"Level order:\", bst.level_order())  # [4, 2, 6, 1, 3, 5, 7]\n```\n\n#### 6.3. Serialize và Deserialize BST\n\n```python\ndef serialize(root):\n    \"\"\"Chuyển BST thành string\"\"\"\n    def preorder(node):\n        if node is None:\n            result.append('#')\n            return\n        result.append(str(node.val))\n        preorder(node.left)\n        preorder(node.right)\n    \n    result = []\n    preorder(root)\n    return ','.join(result)\n\ndef deserialize(data):\n    \"\"\"Xây dựng lại BST từ string\"\"\"\n    def build():\n        val = next(vals)\n        if val == '#':\n            return None\n        \n        node = TreeNode(int(val))\n        node.left = build()\n        node.right = build()\n        return node\n    \n    vals = iter(data.split(','))\n    return build()\n\n# Test\nbst = build_bst_from_array([8, 3, 10, 1, 6, 14])\nserialized = serialize(bst.root)\nprint(\"Serialized:\", serialized)\n\nroot = deserialize(serialized)\nbst2 = BST()\nbst2.root = root\nprint(\"Inorder after deserialize:\", bst2.inorder())\n```\n\n---\n\n### 7. Phân tích độ phức tạp\n\n| Thao tác | Average | Worst | Best |\n|----------|---------|-------|------|\n| Search | O(log n) | O(n) | O(1) |\n| Insert | O(log n) | O(n) | O(1) |\n| Delete | O(log n) | O(n) | O(1) |\n| Find Min/Max | O(log n) | O(n) | O(1) |\n| Inorder | O(n) | O(n) | O(n) |\n| Space | O(n) | O(n) | O(n) |\n\n**Worst case xảy ra khi:** Cây thoái hóa thành linked list (insert các phần tử đã sắp xếp)\n\n```\nCây cân bằng:        Cây thoái hóa:\n      4                   1\n     / \\                   \\\n    2   6                   2\n   / \\ / \\                   \\\n  1  3 5  7                   3\n                               \\\n                                4\nHeight: log n              Height: n\n```\n\n**Giải pháp:** Sử dụng **Self-balancing BST** như AVL Tree, Red-Black Tree\n\n---\n\n### 8. So sánh với các cấu trúc khác\n\n| Cấu trúc | Search | Insert | Delete | Sorted | Space |\n|----------|--------|--------|--------|--------|-------|\n| Array (unsorted) | O(n) | O(1) | O(n) | ❌ | O(n) |\n| Array (sorted) | O(log n) | O(n) | O(n) | ✅ | O(n) |\n| Linked List | O(n) | O(1) | O(n) | ❌ | O(n) |\n| BST | O(log n) | O(log n) | O(log n) | ✅ | O(n) |\n| Hash Table | O(1) | O(1) | O(1) | ❌ | O(n) |\n\n**Khi nào dùng BST?**\n- ✅ Cần duy trì thứ tự sorted\n- ✅ Cần range query (tìm trong khoảng)\n- ✅ Cần tìm successor/predecessor\n- ✅ Dynamic data (thêm/xóa thường xuyên)\n- ✅ Cần kth smallest/largest\n\n**Khi nào không dùng BST?**\n- ❌ Chỉ cần search nhanh → Hash Table\n- ❌ Truy cập theo index → Array\n- ❌ Dữ liệu đã sắp xếp → Sorted Array\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Inorder là phép toán duyệt cây theo thứ tự (duyệt trung thứ tự). Duyệt cây con trái, thăm node gốc, sau đó duyệt cây con phải. Kết quả là các phần tử được in ra theo thứ tự tăng dần. Độ phức tạp thời gian là O(n) vì mỗi node được thăm đúng một lần. Độ phức tạp không gian là O(n) trong trường hợp xấu nhất (cây thoái hóa) do stack đệ quy."
        },
        "output_without_context": {
            "question": "Trong cây nhị phân tìm kiếm (BST), thứ tự duyệt cây theo thứ tự sẽ tạo ra một dãy khóa theo thứ tự nào?",
            "answer": "Thứ tự tăng dần."
        }
    }
]