[
    {
        "topic_description": "Chủ đề này khám phá khái niệm đường đi ngắn nhất trong đồ thị có hướng có trọng số, bao gồm các ứng dụng thực tế như định tuyến bản đồ và lập kế hoạch giao thông. Học sinh sẽ được kiểm tra khả năng xác định các thuật toán phù hợp và ứng dụng của chúng trong thực tế.",
        "output_with_context": {
            "question": "Thuật toán nào được sử dụng để tìm đường đi ngắn nhất trong đồ thị có trọng số không âm?",
            "answer": "Dijkstra",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n| Bellman-Ford | Any weight | O(VE) | O(V) | ✅ | Detect |\n| Floyd-Warshall | Any weight | O(V³) | O(V²) | ✅ | Detect |\n\n**Khi nào dùng:**\n- **BFS:** Unweighted graph, đơn giản nhất\n- **Dijkstra:** Weighted graph, không có cạnh âm, nhanh nhất\n- **Bellman-Ford:** Có cạnh âm, hoặc cần detect negative cycle\n- **Floyd-Warshall:** Cần tất cả cặp shortest paths, graph nhỏ\n\n---\n\n### 8. Ứng dụng thực tế\n\n#### 8.1. Network Routing\n\n```python\ndef find_shortest_route(network, source, destination):\n    \"\"\"\n    Tìm tuyến đường ngắn nhất trong mạng\n    network: weighted graph (router graph)\n    \"\"\"\n    distances, parent = dijkstra(network, source)\n    \n    if distances[destination] == float('inf'):\n        return None, \"No route available\"\n    \n    path = reconstruct_path(parent, source, destination)\n    return path, distances[destination]\n```\n\n#### 8.2. Map Navigation (GPS)\n\n```python\ndef gps_navigation(map_graph, start, end):\n    \"\"\"\n    Tìm đường đi ngắn nhất trên bản đồ\n    Có thể mở rộng với A* algorithm\n    \"\"\"\n    path, distance = dijkstra_with_path(map_graph, start, end)\n    \n    if path is None:\n        return \"No route found\"\n    \n    return {\n        'path': path,\n        'distance': distance,\n        'estimated_time': distance / 60  # Giả sử 60km/h\n    }\n```\n\n#### 8.3. Currency Arbitrage Detection\n\n```python\ndef detect_arbitrage(exchange_rates):\n    \"\"\"\n    Phát hiện cơ hội arbitrage trong tỷ giá\n    Sử dụng negative cycle detection\n    \n    Chuyển đổi: weight = -log(exchange_rate)\n    Negative cycle = arbitrage opportunity\n    \"\"\"\n    import math\n    \n    edges = []\n    for source, targets in exchange_rates.items():\n        for target, rate in targets.items():\n            # Chuyển multiplication thành addition\n            weight = -math.log(rate)\n            edges.append((source, target, weight))\n    \n    return detect_negative_cycle(edges)\n```\n\n#### 8.4. Network Delay Time\n\n```python\ndef network_delay_time(times, n, k):\n    \"\"\"\n    Thời gian để tín hiệu đến tất cả nodes\n    times: [[u, v, w]] - từ u đến v mất w thời gian\n    n: số nodes\n    k: node nguồn\n    \"\"\"\n    # Build graph\n    graph = {i: {} for i in range(1, n + 1)}\n    for u, v, w in times:\n        graph[u][v] = w\n    \n    # Dijkstra\n    distances, _ = dijkstra(graph, k)\n    \n    # Max distance = thời gian cần\n    max_dist = max(distances.values())\n    \n    return max_dist if max_dist != float('inf') else -1\n\n# Test\ntimes = [[2,1,1], [2,3,1], [3,4,1]]\nprint(f\"Network delay: {network_delay_time(times, 4, 2)}\")\n```\n\n#### 8.5. Cheapest Flights Within K Stops\n\n```python\ndef cheapest_flights_k_stops(n, flights, src, dst, k):\n    \"\"\"\n    Tìm chuyến bay rẻ nhất với tối đa k điểm dừng\n    Modified Bellman-Ford\n    \"\"\"\n    # prices[i] = chi phí rẻ nhất đến đỉnh i\n    prices = [float('inf')] * n\n    prices[src] = 0\n    \n    # Lặp k+1 lần (tối đa k stops)\n    for _ in range(k + 1):\n        temp_prices = prices.copy()\n        \n        for u, v, price in flights:\n            if prices[u] != float('inf'):\n                temp_prices[v] = min(temp_prices[v], prices[u] + price)\n        \n        prices = temp_prices\n    \n\n**Các khái niệm quan trọng:**\n- Network Routing là bài toán tìm tuyến đường tối ưu (thường là ngắn nhất hoặc chi phí thấp nhất) để truyền dữ liệu giữa các điểm trong một mạng lưới, thường được mô hình hóa bằng đồ thị có trọng số.\n- Map Navigation (GPS) là bài toán tìm đường đi ngắn nhất hoặc nhanh nhất giữa hai điểm trên bản đồ, thường được mô hình hóa bằng đồ thị, trong đó các cạnh có trọng số biểu thị khoảng cách hoặc thời gian di chuyển.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n#### 5.1. Ý tưởng\n\n**Bellman-Ford** tìm đường đi ngắn nhất từ nguồn trong **weighted graph có thể có trọng số âm**.\n\n**Khác với Dijkstra:**\n- ✅ Xử lý được trọng số âm\n- ✅ Phát hiện được negative cycle\n- ❌ Chậm hơn: O(VE) vs O((V+E) log V)\n\n**Thuật toán:**\n1. Khởi tạo distance nguồn = 0, còn lại = ∞\n2. Lặp (V-1) lần:\n   - Relax tất cả các cạnh\n3. Kiểm tra negative cycle (lặp lần thứ V)\n\n#### 5.2. Cài đặt\n\n```python\ndef bellman_ford(graph, start):\n    \"\"\"\n    Bellman-Ford algorithm\n    Time: O(VE), Space: O(V)\n    \n    graph: list of edges [(u, v, weight)]\n    Returns: (distances, parent, has_negative_cycle)\n    \"\"\"\n    # Lấy tất cả vertices\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    # Khởi tạo\n    distances = {v: float('inf') for v in vertices}\n    distances[start] = 0\n    parent = {v: None for v in vertices}\n    \n    # Relax tất cả edges (V-1) lần\n    for _ in range(len(vertices) - 1):\n        updated = False\n        \n        for u, v, weight in graph:\n            if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n                distances[v] = distances[u] + weight\n                parent[v] = u\n                updated = True\n        \n        # Early termination nếu không có update\n        if not updated:\n            break\n    \n    # Kiểm tra negative cycle\n    has_negative_cycle = False\n    for u, v, weight in graph:\n        if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n            has_negative_cycle = True\n            break\n    \n    return distances, parent, has_negative_cycle\n\n# Test\nedges = [\n    ('A', 'B', 4),\n    ('A', 'C', 2),\n    ('B', 'C', 1),\n    ('B', 'D', 5),\n    ('C', 'D', 8),\n    ('C', 'E', 10),\n    ('D', 'E', 2),\n    ('D', 'F', 6),\n    ('E', 'F', 3)\n]\n\ndistances, parent, has_neg_cycle = bellman_ford(edges, 'A')\nprint(\"\nBellman-Ford from A:\")\nprint(f\"Has negative cycle: {has_neg_cycle}\")\nfor vertex in sorted(distances.keys()):\n    print(f\"A → {vertex}: {distances[vertex]}\")\n```\n\n#### 5.3. Phát hiện Negative Cycle\n\n```python\ndef detect_negative_cycle(graph):\n    \"\"\"\n    Phát hiện negative cycle trong graph\n    \"\"\"\n    # Thử từ mỗi vertex (cho disconnected graph)\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    for start in vertices:\n        _, _, has_cycle = bellman_ford(graph, start)\n        if has_cycle:\n            return True\n    \n    return False\n\n# Test với negative cycle\nedges_with_cycle = [\n    ('A', 'B', 1),\n    ('B', 'C', -3),\n    ('C', 'A', 1)  # Cycle A→B→C→A có tổng = -1\n]\n\nprint(f\"\nHas negative cycle: {detect_negative_cycle(edges_with_cycle)}\")\n```\n\n**Minh họa Negative Cycle:**\n```\nGraph with negative cycle:\n    A --1-→ B\n    ↑       |\n    1       -3\n    |       ↓\n    +←------C\n\nCycle: A → B → C → A\nWeight: 1 + (-3) + 1 = -1 (negative!)\n\nMỗi lần đi qua cycle, distance giảm → không có shortest path\n```\n\n---\n\n### 6. Floyd-Warshall Algorithm (All Pairs)\n\n#### 6.1. Ý tưởng\n\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n- Graph Algorithms (Thuật toán đồ thị) là một lĩnh vực trong khoa học máy tính tập trung vào việc nghiên cứu và giải quyết các bài toán trên cấu trúc dữ liệu đồ thị. Các bài toán phổ biến bao gồm tìm đường đi ngắn nhất, tìm kiếm theo chiều sâu/rộng (duyệt đồ thị), tìm cây bao trùm tối thiểu/nhỏ nhất, v.v.\n\n**Mối quan hệ:**\n- BFS Shortest Path giải quyết bài toán tìm đường đi ngắn nhất trong unweighted graph.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n3. Duyệt các đỉnh kề, cập nhật khoảng cách\n4. Lặp lại cho đến khi queue rỗng\n\n#### 3.2. Cài đặt\n\n```python\nfrom collections import deque\n\ndef bfs_shortest_path(graph, start):\n    \"\"\"\n    Tìm đường đi ngắn nhất từ start đến tất cả đỉnh\n    Chỉ dùng cho unweighted graph\n    Time: O(V + E), Space: O(V)\n    \"\"\"\n    # Khởi tạo\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    parent = {vertex: None for vertex in graph}\n    \n    queue = deque([start])\n    \n    while queue:\n        current = queue.popleft()\n        \n        # Duyệt các đỉnh kề\n        for neighbor in graph[current]:\n            if distances[neighbor] == float('inf'):\n                distances[neighbor] = distances[current] + 1\n                parent[neighbor] = current\n                queue.append(neighbor)\n    \n    return distances, parent\n\ndef reconstruct_path(parent, start, end):\n    \"\"\"Tái tạo đường đi từ start đến end\"\"\"\n    if parent[end] is None and start != end:\n        return None  # Không có đường đi\n    \n    path = []\n    current = end\n    \n    while current is not None:\n        path.append(current)\n        current = parent[current]\n    \n    path.reverse()\n    return path\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\ndistances, parent = bfs_shortest_path(graph, 'A')\nprint(\"Distances from A:\", distances)\nprint(\"Path A to F:\", reconstruct_path(parent, 'A', 'F'))\n```\n\n**Minh họa:**\n```\nGraph:\n    A --- B --- D\n    |     |\n    C --- F --- E\n\nBFS từ A:\nLevel 0: A (distance = 0)\nLevel 1: B, C (distance = 1)\nLevel 2: D, E, F (distance = 2)\n\nShortest paths from A:\nA → B: 1\nA → C: 1\nA → D: 2 (A → B → D)\nA → E: 2 (A → B → E)\nA → F: 2 (A → C → F)\n```\n\n---\n\n### 4. Dijkstra's Algorithm\n\n#### 4.1. Ý tưởng\n\n**Dijkstra** tìm đường đi ngắn nhất từ nguồn đến tất cả đỉnh trong **weighted graph với trọng số không âm**.\n\n**Thuật toán (Greedy):**\n1. Khởi tạo khoảng cách nguồn = 0, còn lại = ∞\n2. Dùng min-heap (priority queue)\n3. Chọn đỉnh có khoảng cách nhỏ nhất chưa xét\n4. **Relaxation:** Cập nhật khoảng cách các đỉnh kề\n5. Lặp lại cho đến khi tất cả đỉnh được xét\n\n**Relaxation:**\n```\nif dist[u] + weight(u, v) < dist[v]:\n    dist[v] = dist[u] + weight(u, v)\n    parent[v] = u\n```\n\n#### 4.2. Cài đặt\n\n```python\nimport heapq\n\ndef dijkstra(graph, start):\n    \"\"\"\n    Dijkstra's algorithm cho weighted graph\n    Time: O((V + E) log V) với binary heap\n    Space: O(V)\n    \n    graph: dict of dict\n    graph[u][v] = weight of edge (u, v)\n    \"\"\"\n    # Khởi tạo\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    parent = {vertex: None for vertex in graph}\n    \n    # Min heap: (distance, vertex)\n    pq = [(0, start)]\n    visited = set()\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        \n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n- Graph Algorithms (Thuật toán đồ thị) là một lĩnh vực trong khoa học máy tính tập trung vào việc nghiên cứu và giải quyết các bài toán trên cấu trúc dữ liệu đồ thị. Các bài toán phổ biến bao gồm tìm đường đi ngắn nhất, tìm kiếm theo chiều sâu/rộng (duyệt đồ thị), tìm cây bao trùm tối thiểu/nhỏ nhất, v.v.\n\n**Mối quan hệ:**\n- BFS Shortest Path giải quyết bài toán tìm đường đi ngắn nhất trong unweighted graph.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n\n### 1. Giới thiệu về Graph (Đồ thị)\n\n#### 1.1. Khái niệm cơ bản\n\n**Graph (Đồ thị)** là một cấu trúc dữ liệu bao gồm:\n- **Vertices (V):** Tập các đỉnh (nodes)\n- **Edges (E):** Tập các cạnh kết nối các đỉnh\n\n**Ký hiệu:** G = (V, E)\n\n**Các loại graph:**\n\n**a) Directed vs Undirected:**\n```\nUndirected:           Directed (Digraph):\n    A --- B               A → B\n    |     |               ↓   ↓\n    C --- D               C → D\n```\n\n**b) Weighted vs Unweighted:**\n```\nUnweighted:           Weighted:\n    A --- B               A --5-- B\n    |     |               |       |\n    C --- D               3       7\n                          |       |\n                          C --2-- D\n```\n\n**c) Connected vs Disconnected:**\n```\nConnected:            Disconnected:\n    A --- B               A --- B    E --- F\n    |     |                          \n    C --- D               C --- D    \n```\n\n#### 1.2. Biểu diễn Graph\n\n**a) Adjacency Matrix (Ma trận kề):**\n```python\n# Không gian: O(V²)\ngraph = [\n    [0, 1, 1, 0],  # A kết nối với B, C\n    [1, 0, 0, 1],  # B kết nối với A, D\n    [1, 0, 0, 1],  # C kết nối với A, D\n    [0, 1, 1, 0]   # D kết nối với B, C\n]\n```\n\n**b) Adjacency List (Danh sách kề):**\n```python\n# Không gian: O(V + E)\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D'],\n    'C': ['A', 'D'],\n    'D': ['B', 'C']\n}\n\n# Weighted graph\nweighted_graph = {\n    'A': [('B', 5), ('C', 3)],\n    'B': [('A', 5), ('D', 7)],\n    'C': [('A', 3), ('D', 2)],\n    'D': [('B', 7), ('C', 2)]\n}\n```\n\n**So sánh:**\n\n| Đặc điểm | Adjacency Matrix | Adjacency List |\n|----------|------------------|----------------|\n| Space | O(V²) | O(V + E) |\n| Check edge (u,v) | O(1) | O(degree(u)) |\n| Iterate neighbors | O(V) | O(degree(u)) |\n| Add vertex | O(V²) | O(1) |\n| Add edge | O(1) | O(1) |\n\n---\n\n### 2. Bài toán Shortest Path (Đường đi ngắn nhất)\n\n**Phân loại:**\n\n1. **Single Source Shortest Path (SSSP):**\n   - Từ 1 đỉnh nguồn đến tất cả đỉnh khác\n   - Algorithms: BFS, Dijkstra, Bellman-Ford\n\n2. **All Pairs Shortest Path (APSP):**\n   - Giữa mọi cặp đỉnh\n   - Algorithm: Floyd-Warshall\n\n**Đặc điểm:**\n- **Unweighted:** BFS\n- **Non-negative weights:** Dijkstra\n- **Negative weights:** Bellman-Ford\n- **Negative cycles:** Bellman-Ford (detect)\n\n---\n\n### 3. BFS (Breadth-First Search) - Unweighted\n\n#### 3.1. Ý tưởng\n\nBFS tìm đường đi ngắn nhất trong **unweighted graph** bằng cách duyệt theo từng level.\n\n**Thuật toán:**\n1. Dùng queue, bắt đầu từ đỉnh nguồn\n2. Đánh dấu khoảng cách từ nguồn = 0\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n- Unweighted là điều kiện áp dụng cho các thuật toán tìm đường đi ngắn nhất khi tất cả các cạnh trong đồ thị có trọng số bằng nhau (thường là 1). BFS là thuật toán phù hợp cho trường hợp này.\n\n**Mối quan hệ:**\n- Floyd-Warshall Algorithm giải quyết bài toán tìm đường đi ngắn nhất giữa tất cả các cặp đỉnh (All Pairs Shortest Path).\n- BFS Shortest Path giải quyết bài toán tìm đường đi ngắn nhất trong unweighted graph.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n**Floyd-Warshall** tìm đường đi ngắn nhất giữa **mọi cặp đỉnh**.\n\n**Dynamic Programming:**\n- `dp[k][i][j]` = shortest path từ i đến j qua các đỉnh {1, 2, ..., k}\n- `dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])`\n\n**Có thể tối ưu:** Dùng 2D array thay vì 3D\n\n#### 6.2. Cài đặt\n\n```python\ndef floyd_warshall(graph):\n    \"\"\"\n    Floyd-Warshall algorithm\n    Time: O(V³), Space: O(V²)\n    \n    graph: adjacency matrix (2D list)\n    graph[i][j] = weight of edge (i, j)\n    Use float('inf') for no edge\n    \"\"\"\n    n = len(graph)\n    \n    # Copy graph để không thay đổi input\n    dist = [row[:] for row in graph]\n    \n    # next[i][j] = đỉnh tiếp theo trên đường đi từ i đến j\n    next_vertex = [[None] * n for _ in range(n)]\n    \n    # Khởi tạo next_vertex\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] != float('inf') and i != j:\n                next_vertex[i][j] = j\n    \n    # Floyd-Warshall\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i][k] + dist[k][j] < dist[i][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n                    next_vertex[i][j] = next_vertex[i][k]\n    \n    return dist, next_vertex\n\ndef reconstruct_path_floyd(next_vertex, i, j):\n    \"\"\"Tái tạo đường đi từ i đến j\"\"\"\n    if next_vertex[i][j] is None:\n        return None\n    \n    path = [i]\n    while i != j:\n        i = next_vertex[i][j]\n        path.append(i)\n    \n    return path\n\n# Test\nINF = float('inf')\nadj_matrix = [\n    [0,   4,   2,   INF, INF, INF],  # A\n    [4,   0,   1,   5,   INF, INF],  # B\n    [2,   1,   0,   8,   10,  INF],  # C\n    [INF, 5,   8,   0,   2,   6],    # D\n    [INF, INF, 10,  2,   0,   3],    # E\n    [INF, INF, INF, 6,   3,   0]     # F\n]\n\ndist, next_v = floyd_warshall(adj_matrix)\n\nvertices = ['A', 'B', 'C', 'D', 'E', 'F']\nprint(\"\nFloyd-Warshall (All Pairs):\")\nprint(\"\nDistance Matrix:\")\nfor i in range(len(vertices)):\n    for j in range(len(vertices)):\n        if dist[i][j] == INF:\n            print(\"INF\", end=\"\t\")\n        else:\n            print(f\"{dist[i][j]}\", end=\"\t\")\n    print(f\"  ({vertices[i]})\")\n\n# Ví dụ một vài đường đi\nprint(\"\nSample paths:\")\nfor i in range(3):\n    for j in range(3, 6):\n        path = reconstruct_path_floyd(next_v, i, j)\n        if path:\n            path_str = ' → '.join(vertices[k] for k in path)\n            print(f\"{vertices[i]} → {vertices[j]}: {dist[i][j]} ({path_str})\")\n```\n\n---\n\n### 7. So sánh các thuật toán\n\n| Algorithm | Graph Type | Time | Space | Negative Weight | Negative Cycle |\n|-----------|-----------|------|-------|-----------------|----------------|\n| BFS | Unweighted | O(V+E) | O(V) | N/A | N/A |\n| Dijkstra | Non-negative weight | O((V+E)logV) | O(V) | ❌ | ❌ |\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n\n**Mối quan hệ:**\n- BFS Shortest Path giải quyết bài toán tìm đường đi ngắn nhất trong unweighted graph."
        },
        "output_without_context": {
            "question": "Thuật toán nào thường được sử dụng để tìm đường đi ngắn nhất trong đồ thị có trọng số?",
            "answer": "Thuật toán Dijkstra"
        }
    },
    {
        "topic_description": "Chủ đề này tập trung vào các biến thể của bài toán tìm đường đi ngắn nhất, phân tích các loại trọng số cạnh và các điều kiện yêu cầu. Học sinh sẽ được kiểm tra khả năng phân loại và áp dụng các thuật toán tìm đường dựa trên các điều kiện khác nhau.",
        "output_with_context": {
            "question": "Trong bài toán tìm đường đi ngắn nhất, thuật toán nào được sử dụng để tìm đường đi từ một đỉnh nguồn đến tất cả các đỉnh khác trong đồ thị có trọng số không âm?",
            "answer": "Dijkstra",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n\n### 1. Giới thiệu về Graph (Đồ thị)\n\n#### 1.1. Khái niệm cơ bản\n\n**Graph (Đồ thị)** là một cấu trúc dữ liệu bao gồm:\n- **Vertices (V):** Tập các đỉnh (nodes)\n- **Edges (E):** Tập các cạnh kết nối các đỉnh\n\n**Ký hiệu:** G = (V, E)\n\n**Các loại graph:**\n\n**a) Directed vs Undirected:**\n```\nUndirected:           Directed (Digraph):\n    A --- B               A → B\n    |     |               ↓   ↓\n    C --- D               C → D\n```\n\n**b) Weighted vs Unweighted:**\n```\nUnweighted:           Weighted:\n    A --- B               A --5-- B\n    |     |               |       |\n    C --- D               3       7\n                          |       |\n                          C --2-- D\n```\n\n**c) Connected vs Disconnected:**\n```\nConnected:            Disconnected:\n    A --- B               A --- B    E --- F\n    |     |                          \n    C --- D               C --- D    \n```\n\n#### 1.2. Biểu diễn Graph\n\n**a) Adjacency Matrix (Ma trận kề):**\n```python\n# Không gian: O(V²)\ngraph = [\n    [0, 1, 1, 0],  # A kết nối với B, C\n    [1, 0, 0, 1],  # B kết nối với A, D\n    [1, 0, 0, 1],  # C kết nối với A, D\n    [0, 1, 1, 0]   # D kết nối với B, C\n]\n```\n\n**b) Adjacency List (Danh sách kề):**\n```python\n# Không gian: O(V + E)\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D'],\n    'C': ['A', 'D'],\n    'D': ['B', 'C']\n}\n\n# Weighted graph\nweighted_graph = {\n    'A': [('B', 5), ('C', 3)],\n    'B': [('A', 5), ('D', 7)],\n    'C': [('A', 3), ('D', 2)],\n    'D': [('B', 7), ('C', 2)]\n}\n```\n\n**So sánh:**\n\n| Đặc điểm | Adjacency Matrix | Adjacency List |\n|----------|------------------|----------------|\n| Space | O(V²) | O(V + E) |\n| Check edge (u,v) | O(1) | O(degree(u)) |\n| Iterate neighbors | O(V) | O(degree(u)) |\n| Add vertex | O(V²) | O(1) |\n| Add edge | O(1) | O(1) |\n\n---\n\n### 2. Bài toán Shortest Path (Đường đi ngắn nhất)\n\n**Phân loại:**\n\n1. **Single Source Shortest Path (SSSP):**\n   - Từ 1 đỉnh nguồn đến tất cả đỉnh khác\n   - Algorithms: BFS, Dijkstra, Bellman-Ford\n\n2. **All Pairs Shortest Path (APSP):**\n   - Giữa mọi cặp đỉnh\n   - Algorithm: Floyd-Warshall\n\n**Đặc điểm:**\n- **Unweighted:** BFS\n- **Non-negative weights:** Dijkstra\n- **Negative weights:** Bellman-Ford\n- **Negative cycles:** Bellman-Ford (detect)\n\n---\n\n### 3. BFS (Breadth-First Search) - Unweighted\n\n#### 3.1. Ý tưởng\n\nBFS tìm đường đi ngắn nhất trong **unweighted graph** bằng cách duyệt theo từng level.\n\n**Thuật toán:**\n1. Dùng queue, bắt đầu từ đỉnh nguồn\n2. Đánh dấu khoảng cách từ nguồn = 0\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n- Single Source Shortest Path (SSSP) là bài toán tìm đường đi ngắn nhất từ một đỉnh nguồn duy nhất đến tất cả các đỉnh khác trong Graph. Các thuật toán giải quyết SSSP bao gồm BFS, Dijkstra và Bellman-Ford.\n- Unweighted là điều kiện áp dụng cho các thuật toán tìm đường đi ngắn nhất khi tất cả các cạnh trong đồ thị có trọng số bằng nhau (thường là 1). BFS là thuật toán phù hợp cho trường hợp này.\n\n**Mối quan hệ:**\n- Bài toán Shortest Path có phân loại Single Source Shortest Path (SSSP).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n        # Đã xét rồi (vì có thể có nhiều entry trong heap)\n        if current in visited:\n            continue\n        \n        visited.add(current)\n        \n        # Không cần xét nếu distance đã lớn hơn\n        if current_dist > distances[current]:\n            continue\n        \n        # Relaxation\n        for neighbor, weight in graph[current].items():\n            distance = current_dist + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                parent[neighbor] = current\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances, parent\n\n# Test\nweighted_graph = {\n    'A': {'B': 4, 'C': 2},\n    'B': {'A': 4, 'C': 1, 'D': 5},\n    'C': {'A': 2, 'B': 1, 'D': 8, 'E': 10},\n    'D': {'B': 5, 'C': 8, 'E': 2, 'F': 6},\n    'E': {'C': 10, 'D': 2, 'F': 3},\n    'F': {'D': 6, 'E': 3}\n}\n\ndistances, parent = dijkstra(weighted_graph, 'A')\nprint(\"\nDijkstra from A:\")\nfor vertex in distances:\n    print(f\"A → {vertex}: {distances[vertex]}\")\n    path = reconstruct_path(parent, 'A', vertex)\n    print(f\"  Path: {' → '.join(path) if path else 'No path'}\")\n```\n\n**Minh họa từng bước:**\n```\nGraph:\n    A --4-- B --5-- D\n    |  \\    |  \\    |  \\\n    2   1   1   8   2   6\n    |    \\  |    \\  |    \\\n    C --8-- + --10- E --3-- F\n\nStep by step từ A:\n\nInitial: A=0, B=∞, C=∞, D=∞, E=∞, F=∞\n\n1. Chọn A (dist=0)\n   Relax: B=4, C=2\n   Heap: [(2,C), (4,B)]\n\n2. Chọn C (dist=2)\n   Relax: B=min(4,2+1)=3, D=10, E=12\n   Heap: [(3,B), (4,B), (10,D), (12,E)]\n\n3. Chọn B (dist=3)\n   Relax: D=min(10,3+5)=8\n   Heap: [(4,B), (8,D), (10,D), (12,E)]\n\n4. Chọn B (dist=4) - Skip (visited)\n\n5. Chọn D (dist=8)\n   Relax: E=min(12,8+2)=10, F=14\n   Heap: [(10,D), (10,E), (12,E), (14,F)]\n\n6. Chọn D (dist=10) - Skip\n\n7. Chọn E (dist=10)\n   Relax: F=min(14,10+3)=13\n   Heap: [(12,E), (13,F), (14,F)]\n\n8. Continue...\n\nFinal distances:\nA → A: 0\nA → B: 3 (A → C → B)\nA → C: 2 (A → C)\nA → D: 8 (A → C → B → D)\nA → E: 10 (A → C → B → D → E)\nA → F: 13 (A → C → B → D → E → F)\n```\n\n#### 4.3. Dijkstra với Path Reconstruction\n\n```python\ndef dijkstra_with_path(graph, start, end):\n    \"\"\"\n    Tìm đường đi ngắn nhất từ start đến end\n    \"\"\"\n    distances, parent = dijkstra(graph, start)\n    \n    if distances[end] == float('inf'):\n        return None, float('inf')\n    \n    path = reconstruct_path(parent, start, end)\n    return path, distances[end]\n\n# Test\npath, dist = dijkstra_with_path(weighted_graph, 'A', 'F')\nprint(f\"\nShortest path A → F: {' → '.join(path)}\")\nprint(f\"Distance: {dist}\")\n```\n\n---\n\n### 5. Bellman-Ford Algorithm\n\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n\n**Mối quan hệ:**\n- Bellman-Ford Algorithm giải quyết bài toán Shortest Path trong đồ thị có trọng số âm và phát hiện chu trình âm.\n- Bài toán Shortest Path có phân loại Single Source Shortest Path (SSSP).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n#### 5.1. Ý tưởng\n\n**Bellman-Ford** tìm đường đi ngắn nhất từ nguồn trong **weighted graph có thể có trọng số âm**.\n\n**Khác với Dijkstra:**\n- ✅ Xử lý được trọng số âm\n- ✅ Phát hiện được negative cycle\n- ❌ Chậm hơn: O(VE) vs O((V+E) log V)\n\n**Thuật toán:**\n1. Khởi tạo distance nguồn = 0, còn lại = ∞\n2. Lặp (V-1) lần:\n   - Relax tất cả các cạnh\n3. Kiểm tra negative cycle (lặp lần thứ V)\n\n#### 5.2. Cài đặt\n\n```python\ndef bellman_ford(graph, start):\n    \"\"\"\n    Bellman-Ford algorithm\n    Time: O(VE), Space: O(V)\n    \n    graph: list of edges [(u, v, weight)]\n    Returns: (distances, parent, has_negative_cycle)\n    \"\"\"\n    # Lấy tất cả vertices\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    # Khởi tạo\n    distances = {v: float('inf') for v in vertices}\n    distances[start] = 0\n    parent = {v: None for v in vertices}\n    \n    # Relax tất cả edges (V-1) lần\n    for _ in range(len(vertices) - 1):\n        updated = False\n        \n        for u, v, weight in graph:\n            if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n                distances[v] = distances[u] + weight\n                parent[v] = u\n                updated = True\n        \n        # Early termination nếu không có update\n        if not updated:\n            break\n    \n    # Kiểm tra negative cycle\n    has_negative_cycle = False\n    for u, v, weight in graph:\n        if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n            has_negative_cycle = True\n            break\n    \n    return distances, parent, has_negative_cycle\n\n# Test\nedges = [\n    ('A', 'B', 4),\n    ('A', 'C', 2),\n    ('B', 'C', 1),\n    ('B', 'D', 5),\n    ('C', 'D', 8),\n    ('C', 'E', 10),\n    ('D', 'E', 2),\n    ('D', 'F', 6),\n    ('E', 'F', 3)\n]\n\ndistances, parent, has_neg_cycle = bellman_ford(edges, 'A')\nprint(\"\nBellman-Ford from A:\")\nprint(f\"Has negative cycle: {has_neg_cycle}\")\nfor vertex in sorted(distances.keys()):\n    print(f\"A → {vertex}: {distances[vertex]}\")\n```\n\n#### 5.3. Phát hiện Negative Cycle\n\n```python\ndef detect_negative_cycle(graph):\n    \"\"\"\n    Phát hiện negative cycle trong graph\n    \"\"\"\n    # Thử từ mỗi vertex (cho disconnected graph)\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    for start in vertices:\n        _, _, has_cycle = bellman_ford(graph, start)\n        if has_cycle:\n            return True\n    \n    return False\n\n# Test với negative cycle\nedges_with_cycle = [\n    ('A', 'B', 1),\n    ('B', 'C', -3),\n    ('C', 'A', 1)  # Cycle A→B→C→A có tổng = -1\n]\n\nprint(f\"\nHas negative cycle: {detect_negative_cycle(edges_with_cycle)}\")\n```\n\n**Minh họa Negative Cycle:**\n```\nGraph with negative cycle:\n    A --1-→ B\n    ↑       |\n    1       -3\n    |       ↓\n    +←------C\n\nCycle: A → B → C → A\nWeight: 1 + (-3) + 1 = -1 (negative!)\n\nMỗi lần đi qua cycle, distance giảm → không có shortest path\n```\n\n---\n\n### 6. Floyd-Warshall Algorithm (All Pairs)\n\n#### 6.1. Ý tưởng\n\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n\n**Mối quan hệ:**\n- Bellman-Ford Algorithm giải quyết bài toán Shortest Path trong đồ thị có trọng số âm và phát hiện chu trình âm.\n- Bài toán Shortest Path có phân loại Single Source Shortest Path (SSSP).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n**Floyd-Warshall** tìm đường đi ngắn nhất giữa **mọi cặp đỉnh**.\n\n**Dynamic Programming:**\n- `dp[k][i][j]` = shortest path từ i đến j qua các đỉnh {1, 2, ..., k}\n- `dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])`\n\n**Có thể tối ưu:** Dùng 2D array thay vì 3D\n\n#### 6.2. Cài đặt\n\n```python\ndef floyd_warshall(graph):\n    \"\"\"\n    Floyd-Warshall algorithm\n    Time: O(V³), Space: O(V²)\n    \n    graph: adjacency matrix (2D list)\n    graph[i][j] = weight of edge (i, j)\n    Use float('inf') for no edge\n    \"\"\"\n    n = len(graph)\n    \n    # Copy graph để không thay đổi input\n    dist = [row[:] for row in graph]\n    \n    # next[i][j] = đỉnh tiếp theo trên đường đi từ i đến j\n    next_vertex = [[None] * n for _ in range(n)]\n    \n    # Khởi tạo next_vertex\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] != float('inf') and i != j:\n                next_vertex[i][j] = j\n    \n    # Floyd-Warshall\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i][k] + dist[k][j] < dist[i][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n                    next_vertex[i][j] = next_vertex[i][k]\n    \n    return dist, next_vertex\n\ndef reconstruct_path_floyd(next_vertex, i, j):\n    \"\"\"Tái tạo đường đi từ i đến j\"\"\"\n    if next_vertex[i][j] is None:\n        return None\n    \n    path = [i]\n    while i != j:\n        i = next_vertex[i][j]\n        path.append(i)\n    \n    return path\n\n# Test\nINF = float('inf')\nadj_matrix = [\n    [0,   4,   2,   INF, INF, INF],  # A\n    [4,   0,   1,   5,   INF, INF],  # B\n    [2,   1,   0,   8,   10,  INF],  # C\n    [INF, 5,   8,   0,   2,   6],    # D\n    [INF, INF, 10,  2,   0,   3],    # E\n    [INF, INF, INF, 6,   3,   0]     # F\n]\n\ndist, next_v = floyd_warshall(adj_matrix)\n\nvertices = ['A', 'B', 'C', 'D', 'E', 'F']\nprint(\"\nFloyd-Warshall (All Pairs):\")\nprint(\"\nDistance Matrix:\")\nfor i in range(len(vertices)):\n    for j in range(len(vertices)):\n        if dist[i][j] == INF:\n            print(\"INF\", end=\"\t\")\n        else:\n            print(f\"{dist[i][j]}\", end=\"\t\")\n    print(f\"  ({vertices[i]})\")\n\n# Ví dụ một vài đường đi\nprint(\"\nSample paths:\")\nfor i in range(3):\n    for j in range(3, 6):\n        path = reconstruct_path_floyd(next_v, i, j)\n        if path:\n            path_str = ' → '.join(vertices[k] for k in path)\n            print(f\"{vertices[i]} → {vertices[j]}: {dist[i][j]} ({path_str})\")\n```\n\n---\n\n### 7. So sánh các thuật toán\n\n| Algorithm | Graph Type | Time | Space | Negative Weight | Negative Cycle |\n|-----------|-----------|------|-------|-----------------|----------------|\n| BFS | Unweighted | O(V+E) | O(V) | N/A | N/A |\n| Dijkstra | Non-negative weight | O((V+E)logV) | O(V) | ❌ | ❌ |\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n\n**Mối quan hệ:**\n- Bellman-Ford Algorithm giải quyết bài toán Shortest Path trong đồ thị có trọng số âm và phát hiện chu trình âm.\n- Bài toán Shortest Path có phân loại Single Source Shortest Path (SSSP).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n| Bellman-Ford | Any weight | O(VE) | O(V) | ✅ | Detect |\n| Floyd-Warshall | Any weight | O(V³) | O(V²) | ✅ | Detect |\n\n**Khi nào dùng:**\n- **BFS:** Unweighted graph, đơn giản nhất\n- **Dijkstra:** Weighted graph, không có cạnh âm, nhanh nhất\n- **Bellman-Ford:** Có cạnh âm, hoặc cần detect negative cycle\n- **Floyd-Warshall:** Cần tất cả cặp shortest paths, graph nhỏ\n\n---\n\n### 8. Ứng dụng thực tế\n\n#### 8.1. Network Routing\n\n```python\ndef find_shortest_route(network, source, destination):\n    \"\"\"\n    Tìm tuyến đường ngắn nhất trong mạng\n    network: weighted graph (router graph)\n    \"\"\"\n    distances, parent = dijkstra(network, source)\n    \n    if distances[destination] == float('inf'):\n        return None, \"No route available\"\n    \n    path = reconstruct_path(parent, source, destination)\n    return path, distances[destination]\n```\n\n#### 8.2. Map Navigation (GPS)\n\n```python\ndef gps_navigation(map_graph, start, end):\n    \"\"\"\n    Tìm đường đi ngắn nhất trên bản đồ\n    Có thể mở rộng với A* algorithm\n    \"\"\"\n    path, distance = dijkstra_with_path(map_graph, start, end)\n    \n    if path is None:\n        return \"No route found\"\n    \n    return {\n        'path': path,\n        'distance': distance,\n        'estimated_time': distance / 60  # Giả sử 60km/h\n    }\n```\n\n#### 8.3. Currency Arbitrage Detection\n\n```python\ndef detect_arbitrage(exchange_rates):\n    \"\"\"\n    Phát hiện cơ hội arbitrage trong tỷ giá\n    Sử dụng negative cycle detection\n    \n    Chuyển đổi: weight = -log(exchange_rate)\n    Negative cycle = arbitrage opportunity\n    \"\"\"\n    import math\n    \n    edges = []\n    for source, targets in exchange_rates.items():\n        for target, rate in targets.items():\n            # Chuyển multiplication thành addition\n            weight = -math.log(rate)\n            edges.append((source, target, weight))\n    \n    return detect_negative_cycle(edges)\n```\n\n#### 8.4. Network Delay Time\n\n```python\ndef network_delay_time(times, n, k):\n    \"\"\"\n    Thời gian để tín hiệu đến tất cả nodes\n    times: [[u, v, w]] - từ u đến v mất w thời gian\n    n: số nodes\n    k: node nguồn\n    \"\"\"\n    # Build graph\n    graph = {i: {} for i in range(1, n + 1)}\n    for u, v, w in times:\n        graph[u][v] = w\n    \n    # Dijkstra\n    distances, _ = dijkstra(graph, k)\n    \n    # Max distance = thời gian cần\n    max_dist = max(distances.values())\n    \n    return max_dist if max_dist != float('inf') else -1\n\n# Test\ntimes = [[2,1,1], [2,3,1], [3,4,1]]\nprint(f\"Network delay: {network_delay_time(times, 4, 2)}\")\n```\n\n#### 8.5. Cheapest Flights Within K Stops\n\n```python\ndef cheapest_flights_k_stops(n, flights, src, dst, k):\n    \"\"\"\n    Tìm chuyến bay rẻ nhất với tối đa k điểm dừng\n    Modified Bellman-Ford\n    \"\"\"\n    # prices[i] = chi phí rẻ nhất đến đỉnh i\n    prices = [float('inf')] * n\n    prices[src] = 0\n    \n    # Lặp k+1 lần (tối đa k stops)\n    for _ in range(k + 1):\n        temp_prices = prices.copy()\n        \n        for u, v, price in flights:\n            if prices[u] != float('inf'):\n                temp_prices[v] = min(temp_prices[v], prices[u] + price)\n        \n        prices = temp_prices\n    \n\n**Các khái niệm quan trọng:**\n- Network Routing là bài toán tìm tuyến đường tối ưu (thường là ngắn nhất hoặc chi phí thấp nhất) để truyền dữ liệu giữa các điểm trong một mạng lưới, thường được mô hình hóa bằng đồ thị có trọng số."
        },
        "output_without_context": {
            "question": "Trong bài toán đường đi ngắn nhất, thuật toán nào thường được sử dụng để tìm đường đi tối ưu trong đồ thị có trọng số không âm?",
            "answer": "Thuật toán Dijkstra"
        }
    },
    {
        "topic_description": "Chủ đề này giới thiệu phương pháp thư giãn cạnh trong việc xác định đường đi ngắn nhất, bao gồm công thức và ví dụ cụ thể. Học sinh sẽ được kiểm tra khả năng áp dụng công thức này trong các tình huống thực tế để cập nhật đường đi ngắn hơn.",
        "output_with_context": {
            "question": "Trong phương pháp thư giãn cạnh, công thức nào được sử dụng để cập nhật khoảng cách ngắn nhất từ đỉnh nguồn đến các đỉnh kề trong thuật toán Dijkstra?",
            "answer": "distance = current_dist + weight",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n    return prices[dst] if prices[dst] != float('inf') else -1\n\n# Test\nflights = [[0,1,100], [1,2,100], [0,2,500]]\nprint(f\"Cheapest: {cheapest_flights_k_stops(3, flights, 0, 2, 1)}\")\n```\n\n---\n\n### 9. Tối ưu hóa và Biến thể\n\n#### 9.1. A* Algorithm\n\nCải tiến Dijkstra với heuristic function:\n\n```python\ndef a_star(graph, start, goal, heuristic):\n    \"\"\"\n    A* algorithm - Dijkstra + heuristic\n    heuristic(node, goal) = ước lượng khoảng cách đến goal\n    \n    f(n) = g(n) + h(n)\n    g(n) = cost từ start đến n\n    h(n) = heuristic từ n đến goal\n    \"\"\"\n    import heapq\n    \n    open_set = [(0 + heuristic(start, goal), 0, start)]\n    came_from = {}\n    g_score = {start: 0}\n    \n    while open_set:\n        _, current_g, current = heapq.heappop(open_set)\n        \n        if current == goal:\n            # Reconstruct path\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1], g_score[goal]\n        \n        for neighbor, weight in graph[current].items():\n            tentative_g = current_g + weight\n            \n            if neighbor not in g_score or tentative_g < g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g\n                f_score = tentative_g + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score, tentative_g, neighbor))\n    \n    return None, float('inf')\n```\n\n#### 9.2. Bidirectional Dijkstra\n\nChạy Dijkstra từ cả 2 phía (start và end):\n\n```python\ndef bidirectional_dijkstra(graph, start, end):\n    \"\"\"\n    Dijkstra từ cả 2 phía\n    Nhanh hơn khi chỉ cần tìm 1 đường đi\n    \"\"\"\n    # Implement tương tự Dijkstra nhưng:\n    # - Chạy 2 searches song song\n    # - Dừng khi 2 searches gặp nhau\n    # - Kết hợp 2 paths\n    pass\n```\n\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n- Cheapest Flights with K Stops (Cheapest Flights Within K Stops) là bài toán tìm chuyến bay hoặc đường đi có chi phí thấp nhất từ một điểm xuất phát (đỉnh nguồn) đến một điểm đến (đỉnh đích), với giới hạn tối đa K điểm dừng (chặng dừng). Đây là một biến thể của bài toán đường đi ngắn nhất, thường được giải quyết bằng một phiên bản sửa đổi của thuật toán Bellman-Ford hoặc BFS với giới hạn số cạnh.\n\n**Mối quan hệ:**\n- Floyd-Warshall Algorithm giải quyết bài toán tìm đường đi ngắn nhất giữa tất cả các cặp đỉnh (All Pairs Shortest Path).\n- A* Algorithm giải quyết bài toán tìm đường đi ngắn nhất giữa hai đỉnh trong đồ thị.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n        # Đã xét rồi (vì có thể có nhiều entry trong heap)\n        if current in visited:\n            continue\n        \n        visited.add(current)\n        \n        # Không cần xét nếu distance đã lớn hơn\n        if current_dist > distances[current]:\n            continue\n        \n        # Relaxation\n        for neighbor, weight in graph[current].items():\n            distance = current_dist + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                parent[neighbor] = current\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances, parent\n\n# Test\nweighted_graph = {\n    'A': {'B': 4, 'C': 2},\n    'B': {'A': 4, 'C': 1, 'D': 5},\n    'C': {'A': 2, 'B': 1, 'D': 8, 'E': 10},\n    'D': {'B': 5, 'C': 8, 'E': 2, 'F': 6},\n    'E': {'C': 10, 'D': 2, 'F': 3},\n    'F': {'D': 6, 'E': 3}\n}\n\ndistances, parent = dijkstra(weighted_graph, 'A')\nprint(\"\nDijkstra from A:\")\nfor vertex in distances:\n    print(f\"A → {vertex}: {distances[vertex]}\")\n    path = reconstruct_path(parent, 'A', vertex)\n    print(f\"  Path: {' → '.join(path) if path else 'No path'}\")\n```\n\n**Minh họa từng bước:**\n```\nGraph:\n    A --4-- B --5-- D\n    |  \\    |  \\    |  \\\n    2   1   1   8   2   6\n    |    \\  |    \\  |    \\\n    C --8-- + --10- E --3-- F\n\nStep by step từ A:\n\nInitial: A=0, B=∞, C=∞, D=∞, E=∞, F=∞\n\n1. Chọn A (dist=0)\n   Relax: B=4, C=2\n   Heap: [(2,C), (4,B)]\n\n2. Chọn C (dist=2)\n   Relax: B=min(4,2+1)=3, D=10, E=12\n   Heap: [(3,B), (4,B), (10,D), (12,E)]\n\n3. Chọn B (dist=3)\n   Relax: D=min(10,3+5)=8\n   Heap: [(4,B), (8,D), (10,D), (12,E)]\n\n4. Chọn B (dist=4) - Skip (visited)\n\n5. Chọn D (dist=8)\n   Relax: E=min(12,8+2)=10, F=14\n   Heap: [(10,D), (10,E), (12,E), (14,F)]\n\n6. Chọn D (dist=10) - Skip\n\n7. Chọn E (dist=10)\n   Relax: F=min(14,10+3)=13\n   Heap: [(12,E), (13,F), (14,F)]\n\n8. Continue...\n\nFinal distances:\nA → A: 0\nA → B: 3 (A → C → B)\nA → C: 2 (A → C)\nA → D: 8 (A → C → B → D)\nA → E: 10 (A → C → B → D → E)\nA → F: 13 (A → C → B → D → E → F)\n```\n\n#### 4.3. Dijkstra với Path Reconstruction\n\n```python\ndef dijkstra_with_path(graph, start, end):\n    \"\"\"\n    Tìm đường đi ngắn nhất từ start đến end\n    \"\"\"\n    distances, parent = dijkstra(graph, start)\n    \n    if distances[end] == float('inf'):\n        return None, float('inf')\n    \n    path = reconstruct_path(parent, start, end)\n    return path, distances[end]\n\n# Test\npath, dist = dijkstra_with_path(weighted_graph, 'A', 'F')\nprint(f\"\nShortest path A → F: {' → '.join(path)}\")\nprint(f\"Distance: {dist}\")\n```\n\n---\n\n### 5. Bellman-Ford Algorithm\n\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n- Relaxation là một phép toán trong thuật toán Dijkstra (và Bellman-Ford) để cập nhật khoảng cách ngắn nhất đến một đỉnh kề. Nếu đường đi qua đỉnh hiện tại đến đỉnh kề ngắn hơn khoảng cách đã biết, thì khoảng cách của đỉnh kề sẽ được cập nhật và đỉnh kề được thêm vào hàng đợi ưu tiên.\n\n**Mối quan hệ:**\n- Floyd-Warshall Algorithm giải quyết bài toán tìm đường đi ngắn nhất giữa tất cả các cặp đỉnh (All Pairs Shortest Path).\n- A* Algorithm giải quyết bài toán tìm đường đi ngắn nhất giữa hai đỉnh trong đồ thị.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n**Floyd-Warshall** tìm đường đi ngắn nhất giữa **mọi cặp đỉnh**.\n\n**Dynamic Programming:**\n- `dp[k][i][j]` = shortest path từ i đến j qua các đỉnh {1, 2, ..., k}\n- `dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])`\n\n**Có thể tối ưu:** Dùng 2D array thay vì 3D\n\n#### 6.2. Cài đặt\n\n```python\ndef floyd_warshall(graph):\n    \"\"\"\n    Floyd-Warshall algorithm\n    Time: O(V³), Space: O(V²)\n    \n    graph: adjacency matrix (2D list)\n    graph[i][j] = weight of edge (i, j)\n    Use float('inf') for no edge\n    \"\"\"\n    n = len(graph)\n    \n    # Copy graph để không thay đổi input\n    dist = [row[:] for row in graph]\n    \n    # next[i][j] = đỉnh tiếp theo trên đường đi từ i đến j\n    next_vertex = [[None] * n for _ in range(n)]\n    \n    # Khởi tạo next_vertex\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] != float('inf') and i != j:\n                next_vertex[i][j] = j\n    \n    # Floyd-Warshall\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i][k] + dist[k][j] < dist[i][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n                    next_vertex[i][j] = next_vertex[i][k]\n    \n    return dist, next_vertex\n\ndef reconstruct_path_floyd(next_vertex, i, j):\n    \"\"\"Tái tạo đường đi từ i đến j\"\"\"\n    if next_vertex[i][j] is None:\n        return None\n    \n    path = [i]\n    while i != j:\n        i = next_vertex[i][j]\n        path.append(i)\n    \n    return path\n\n# Test\nINF = float('inf')\nadj_matrix = [\n    [0,   4,   2,   INF, INF, INF],  # A\n    [4,   0,   1,   5,   INF, INF],  # B\n    [2,   1,   0,   8,   10,  INF],  # C\n    [INF, 5,   8,   0,   2,   6],    # D\n    [INF, INF, 10,  2,   0,   3],    # E\n    [INF, INF, INF, 6,   3,   0]     # F\n]\n\ndist, next_v = floyd_warshall(adj_matrix)\n\nvertices = ['A', 'B', 'C', 'D', 'E', 'F']\nprint(\"\nFloyd-Warshall (All Pairs):\")\nprint(\"\nDistance Matrix:\")\nfor i in range(len(vertices)):\n    for j in range(len(vertices)):\n        if dist[i][j] == INF:\n            print(\"INF\", end=\"\t\")\n        else:\n            print(f\"{dist[i][j]}\", end=\"\t\")\n    print(f\"  ({vertices[i]})\")\n\n# Ví dụ một vài đường đi\nprint(\"\nSample paths:\")\nfor i in range(3):\n    for j in range(3, 6):\n        path = reconstruct_path_floyd(next_v, i, j)\n        if path:\n            path_str = ' → '.join(vertices[k] for k in path)\n            print(f\"{vertices[i]} → {vertices[j]}: {dist[i][j]} ({path_str})\")\n```\n\n---\n\n### 7. So sánh các thuật toán\n\n| Algorithm | Graph Type | Time | Space | Negative Weight | Negative Cycle |\n|-----------|-----------|------|-------|-----------------|----------------|\n| BFS | Unweighted | O(V+E) | O(V) | N/A | N/A |\n| Dijkstra | Non-negative weight | O((V+E)logV) | O(V) | ❌ | ❌ |\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n\n**Mối quan hệ:**\n- Floyd-Warshall Algorithm giải quyết bài toán tìm đường đi ngắn nhất giữa tất cả các cặp đỉnh (All Pairs Shortest Path).\n- A* Algorithm giải quyết bài toán tìm đường đi ngắn nhất giữa hai đỉnh trong đồ thị.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n#### 5.1. Ý tưởng\n\n**Bellman-Ford** tìm đường đi ngắn nhất từ nguồn trong **weighted graph có thể có trọng số âm**.\n\n**Khác với Dijkstra:**\n- ✅ Xử lý được trọng số âm\n- ✅ Phát hiện được negative cycle\n- ❌ Chậm hơn: O(VE) vs O((V+E) log V)\n\n**Thuật toán:**\n1. Khởi tạo distance nguồn = 0, còn lại = ∞\n2. Lặp (V-1) lần:\n   - Relax tất cả các cạnh\n3. Kiểm tra negative cycle (lặp lần thứ V)\n\n#### 5.2. Cài đặt\n\n```python\ndef bellman_ford(graph, start):\n    \"\"\"\n    Bellman-Ford algorithm\n    Time: O(VE), Space: O(V)\n    \n    graph: list of edges [(u, v, weight)]\n    Returns: (distances, parent, has_negative_cycle)\n    \"\"\"\n    # Lấy tất cả vertices\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    # Khởi tạo\n    distances = {v: float('inf') for v in vertices}\n    distances[start] = 0\n    parent = {v: None for v in vertices}\n    \n    # Relax tất cả edges (V-1) lần\n    for _ in range(len(vertices) - 1):\n        updated = False\n        \n        for u, v, weight in graph:\n            if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n                distances[v] = distances[u] + weight\n                parent[v] = u\n                updated = True\n        \n        # Early termination nếu không có update\n        if not updated:\n            break\n    \n    # Kiểm tra negative cycle\n    has_negative_cycle = False\n    for u, v, weight in graph:\n        if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n            has_negative_cycle = True\n            break\n    \n    return distances, parent, has_negative_cycle\n\n# Test\nedges = [\n    ('A', 'B', 4),\n    ('A', 'C', 2),\n    ('B', 'C', 1),\n    ('B', 'D', 5),\n    ('C', 'D', 8),\n    ('C', 'E', 10),\n    ('D', 'E', 2),\n    ('D', 'F', 6),\n    ('E', 'F', 3)\n]\n\ndistances, parent, has_neg_cycle = bellman_ford(edges, 'A')\nprint(\"\nBellman-Ford from A:\")\nprint(f\"Has negative cycle: {has_neg_cycle}\")\nfor vertex in sorted(distances.keys()):\n    print(f\"A → {vertex}: {distances[vertex]}\")\n```\n\n#### 5.3. Phát hiện Negative Cycle\n\n```python\ndef detect_negative_cycle(graph):\n    \"\"\"\n    Phát hiện negative cycle trong graph\n    \"\"\"\n    # Thử từ mỗi vertex (cho disconnected graph)\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    for start in vertices:\n        _, _, has_cycle = bellman_ford(graph, start)\n        if has_cycle:\n            return True\n    \n    return False\n\n# Test với negative cycle\nedges_with_cycle = [\n    ('A', 'B', 1),\n    ('B', 'C', -3),\n    ('C', 'A', 1)  # Cycle A→B→C→A có tổng = -1\n]\n\nprint(f\"\nHas negative cycle: {detect_negative_cycle(edges_with_cycle)}\")\n```\n\n**Minh họa Negative Cycle:**\n```\nGraph with negative cycle:\n    A --1-→ B\n    ↑       |\n    1       -3\n    |       ↓\n    +←------C\n\nCycle: A → B → C → A\nWeight: 1 + (-3) + 1 = -1 (negative!)\n\nMỗi lần đi qua cycle, distance giảm → không có shortest path\n```\n\n---\n\n### 6. Floyd-Warshall Algorithm (All Pairs)\n\n#### 6.1. Ý tưởng\n\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n\n**Mối quan hệ:**\n- Floyd-Warshall Algorithm giải quyết bài toán tìm đường đi ngắn nhất giữa tất cả các cặp đỉnh (All Pairs Shortest Path).\n- A* Algorithm giải quyết bài toán tìm đường đi ngắn nhất giữa hai đỉnh trong đồ thị."
        },
        "output_without_context": {
            "question": "Trong phương pháp thư giãn cạnh, công thức nào được sử dụng để xác định đường đi ngắn nhất giữa hai điểm trong đồ thị?",
            "answer": "Công thức Dijkstra."
        }
    },
    {
        "topic_description": "Chủ đề này tập trung vào thuật toán Dijkstra và cách nó được sử dụng để tìm đường đi ngắn nhất. Học sinh sẽ được kiểm tra khả năng mô tả cơ chế làm việc của thuật toán và cách thức áp dụng nó trong các nhiệm vụ thực tế.",
        "output_with_context": {
            "question": "Thuật toán Dijkstra được sử dụng để làm gì trong đồ thị có trọng số?",
            "answer": "Tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh khác.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n        # Đã xét rồi (vì có thể có nhiều entry trong heap)\n        if current in visited:\n            continue\n        \n        visited.add(current)\n        \n        # Không cần xét nếu distance đã lớn hơn\n        if current_dist > distances[current]:\n            continue\n        \n        # Relaxation\n        for neighbor, weight in graph[current].items():\n            distance = current_dist + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                parent[neighbor] = current\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances, parent\n\n# Test\nweighted_graph = {\n    'A': {'B': 4, 'C': 2},\n    'B': {'A': 4, 'C': 1, 'D': 5},\n    'C': {'A': 2, 'B': 1, 'D': 8, 'E': 10},\n    'D': {'B': 5, 'C': 8, 'E': 2, 'F': 6},\n    'E': {'C': 10, 'D': 2, 'F': 3},\n    'F': {'D': 6, 'E': 3}\n}\n\ndistances, parent = dijkstra(weighted_graph, 'A')\nprint(\"\nDijkstra from A:\")\nfor vertex in distances:\n    print(f\"A → {vertex}: {distances[vertex]}\")\n    path = reconstruct_path(parent, 'A', vertex)\n    print(f\"  Path: {' → '.join(path) if path else 'No path'}\")\n```\n\n**Minh họa từng bước:**\n```\nGraph:\n    A --4-- B --5-- D\n    |  \\    |  \\    |  \\\n    2   1   1   8   2   6\n    |    \\  |    \\  |    \\\n    C --8-- + --10- E --3-- F\n\nStep by step từ A:\n\nInitial: A=0, B=∞, C=∞, D=∞, E=∞, F=∞\n\n1. Chọn A (dist=0)\n   Relax: B=4, C=2\n   Heap: [(2,C), (4,B)]\n\n2. Chọn C (dist=2)\n   Relax: B=min(4,2+1)=3, D=10, E=12\n   Heap: [(3,B), (4,B), (10,D), (12,E)]\n\n3. Chọn B (dist=3)\n   Relax: D=min(10,3+5)=8\n   Heap: [(4,B), (8,D), (10,D), (12,E)]\n\n4. Chọn B (dist=4) - Skip (visited)\n\n5. Chọn D (dist=8)\n   Relax: E=min(12,8+2)=10, F=14\n   Heap: [(10,D), (10,E), (12,E), (14,F)]\n\n6. Chọn D (dist=10) - Skip\n\n7. Chọn E (dist=10)\n   Relax: F=min(14,10+3)=13\n   Heap: [(12,E), (13,F), (14,F)]\n\n8. Continue...\n\nFinal distances:\nA → A: 0\nA → B: 3 (A → C → B)\nA → C: 2 (A → C)\nA → D: 8 (A → C → B → D)\nA → E: 10 (A → C → B → D → E)\nA → F: 13 (A → C → B → D → E → F)\n```\n\n#### 4.3. Dijkstra với Path Reconstruction\n\n```python\ndef dijkstra_with_path(graph, start, end):\n    \"\"\"\n    Tìm đường đi ngắn nhất từ start đến end\n    \"\"\"\n    distances, parent = dijkstra(graph, start)\n    \n    if distances[end] == float('inf'):\n        return None, float('inf')\n    \n    path = reconstruct_path(parent, start, end)\n    return path, distances[end]\n\n# Test\npath, dist = dijkstra_with_path(weighted_graph, 'A', 'F')\nprint(f\"\nShortest path A → F: {' → '.join(path)}\")\nprint(f\"Distance: {dist}\")\n```\n\n---\n\n### 5. Bellman-Ford Algorithm\n\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n- Dijkstra là một thuật toán tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh khác trong một đồ thị có trọng số không âm. Trong Isomap, thuật toán Dijkstra được sử dụng để tính toán khoảng cách trắc địa (geodesic distances) giữa các điểm dữ liệu trên đồ thị lân cận, đại diện cho các đường đi ngắn nhất trên manifold.\n- Dijkstra là một thuật toán tham lam (Greedy) được sử dụng để tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh khác trong một đồ thị có trọng số không âm. Thuật toán này hoạt động bằng cách duy trì một tập hợp các đỉnh đã được thăm và sử dụng một hàng đợi ưu tiên (min-priority queue hoặc min-heap) để luôn chọn đỉnh có khoảng cách nhỏ nhất chưa được xét. Dijkstra không thể xử lý các cạnh có trọng số âm hoặc phát hiện chu trình âm. Độ phức tạp thời gian của Dijkstra thường là O(E log V) hoặc O(E + V log V) khi sử dụng min-priority queue (heap), hoặc O((V+E) log V) với binary heap. Độ phức tạp không gian là O(V) hoặc O(V + E) để lưu trữ đồ thị, khoảng cách và đỉnh cha.\n\nA* Algorithm là một thuật toán tìm kiếm đường đi và duyệt đồ thị, được cải tiến từ Dijkstra bằng cách sử dụng một hàm heuristic để ước lượng chi phí từ đỉnh hiện tại đến đỉnh đích. A* là một thuật toán tìm kiếm tốt nhất đầu tiên (best-first search) sử dụng hàng đợi ưu tiên để lưu trữ các node cần thăm, ưu tiên node có f(n) nhỏ nhất (f(n) = g(n) + h(n), với g(n) là chi phí thực tế và h(n) là chi phí ước lượng). A* hiệu quả hơn Dijkstra trong nhiều trường hợp vì nó có khả năng \"hướng dẫn\" tìm kiếm về phía đích, giúp tối ưu hóa việc tìm kiếm. Độ phức tạp thời gian của A* phụ thuộc vào chất lượng của hàm heuristic, trong trường hợp xấu nhất có thể tương tự Dijkstra (O(E log V) hoặc O(E) với Fibonacci heap), nhưng trong thực tế thường nhanh hơn nhiều.\n- dijkstra_with_path là một biến thể của thuật toán Dijkstra được thiết kế để không chỉ tìm khoảng cách ngắn nhất mà còn tái tạo lại đường đi ngắn nhất từ đỉnh nguồn đến một đỉnh đích cụ thể. Nó sử dụng kết quả từ hàm `dijkstra` (khoảng cách và đỉnh cha) để xây dựng lại đường đi.\n\n**Mối quan hệ:**\n- dijkstra_with_path sử dụng thuật toán Dijkstra để tính toán khoảng cách và đỉnh cha trước khi tái tạo đường đi.\n- Dijkstra's Algorithm giải quyết bài toán tìm đường đi ngắn nhất từ nguồn đến tất cả đỉnh.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n3. Duyệt các đỉnh kề, cập nhật khoảng cách\n4. Lặp lại cho đến khi queue rỗng\n\n#### 3.2. Cài đặt\n\n```python\nfrom collections import deque\n\ndef bfs_shortest_path(graph, start):\n    \"\"\"\n    Tìm đường đi ngắn nhất từ start đến tất cả đỉnh\n    Chỉ dùng cho unweighted graph\n    Time: O(V + E), Space: O(V)\n    \"\"\"\n    # Khởi tạo\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    parent = {vertex: None for vertex in graph}\n    \n    queue = deque([start])\n    \n    while queue:\n        current = queue.popleft()\n        \n        # Duyệt các đỉnh kề\n        for neighbor in graph[current]:\n            if distances[neighbor] == float('inf'):\n                distances[neighbor] = distances[current] + 1\n                parent[neighbor] = current\n                queue.append(neighbor)\n    \n    return distances, parent\n\ndef reconstruct_path(parent, start, end):\n    \"\"\"Tái tạo đường đi từ start đến end\"\"\"\n    if parent[end] is None and start != end:\n        return None  # Không có đường đi\n    \n    path = []\n    current = end\n    \n    while current is not None:\n        path.append(current)\n        current = parent[current]\n    \n    path.reverse()\n    return path\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\ndistances, parent = bfs_shortest_path(graph, 'A')\nprint(\"Distances from A:\", distances)\nprint(\"Path A to F:\", reconstruct_path(parent, 'A', 'F'))\n```\n\n**Minh họa:**\n```\nGraph:\n    A --- B --- D\n    |     |\n    C --- F --- E\n\nBFS từ A:\nLevel 0: A (distance = 0)\nLevel 1: B, C (distance = 1)\nLevel 2: D, E, F (distance = 2)\n\nShortest paths from A:\nA → B: 1\nA → C: 1\nA → D: 2 (A → B → D)\nA → E: 2 (A → B → E)\nA → F: 2 (A → C → F)\n```\n\n---\n\n### 4. Dijkstra's Algorithm\n\n#### 4.1. Ý tưởng\n\n**Dijkstra** tìm đường đi ngắn nhất từ nguồn đến tất cả đỉnh trong **weighted graph với trọng số không âm**.\n\n**Thuật toán (Greedy):**\n1. Khởi tạo khoảng cách nguồn = 0, còn lại = ∞\n2. Dùng min-heap (priority queue)\n3. Chọn đỉnh có khoảng cách nhỏ nhất chưa xét\n4. **Relaxation:** Cập nhật khoảng cách các đỉnh kề\n5. Lặp lại cho đến khi tất cả đỉnh được xét\n\n**Relaxation:**\n```\nif dist[u] + weight(u, v) < dist[v]:\n    dist[v] = dist[u] + weight(u, v)\n    parent[v] = u\n```\n\n#### 4.2. Cài đặt\n\n```python\nimport heapq\n\ndef dijkstra(graph, start):\n    \"\"\"\n    Dijkstra's algorithm cho weighted graph\n    Time: O((V + E) log V) với binary heap\n    Space: O(V)\n    \n    graph: dict of dict\n    graph[u][v] = weight of edge (u, v)\n    \"\"\"\n    # Khởi tạo\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    parent = {vertex: None for vertex in graph}\n    \n    # Min heap: (distance, vertex)\n    pq = [(0, start)]\n    visited = set()\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        \n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n\n**Mối quan hệ:**\n- Dijkstra's Algorithm giải quyết bài toán tìm đường đi ngắn nhất từ nguồn đến tất cả đỉnh.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n**Floyd-Warshall** tìm đường đi ngắn nhất giữa **mọi cặp đỉnh**.\n\n**Dynamic Programming:**\n- `dp[k][i][j]` = shortest path từ i đến j qua các đỉnh {1, 2, ..., k}\n- `dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])`\n\n**Có thể tối ưu:** Dùng 2D array thay vì 3D\n\n#### 6.2. Cài đặt\n\n```python\ndef floyd_warshall(graph):\n    \"\"\"\n    Floyd-Warshall algorithm\n    Time: O(V³), Space: O(V²)\n    \n    graph: adjacency matrix (2D list)\n    graph[i][j] = weight of edge (i, j)\n    Use float('inf') for no edge\n    \"\"\"\n    n = len(graph)\n    \n    # Copy graph để không thay đổi input\n    dist = [row[:] for row in graph]\n    \n    # next[i][j] = đỉnh tiếp theo trên đường đi từ i đến j\n    next_vertex = [[None] * n for _ in range(n)]\n    \n    # Khởi tạo next_vertex\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] != float('inf') and i != j:\n                next_vertex[i][j] = j\n    \n    # Floyd-Warshall\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i][k] + dist[k][j] < dist[i][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n                    next_vertex[i][j] = next_vertex[i][k]\n    \n    return dist, next_vertex\n\ndef reconstruct_path_floyd(next_vertex, i, j):\n    \"\"\"Tái tạo đường đi từ i đến j\"\"\"\n    if next_vertex[i][j] is None:\n        return None\n    \n    path = [i]\n    while i != j:\n        i = next_vertex[i][j]\n        path.append(i)\n    \n    return path\n\n# Test\nINF = float('inf')\nadj_matrix = [\n    [0,   4,   2,   INF, INF, INF],  # A\n    [4,   0,   1,   5,   INF, INF],  # B\n    [2,   1,   0,   8,   10,  INF],  # C\n    [INF, 5,   8,   0,   2,   6],    # D\n    [INF, INF, 10,  2,   0,   3],    # E\n    [INF, INF, INF, 6,   3,   0]     # F\n]\n\ndist, next_v = floyd_warshall(adj_matrix)\n\nvertices = ['A', 'B', 'C', 'D', 'E', 'F']\nprint(\"\nFloyd-Warshall (All Pairs):\")\nprint(\"\nDistance Matrix:\")\nfor i in range(len(vertices)):\n    for j in range(len(vertices)):\n        if dist[i][j] == INF:\n            print(\"INF\", end=\"\t\")\n        else:\n            print(f\"{dist[i][j]}\", end=\"\t\")\n    print(f\"  ({vertices[i]})\")\n\n# Ví dụ một vài đường đi\nprint(\"\nSample paths:\")\nfor i in range(3):\n    for j in range(3, 6):\n        path = reconstruct_path_floyd(next_v, i, j)\n        if path:\n            path_str = ' → '.join(vertices[k] for k in path)\n            print(f\"{vertices[i]} → {vertices[j]}: {dist[i][j]} ({path_str})\")\n```\n\n---\n\n### 7. So sánh các thuật toán\n\n| Algorithm | Graph Type | Time | Space | Negative Weight | Negative Cycle |\n|-----------|-----------|------|-------|-----------------|----------------|\n| BFS | Unweighted | O(V+E) | O(V) | N/A | N/A |\n| Dijkstra | Non-negative weight | O((V+E)logV) | O(V) | ❌ | ❌ |\n\n**Các khái niệm quan trọng:**\n- Dijkstra là một thuật toán tham lam (Greedy) được sử dụng để tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh khác trong một đồ thị có trọng số không âm. Thuật toán này hoạt động bằng cách duy trì một tập hợp các đỉnh đã được thăm và sử dụng một hàng đợi ưu tiên (min-priority queue hoặc min-heap) để luôn chọn đỉnh có khoảng cách nhỏ nhất chưa được xét. Dijkstra không thể xử lý các cạnh có trọng số âm hoặc phát hiện chu trình âm. Độ phức tạp thời gian của Dijkstra thường là O(E log V) hoặc O(E + V log V) khi sử dụng min-priority queue (heap), hoặc O((V+E) log V) với binary heap. Độ phức tạp không gian là O(V) hoặc O(V + E) để lưu trữ đồ thị, khoảng cách và đỉnh cha.\n\nA* Algorithm là một thuật toán tìm kiếm đường đi và duyệt đồ thị, được cải tiến từ Dijkstra bằng cách sử dụng một hàm heuristic để ước lượng chi phí từ đỉnh hiện tại đến đỉnh đích. A* là một thuật toán tìm kiếm tốt nhất đầu tiên (best-first search) sử dụng hàng đợi ưu tiên để lưu trữ các node cần thăm, ưu tiên node có f(n) nhỏ nhất (f(n) = g(n) + h(n), với g(n) là chi phí thực tế và h(n) là chi phí ước lượng). A* hiệu quả hơn Dijkstra trong nhiều trường hợp vì nó có khả năng \"hướng dẫn\" tìm kiếm về phía đích, giúp tối ưu hóa việc tìm kiếm. Độ phức tạp thời gian của A* phụ thuộc vào chất lượng của hàm heuristic, trong trường hợp xấu nhất có thể tương tự Dijkstra (O(E log V) hoặc O(E) với Fibonacci heap), nhưng trong thực tế thường nhanh hơn nhiều.\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n- Dijkstra là một thuật toán tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh khác trong một đồ thị có trọng số không âm. Trong Isomap, thuật toán Dijkstra được sử dụng để tính toán khoảng cách trắc địa (geodesic distances) giữa các điểm dữ liệu trên đồ thị lân cận, đại diện cho các đường đi ngắn nhất trên manifold.\n\n**Mối quan hệ:**\n- dijkstra_with_path sử dụng thuật toán Dijkstra để tính toán khoảng cách và đỉnh cha trước khi tái tạo đường đi.\n- Dijkstra's Algorithm giải quyết bài toán tìm đường đi ngắn nhất từ nguồn đến tất cả đỉnh.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n    return prices[dst] if prices[dst] != float('inf') else -1\n\n# Test\nflights = [[0,1,100], [1,2,100], [0,2,500]]\nprint(f\"Cheapest: {cheapest_flights_k_stops(3, flights, 0, 2, 1)}\")\n```\n\n---\n\n### 9. Tối ưu hóa và Biến thể\n\n#### 9.1. A* Algorithm\n\nCải tiến Dijkstra với heuristic function:\n\n```python\ndef a_star(graph, start, goal, heuristic):\n    \"\"\"\n    A* algorithm - Dijkstra + heuristic\n    heuristic(node, goal) = ước lượng khoảng cách đến goal\n    \n    f(n) = g(n) + h(n)\n    g(n) = cost từ start đến n\n    h(n) = heuristic từ n đến goal\n    \"\"\"\n    import heapq\n    \n    open_set = [(0 + heuristic(start, goal), 0, start)]\n    came_from = {}\n    g_score = {start: 0}\n    \n    while open_set:\n        _, current_g, current = heapq.heappop(open_set)\n        \n        if current == goal:\n            # Reconstruct path\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1], g_score[goal]\n        \n        for neighbor, weight in graph[current].items():\n            tentative_g = current_g + weight\n            \n            if neighbor not in g_score or tentative_g < g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g\n                f_score = tentative_g + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score, tentative_g, neighbor))\n    \n    return None, float('inf')\n```\n\n#### 9.2. Bidirectional Dijkstra\n\nChạy Dijkstra từ cả 2 phía (start và end):\n\n```python\ndef bidirectional_dijkstra(graph, start, end):\n    \"\"\"\n    Dijkstra từ cả 2 phía\n    Nhanh hơn khi chỉ cần tìm 1 đường đi\n    \"\"\"\n    # Implement tương tự Dijkstra nhưng:\n    # - Chạy 2 searches song song\n    # - Dừng khi 2 searches gặp nhau\n    # - Kết hợp 2 paths\n    pass\n```\n\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n\n**Mối quan hệ:**\n- Dijkstra's Algorithm giải quyết bài toán tìm đường đi ngắn nhất từ nguồn đến tất cả đỉnh.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n| Bellman-Ford | Any weight | O(VE) | O(V) | ✅ | Detect |\n| Floyd-Warshall | Any weight | O(V³) | O(V²) | ✅ | Detect |\n\n**Khi nào dùng:**\n- **BFS:** Unweighted graph, đơn giản nhất\n- **Dijkstra:** Weighted graph, không có cạnh âm, nhanh nhất\n- **Bellman-Ford:** Có cạnh âm, hoặc cần detect negative cycle\n- **Floyd-Warshall:** Cần tất cả cặp shortest paths, graph nhỏ\n\n---\n\n### 8. Ứng dụng thực tế\n\n#### 8.1. Network Routing\n\n```python\ndef find_shortest_route(network, source, destination):\n    \"\"\"\n    Tìm tuyến đường ngắn nhất trong mạng\n    network: weighted graph (router graph)\n    \"\"\"\n    distances, parent = dijkstra(network, source)\n    \n    if distances[destination] == float('inf'):\n        return None, \"No route available\"\n    \n    path = reconstruct_path(parent, source, destination)\n    return path, distances[destination]\n```\n\n#### 8.2. Map Navigation (GPS)\n\n```python\ndef gps_navigation(map_graph, start, end):\n    \"\"\"\n    Tìm đường đi ngắn nhất trên bản đồ\n    Có thể mở rộng với A* algorithm\n    \"\"\"\n    path, distance = dijkstra_with_path(map_graph, start, end)\n    \n    if path is None:\n        return \"No route found\"\n    \n    return {\n        'path': path,\n        'distance': distance,\n        'estimated_time': distance / 60  # Giả sử 60km/h\n    }\n```\n\n#### 8.3. Currency Arbitrage Detection\n\n```python\ndef detect_arbitrage(exchange_rates):\n    \"\"\"\n    Phát hiện cơ hội arbitrage trong tỷ giá\n    Sử dụng negative cycle detection\n    \n    Chuyển đổi: weight = -log(exchange_rate)\n    Negative cycle = arbitrage opportunity\n    \"\"\"\n    import math\n    \n    edges = []\n    for source, targets in exchange_rates.items():\n        for target, rate in targets.items():\n            # Chuyển multiplication thành addition\n            weight = -math.log(rate)\n            edges.append((source, target, weight))\n    \n    return detect_negative_cycle(edges)\n```\n\n#### 8.4. Network Delay Time\n\n```python\ndef network_delay_time(times, n, k):\n    \"\"\"\n    Thời gian để tín hiệu đến tất cả nodes\n    times: [[u, v, w]] - từ u đến v mất w thời gian\n    n: số nodes\n    k: node nguồn\n    \"\"\"\n    # Build graph\n    graph = {i: {} for i in range(1, n + 1)}\n    for u, v, w in times:\n        graph[u][v] = w\n    \n    # Dijkstra\n    distances, _ = dijkstra(graph, k)\n    \n    # Max distance = thời gian cần\n    max_dist = max(distances.values())\n    \n    return max_dist if max_dist != float('inf') else -1\n\n# Test\ntimes = [[2,1,1], [2,3,1], [3,4,1]]\nprint(f\"Network delay: {network_delay_time(times, 4, 2)}\")\n```\n\n#### 8.5. Cheapest Flights Within K Stops\n\n```python\ndef cheapest_flights_k_stops(n, flights, src, dst, k):\n    \"\"\"\n    Tìm chuyến bay rẻ nhất với tối đa k điểm dừng\n    Modified Bellman-Ford\n    \"\"\"\n    # prices[i] = chi phí rẻ nhất đến đỉnh i\n    prices = [float('inf')] * n\n    prices[src] = 0\n    \n    # Lặp k+1 lần (tối đa k stops)\n    for _ in range(k + 1):\n        temp_prices = prices.copy()\n        \n        for u, v, price in flights:\n            if prices[u] != float('inf'):\n                temp_prices[v] = min(temp_prices[v], prices[u] + price)\n        \n        prices = temp_prices\n    \n\n**Các khái niệm quan trọng:**\n- Dijkstra là một thuật toán tham lam (Greedy) được sử dụng để tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh khác trong một đồ thị có trọng số không âm. Thuật toán này hoạt động bằng cách duy trì một tập hợp các đỉnh đã được thăm và sử dụng một hàng đợi ưu tiên (min-priority queue hoặc min-heap) để luôn chọn đỉnh có khoảng cách nhỏ nhất chưa được xét. Dijkstra không thể xử lý các cạnh có trọng số âm hoặc phát hiện chu trình âm. Độ phức tạp thời gian của Dijkstra thường là O(E log V) hoặc O(E + V log V) khi sử dụng min-priority queue (heap), hoặc O((V+E) log V) với binary heap. Độ phức tạp không gian là O(V) hoặc O(V + E) để lưu trữ đồ thị, khoảng cách và đỉnh cha.\n\nA* Algorithm là một thuật toán tìm kiếm đường đi và duyệt đồ thị, được cải tiến từ Dijkstra bằng cách sử dụng một hàm heuristic để ước lượng chi phí từ đỉnh hiện tại đến đỉnh đích. A* là một thuật toán tìm kiếm tốt nhất đầu tiên (best-first search) sử dụng hàng đợi ưu tiên để lưu trữ các node cần thăm, ưu tiên node có f(n) nhỏ nhất (f(n) = g(n) + h(n), với g(n) là chi phí thực tế và h(n) là chi phí ước lượng). A* hiệu quả hơn Dijkstra trong nhiều trường hợp vì nó có khả năng \"hướng dẫn\" tìm kiếm về phía đích, giúp tối ưu hóa việc tìm kiếm. Độ phức tạp thời gian của A* phụ thuộc vào chất lượng của hàm heuristic, trong trường hợp xấu nhất có thể tương tự Dijkstra (O(E log V) hoặc O(E) với Fibonacci heap), nhưng trong thực tế thường nhanh hơn nhiều.\n\n**Mối quan hệ:**\n- dijkstra_with_path sử dụng thuật toán Dijkstra để tính toán khoảng cách và đỉnh cha trước khi tái tạo đường đi."
        },
        "output_without_context": {
            "question": "Thuật toán Dijkstra được sử dụng để tìm kiếm điều gì trong một đồ thị có trọng số?",
            "answer": "Đường đi ngắn nhất từ một đỉnh đến tất cả các đỉnh còn lại."
        }
    },
    {
        "topic_description": "Chủ đề này đánh giá hiểu biết của học sinh về API đồ thị có trọng số. Học sinh sẽ được kiểm tra khả năng xác định các phương thức cần thiết và ứng dụng thực tế của API trong việc quản lý đồ thị có trọng số.",
        "output_with_context": {
            "question": "Đồ thị có trọng số được định nghĩa là gì trong cấu trúc dữ liệu và giải thuật?",
            "answer": "Đồ thị có trọng số là một cấu trúc dữ liệu đồ thị trong đó mỗi cạnh được gán một giá trị số, gọi là trọng số.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n\n### 1. Giới thiệu về Graph (Đồ thị)\n\n#### 1.1. Khái niệm cơ bản\n\n**Graph (Đồ thị)** là một cấu trúc dữ liệu bao gồm:\n- **Vertices (V):** Tập các đỉnh (nodes)\n- **Edges (E):** Tập các cạnh kết nối các đỉnh\n\n**Ký hiệu:** G = (V, E)\n\n**Các loại graph:**\n\n**a) Directed vs Undirected:**\n```\nUndirected:           Directed (Digraph):\n    A --- B               A → B\n    |     |               ↓   ↓\n    C --- D               C → D\n```\n\n**b) Weighted vs Unweighted:**\n```\nUnweighted:           Weighted:\n    A --- B               A --5-- B\n    |     |               |       |\n    C --- D               3       7\n                          |       |\n                          C --2-- D\n```\n\n**c) Connected vs Disconnected:**\n```\nConnected:            Disconnected:\n    A --- B               A --- B    E --- F\n    |     |                          \n    C --- D               C --- D    \n```\n\n#### 1.2. Biểu diễn Graph\n\n**a) Adjacency Matrix (Ma trận kề):**\n```python\n# Không gian: O(V²)\ngraph = [\n    [0, 1, 1, 0],  # A kết nối với B, C\n    [1, 0, 0, 1],  # B kết nối với A, D\n    [1, 0, 0, 1],  # C kết nối với A, D\n    [0, 1, 1, 0]   # D kết nối với B, C\n]\n```\n\n**b) Adjacency List (Danh sách kề):**\n```python\n# Không gian: O(V + E)\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D'],\n    'C': ['A', 'D'],\n    'D': ['B', 'C']\n}\n\n# Weighted graph\nweighted_graph = {\n    'A': [('B', 5), ('C', 3)],\n    'B': [('A', 5), ('D', 7)],\n    'C': [('A', 3), ('D', 2)],\n    'D': [('B', 7), ('C', 2)]\n}\n```\n\n**So sánh:**\n\n| Đặc điểm | Adjacency Matrix | Adjacency List |\n|----------|------------------|----------------|\n| Space | O(V²) | O(V + E) |\n| Check edge (u,v) | O(1) | O(degree(u)) |\n| Iterate neighbors | O(V) | O(degree(u)) |\n| Add vertex | O(V²) | O(1) |\n| Add edge | O(1) | O(1) |\n\n---\n\n### 2. Bài toán Shortest Path (Đường đi ngắn nhất)\n\n**Phân loại:**\n\n1. **Single Source Shortest Path (SSSP):**\n   - Từ 1 đỉnh nguồn đến tất cả đỉnh khác\n   - Algorithms: BFS, Dijkstra, Bellman-Ford\n\n2. **All Pairs Shortest Path (APSP):**\n   - Giữa mọi cặp đỉnh\n   - Algorithm: Floyd-Warshall\n\n**Đặc điểm:**\n- **Unweighted:** BFS\n- **Non-negative weights:** Dijkstra\n- **Negative weights:** Bellman-Ford\n- **Negative cycles:** Bellman-Ford (detect)\n\n---\n\n### 3. BFS (Breadth-First Search) - Unweighted\n\n#### 3.1. Ý tưởng\n\nBFS tìm đường đi ngắn nhất trong **unweighted graph** bằng cách duyệt theo từng level.\n\n**Thuật toán:**\n1. Dùng queue, bắt đầu từ đỉnh nguồn\n2. Đánh dấu khoảng cách từ nguồn = 0\n\n**Các khái niệm quan trọng:**\n- Unweighted Graph (Đồ thị không trọng số) là một cấu trúc dữ liệu đồ thị trong đó các cạnh không có trọng số gán kèm, hoặc tất cả các cạnh được coi là có trọng số bằng nhau (thường là 1). Trong loại đồ thị này, độ dài của một đường đi được tính bằng số lượng cạnh trên đường đi đó, và thuật toán BFS là một phương pháp hiệu quả để tìm đường đi ngắn nhất.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n| Bellman-Ford | Any weight | O(VE) | O(V) | ✅ | Detect |\n| Floyd-Warshall | Any weight | O(V³) | O(V²) | ✅ | Detect |\n\n**Khi nào dùng:**\n- **BFS:** Unweighted graph, đơn giản nhất\n- **Dijkstra:** Weighted graph, không có cạnh âm, nhanh nhất\n- **Bellman-Ford:** Có cạnh âm, hoặc cần detect negative cycle\n- **Floyd-Warshall:** Cần tất cả cặp shortest paths, graph nhỏ\n\n---\n\n### 8. Ứng dụng thực tế\n\n#### 8.1. Network Routing\n\n```python\ndef find_shortest_route(network, source, destination):\n    \"\"\"\n    Tìm tuyến đường ngắn nhất trong mạng\n    network: weighted graph (router graph)\n    \"\"\"\n    distances, parent = dijkstra(network, source)\n    \n    if distances[destination] == float('inf'):\n        return None, \"No route available\"\n    \n    path = reconstruct_path(parent, source, destination)\n    return path, distances[destination]\n```\n\n#### 8.2. Map Navigation (GPS)\n\n```python\ndef gps_navigation(map_graph, start, end):\n    \"\"\"\n    Tìm đường đi ngắn nhất trên bản đồ\n    Có thể mở rộng với A* algorithm\n    \"\"\"\n    path, distance = dijkstra_with_path(map_graph, start, end)\n    \n    if path is None:\n        return \"No route found\"\n    \n    return {\n        'path': path,\n        'distance': distance,\n        'estimated_time': distance / 60  # Giả sử 60km/h\n    }\n```\n\n#### 8.3. Currency Arbitrage Detection\n\n```python\ndef detect_arbitrage(exchange_rates):\n    \"\"\"\n    Phát hiện cơ hội arbitrage trong tỷ giá\n    Sử dụng negative cycle detection\n    \n    Chuyển đổi: weight = -log(exchange_rate)\n    Negative cycle = arbitrage opportunity\n    \"\"\"\n    import math\n    \n    edges = []\n    for source, targets in exchange_rates.items():\n        for target, rate in targets.items():\n            # Chuyển multiplication thành addition\n            weight = -math.log(rate)\n            edges.append((source, target, weight))\n    \n    return detect_negative_cycle(edges)\n```\n\n#### 8.4. Network Delay Time\n\n```python\ndef network_delay_time(times, n, k):\n    \"\"\"\n    Thời gian để tín hiệu đến tất cả nodes\n    times: [[u, v, w]] - từ u đến v mất w thời gian\n    n: số nodes\n    k: node nguồn\n    \"\"\"\n    # Build graph\n    graph = {i: {} for i in range(1, n + 1)}\n    for u, v, w in times:\n        graph[u][v] = w\n    \n    # Dijkstra\n    distances, _ = dijkstra(graph, k)\n    \n    # Max distance = thời gian cần\n    max_dist = max(distances.values())\n    \n    return max_dist if max_dist != float('inf') else -1\n\n# Test\ntimes = [[2,1,1], [2,3,1], [3,4,1]]\nprint(f\"Network delay: {network_delay_time(times, 4, 2)}\")\n```\n\n#### 8.5. Cheapest Flights Within K Stops\n\n```python\ndef cheapest_flights_k_stops(n, flights, src, dst, k):\n    \"\"\"\n    Tìm chuyến bay rẻ nhất với tối đa k điểm dừng\n    Modified Bellman-Ford\n    \"\"\"\n    # prices[i] = chi phí rẻ nhất đến đỉnh i\n    prices = [float('inf')] * n\n    prices[src] = 0\n    \n    # Lặp k+1 lần (tối đa k stops)\n    for _ in range(k + 1):\n        temp_prices = prices.copy()\n        \n        for u, v, price in flights:\n            if prices[u] != float('inf'):\n                temp_prices[v] = min(temp_prices[v], prices[u] + price)\n        \n        prices = temp_prices\n    \n\n**Các khái niệm quan trọng:**\n- Unweighted Graph (Đồ thị không trọng số) là một cấu trúc dữ liệu đồ thị trong đó các cạnh không có trọng số gán kèm, hoặc tất cả các cạnh được coi là có trọng số bằng nhau (thường là 1). Trong loại đồ thị này, độ dài của một đường đi được tính bằng số lượng cạnh trên đường đi đó, và thuật toán BFS là một phương pháp hiệu quả để tìm đường đi ngắn nhất.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n**Floyd-Warshall** tìm đường đi ngắn nhất giữa **mọi cặp đỉnh**.\n\n**Dynamic Programming:**\n- `dp[k][i][j]` = shortest path từ i đến j qua các đỉnh {1, 2, ..., k}\n- `dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])`\n\n**Có thể tối ưu:** Dùng 2D array thay vì 3D\n\n#### 6.2. Cài đặt\n\n```python\ndef floyd_warshall(graph):\n    \"\"\"\n    Floyd-Warshall algorithm\n    Time: O(V³), Space: O(V²)\n    \n    graph: adjacency matrix (2D list)\n    graph[i][j] = weight of edge (i, j)\n    Use float('inf') for no edge\n    \"\"\"\n    n = len(graph)\n    \n    # Copy graph để không thay đổi input\n    dist = [row[:] for row in graph]\n    \n    # next[i][j] = đỉnh tiếp theo trên đường đi từ i đến j\n    next_vertex = [[None] * n for _ in range(n)]\n    \n    # Khởi tạo next_vertex\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] != float('inf') and i != j:\n                next_vertex[i][j] = j\n    \n    # Floyd-Warshall\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i][k] + dist[k][j] < dist[i][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n                    next_vertex[i][j] = next_vertex[i][k]\n    \n    return dist, next_vertex\n\ndef reconstruct_path_floyd(next_vertex, i, j):\n    \"\"\"Tái tạo đường đi từ i đến j\"\"\"\n    if next_vertex[i][j] is None:\n        return None\n    \n    path = [i]\n    while i != j:\n        i = next_vertex[i][j]\n        path.append(i)\n    \n    return path\n\n# Test\nINF = float('inf')\nadj_matrix = [\n    [0,   4,   2,   INF, INF, INF],  # A\n    [4,   0,   1,   5,   INF, INF],  # B\n    [2,   1,   0,   8,   10,  INF],  # C\n    [INF, 5,   8,   0,   2,   6],    # D\n    [INF, INF, 10,  2,   0,   3],    # E\n    [INF, INF, INF, 6,   3,   0]     # F\n]\n\ndist, next_v = floyd_warshall(adj_matrix)\n\nvertices = ['A', 'B', 'C', 'D', 'E', 'F']\nprint(\"\nFloyd-Warshall (All Pairs):\")\nprint(\"\nDistance Matrix:\")\nfor i in range(len(vertices)):\n    for j in range(len(vertices)):\n        if dist[i][j] == INF:\n            print(\"INF\", end=\"\t\")\n        else:\n            print(f\"{dist[i][j]}\", end=\"\t\")\n    print(f\"  ({vertices[i]})\")\n\n# Ví dụ một vài đường đi\nprint(\"\nSample paths:\")\nfor i in range(3):\n    for j in range(3, 6):\n        path = reconstruct_path_floyd(next_v, i, j)\n        if path:\n            path_str = ' → '.join(vertices[k] for k in path)\n            print(f\"{vertices[i]} → {vertices[j]}: {dist[i][j]} ({path_str})\")\n```\n\n---\n\n### 7. So sánh các thuật toán\n\n| Algorithm | Graph Type | Time | Space | Negative Weight | Negative Cycle |\n|-----------|-----------|------|-------|-----------------|----------------|\n| BFS | Unweighted | O(V+E) | O(V) | N/A | N/A |\n| Dijkstra | Non-negative weight | O((V+E)logV) | O(V) | ❌ | ❌ |\n\n**Các khái niệm quan trọng:**\n- Non-negative weights (trọng số không âm) là điều kiện mà tất cả các cạnh trong đồ thị phải có trọng số lớn hơn hoặc bằng 0. Điều kiện này là bắt buộc đối với thuật toán Dijkstra để đảm bảo tính đúng đắn của nó trong việc tìm đường đi ngắn nhất. Nếu đồ thị chứa các cạnh có trọng số âm (negative weights), thuật toán Dijkstra có thể không tìm được đường đi ngắn nhất chính xác; trong trường hợp này, các thuật toán khác như Bellman-Ford là phù hợp hơn.\n- Unweighted Graph (Đồ thị không trọng số) là một cấu trúc dữ liệu đồ thị trong đó các cạnh không có trọng số gán kèm, hoặc tất cả các cạnh được coi là có trọng số bằng nhau (thường là 1). Trong loại đồ thị này, độ dài của một đường đi được tính bằng số lượng cạnh trên đường đi đó, và thuật toán BFS là một phương pháp hiệu quả để tìm đường đi ngắn nhất.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n#### 5.1. Ý tưởng\n\n**Bellman-Ford** tìm đường đi ngắn nhất từ nguồn trong **weighted graph có thể có trọng số âm**.\n\n**Khác với Dijkstra:**\n- ✅ Xử lý được trọng số âm\n- ✅ Phát hiện được negative cycle\n- ❌ Chậm hơn: O(VE) vs O((V+E) log V)\n\n**Thuật toán:**\n1. Khởi tạo distance nguồn = 0, còn lại = ∞\n2. Lặp (V-1) lần:\n   - Relax tất cả các cạnh\n3. Kiểm tra negative cycle (lặp lần thứ V)\n\n#### 5.2. Cài đặt\n\n```python\ndef bellman_ford(graph, start):\n    \"\"\"\n    Bellman-Ford algorithm\n    Time: O(VE), Space: O(V)\n    \n    graph: list of edges [(u, v, weight)]\n    Returns: (distances, parent, has_negative_cycle)\n    \"\"\"\n    # Lấy tất cả vertices\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    # Khởi tạo\n    distances = {v: float('inf') for v in vertices}\n    distances[start] = 0\n    parent = {v: None for v in vertices}\n    \n    # Relax tất cả edges (V-1) lần\n    for _ in range(len(vertices) - 1):\n        updated = False\n        \n        for u, v, weight in graph:\n            if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n                distances[v] = distances[u] + weight\n                parent[v] = u\n                updated = True\n        \n        # Early termination nếu không có update\n        if not updated:\n            break\n    \n    # Kiểm tra negative cycle\n    has_negative_cycle = False\n    for u, v, weight in graph:\n        if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n            has_negative_cycle = True\n            break\n    \n    return distances, parent, has_negative_cycle\n\n# Test\nedges = [\n    ('A', 'B', 4),\n    ('A', 'C', 2),\n    ('B', 'C', 1),\n    ('B', 'D', 5),\n    ('C', 'D', 8),\n    ('C', 'E', 10),\n    ('D', 'E', 2),\n    ('D', 'F', 6),\n    ('E', 'F', 3)\n]\n\ndistances, parent, has_neg_cycle = bellman_ford(edges, 'A')\nprint(\"\nBellman-Ford from A:\")\nprint(f\"Has negative cycle: {has_neg_cycle}\")\nfor vertex in sorted(distances.keys()):\n    print(f\"A → {vertex}: {distances[vertex]}\")\n```\n\n#### 5.3. Phát hiện Negative Cycle\n\n```python\ndef detect_negative_cycle(graph):\n    \"\"\"\n    Phát hiện negative cycle trong graph\n    \"\"\"\n    # Thử từ mỗi vertex (cho disconnected graph)\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    for start in vertices:\n        _, _, has_cycle = bellman_ford(graph, start)\n        if has_cycle:\n            return True\n    \n    return False\n\n# Test với negative cycle\nedges_with_cycle = [\n    ('A', 'B', 1),\n    ('B', 'C', -3),\n    ('C', 'A', 1)  # Cycle A→B→C→A có tổng = -1\n]\n\nprint(f\"\nHas negative cycle: {detect_negative_cycle(edges_with_cycle)}\")\n```\n\n**Minh họa Negative Cycle:**\n```\nGraph with negative cycle:\n    A --1-→ B\n    ↑       |\n    1       -3\n    |       ↓\n    +←------C\n\nCycle: A → B → C → A\nWeight: 1 + (-3) + 1 = -1 (negative!)\n\nMỗi lần đi qua cycle, distance giảm → không có shortest path\n```\n\n---\n\n### 6. Floyd-Warshall Algorithm (All Pairs)\n\n#### 6.1. Ý tưởng\n\n\n**Các khái niệm quan trọng:**\n- Graph Algorithms (Thuật toán đồ thị) là một lĩnh vực trong khoa học máy tính tập trung vào việc nghiên cứu và giải quyết các bài toán trên cấu trúc dữ liệu đồ thị. Các bài toán phổ biến bao gồm tìm đường đi ngắn nhất, tìm kiếm theo chiều sâu/rộng (duyệt đồ thị), tìm cây bao trùm tối thiểu/nhỏ nhất, v.v.\n- Weighted Graph (Đồ thị có trọng số) là một cấu trúc dữ liệu đồ thị trong đó mỗi cạnh được gán một giá trị số, gọi là trọng số. Trọng số này biểu thị chi phí, khoảng cách, thời gian, hoặc bất kỳ đại lượng nào khác liên quan đến việc đi qua cạnh đó. Đồ thị có thể có trọng số dương hoặc âm. Các thuật toán tìm đường đi ngắn nhất như Bellman-Ford và Dijkstra được thiết kế để hoạt động trên loại đồ thị này.\n\n**Mối quan hệ:**\n- Dijkstra's Algorithm được thiết kế cho weighted graph.\n- Bellman-Ford sử dụng cấu trúc dữ liệu weighted graph làm đầu vào để tìm đường đi ngắn nhất.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n3. Duyệt các đỉnh kề, cập nhật khoảng cách\n4. Lặp lại cho đến khi queue rỗng\n\n#### 3.2. Cài đặt\n\n```python\nfrom collections import deque\n\ndef bfs_shortest_path(graph, start):\n    \"\"\"\n    Tìm đường đi ngắn nhất từ start đến tất cả đỉnh\n    Chỉ dùng cho unweighted graph\n    Time: O(V + E), Space: O(V)\n    \"\"\"\n    # Khởi tạo\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    parent = {vertex: None for vertex in graph}\n    \n    queue = deque([start])\n    \n    while queue:\n        current = queue.popleft()\n        \n        # Duyệt các đỉnh kề\n        for neighbor in graph[current]:\n            if distances[neighbor] == float('inf'):\n                distances[neighbor] = distances[current] + 1\n                parent[neighbor] = current\n                queue.append(neighbor)\n    \n    return distances, parent\n\ndef reconstruct_path(parent, start, end):\n    \"\"\"Tái tạo đường đi từ start đến end\"\"\"\n    if parent[end] is None and start != end:\n        return None  # Không có đường đi\n    \n    path = []\n    current = end\n    \n    while current is not None:\n        path.append(current)\n        current = parent[current]\n    \n    path.reverse()\n    return path\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\ndistances, parent = bfs_shortest_path(graph, 'A')\nprint(\"Distances from A:\", distances)\nprint(\"Path A to F:\", reconstruct_path(parent, 'A', 'F'))\n```\n\n**Minh họa:**\n```\nGraph:\n    A --- B --- D\n    |     |\n    C --- F --- E\n\nBFS từ A:\nLevel 0: A (distance = 0)\nLevel 1: B, C (distance = 1)\nLevel 2: D, E, F (distance = 2)\n\nShortest paths from A:\nA → B: 1\nA → C: 1\nA → D: 2 (A → B → D)\nA → E: 2 (A → B → E)\nA → F: 2 (A → C → F)\n```\n\n---\n\n### 4. Dijkstra's Algorithm\n\n#### 4.1. Ý tưởng\n\n**Dijkstra** tìm đường đi ngắn nhất từ nguồn đến tất cả đỉnh trong **weighted graph với trọng số không âm**.\n\n**Thuật toán (Greedy):**\n1. Khởi tạo khoảng cách nguồn = 0, còn lại = ∞\n2. Dùng min-heap (priority queue)\n3. Chọn đỉnh có khoảng cách nhỏ nhất chưa xét\n4. **Relaxation:** Cập nhật khoảng cách các đỉnh kề\n5. Lặp lại cho đến khi tất cả đỉnh được xét\n\n**Relaxation:**\n```\nif dist[u] + weight(u, v) < dist[v]:\n    dist[v] = dist[u] + weight(u, v)\n    parent[v] = u\n```\n\n#### 4.2. Cài đặt\n\n```python\nimport heapq\n\ndef dijkstra(graph, start):\n    \"\"\"\n    Dijkstra's algorithm cho weighted graph\n    Time: O((V + E) log V) với binary heap\n    Space: O(V)\n    \n    graph: dict of dict\n    graph[u][v] = weight of edge (u, v)\n    \"\"\"\n    # Khởi tạo\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    parent = {vertex: None for vertex in graph}\n    \n    # Min heap: (distance, vertex)\n    pq = [(0, start)]\n    visited = set()\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        \n\n**Các khái niệm quan trọng:**\n- Graph Algorithms (Thuật toán đồ thị) là một lĩnh vực trong khoa học máy tính tập trung vào việc nghiên cứu và giải quyết các bài toán trên cấu trúc dữ liệu đồ thị. Các bài toán phổ biến bao gồm tìm đường đi ngắn nhất, tìm kiếm theo chiều sâu/rộng (duyệt đồ thị), tìm cây bao trùm tối thiểu/nhỏ nhất, v.v.\n- Weighted Graph (Đồ thị có trọng số) là một cấu trúc dữ liệu đồ thị trong đó mỗi cạnh được gán một giá trị số, gọi là trọng số. Trọng số này biểu thị chi phí, khoảng cách, thời gian, hoặc bất kỳ đại lượng nào khác liên quan đến việc đi qua cạnh đó. Đồ thị có thể có trọng số dương hoặc âm. Các thuật toán tìm đường đi ngắn nhất như Bellman-Ford và Dijkstra được thiết kế để hoạt động trên loại đồ thị này.\n\n**Mối quan hệ:**\n- Dijkstra's Algorithm được thiết kế cho weighted graph.\n- Bellman-Ford sử dụng cấu trúc dữ liệu weighted graph làm đầu vào để tìm đường đi ngắn nhất."
        },
        "output_without_context": {
            "question": "API đồ thị có trọng số thường được sử dụng để làm gì trong quản lý đồ thị?",
            "answer": "Quản lý và xử lý các đỉnh và cạnh có trọng số trong đồ thị."
        }
    },
    {
        "topic_description": "Chủ đề này phân tích sự khác biệt giữa hai thuật toán Dijkstra và Bellman-Ford trong việc tìm đường đi ngắn nhất, bao gồm các trường hợp sử dụng cụ thể của chúng. Học sinh sẽ được kiểm tra khả năng so sánh và phân tích ưu nhược điểm của hai thuật toán này.",
        "output_with_context": {
            "question": "So sánh thuật toán Dijkstra và Bellman-Ford, thuật toán nào có khả năng phát hiện chu trình âm trong đồ thị?",
            "answer": "Bellman-Ford",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n| Bellman-Ford | Any weight | O(VE) | O(V) | ✅ | Detect |\n| Floyd-Warshall | Any weight | O(V³) | O(V²) | ✅ | Detect |\n\n**Khi nào dùng:**\n- **BFS:** Unweighted graph, đơn giản nhất\n- **Dijkstra:** Weighted graph, không có cạnh âm, nhanh nhất\n- **Bellman-Ford:** Có cạnh âm, hoặc cần detect negative cycle\n- **Floyd-Warshall:** Cần tất cả cặp shortest paths, graph nhỏ\n\n---\n\n### 8. Ứng dụng thực tế\n\n#### 8.1. Network Routing\n\n```python\ndef find_shortest_route(network, source, destination):\n    \"\"\"\n    Tìm tuyến đường ngắn nhất trong mạng\n    network: weighted graph (router graph)\n    \"\"\"\n    distances, parent = dijkstra(network, source)\n    \n    if distances[destination] == float('inf'):\n        return None, \"No route available\"\n    \n    path = reconstruct_path(parent, source, destination)\n    return path, distances[destination]\n```\n\n#### 8.2. Map Navigation (GPS)\n\n```python\ndef gps_navigation(map_graph, start, end):\n    \"\"\"\n    Tìm đường đi ngắn nhất trên bản đồ\n    Có thể mở rộng với A* algorithm\n    \"\"\"\n    path, distance = dijkstra_with_path(map_graph, start, end)\n    \n    if path is None:\n        return \"No route found\"\n    \n    return {\n        'path': path,\n        'distance': distance,\n        'estimated_time': distance / 60  # Giả sử 60km/h\n    }\n```\n\n#### 8.3. Currency Arbitrage Detection\n\n```python\ndef detect_arbitrage(exchange_rates):\n    \"\"\"\n    Phát hiện cơ hội arbitrage trong tỷ giá\n    Sử dụng negative cycle detection\n    \n    Chuyển đổi: weight = -log(exchange_rate)\n    Negative cycle = arbitrage opportunity\n    \"\"\"\n    import math\n    \n    edges = []\n    for source, targets in exchange_rates.items():\n        for target, rate in targets.items():\n            # Chuyển multiplication thành addition\n            weight = -math.log(rate)\n            edges.append((source, target, weight))\n    \n    return detect_negative_cycle(edges)\n```\n\n#### 8.4. Network Delay Time\n\n```python\ndef network_delay_time(times, n, k):\n    \"\"\"\n    Thời gian để tín hiệu đến tất cả nodes\n    times: [[u, v, w]] - từ u đến v mất w thời gian\n    n: số nodes\n    k: node nguồn\n    \"\"\"\n    # Build graph\n    graph = {i: {} for i in range(1, n + 1)}\n    for u, v, w in times:\n        graph[u][v] = w\n    \n    # Dijkstra\n    distances, _ = dijkstra(graph, k)\n    \n    # Max distance = thời gian cần\n    max_dist = max(distances.values())\n    \n    return max_dist if max_dist != float('inf') else -1\n\n# Test\ntimes = [[2,1,1], [2,3,1], [3,4,1]]\nprint(f\"Network delay: {network_delay_time(times, 4, 2)}\")\n```\n\n#### 8.5. Cheapest Flights Within K Stops\n\n```python\ndef cheapest_flights_k_stops(n, flights, src, dst, k):\n    \"\"\"\n    Tìm chuyến bay rẻ nhất với tối đa k điểm dừng\n    Modified Bellman-Ford\n    \"\"\"\n    # prices[i] = chi phí rẻ nhất đến đỉnh i\n    prices = [float('inf')] * n\n    prices[src] = 0\n    \n    # Lặp k+1 lần (tối đa k stops)\n    for _ in range(k + 1):\n        temp_prices = prices.copy()\n        \n        for u, v, price in flights:\n            if prices[u] != float('inf'):\n                temp_prices[v] = min(temp_prices[v], prices[u] + price)\n        \n        prices = temp_prices\n    \n\n**Các khái niệm quan trọng:**\n- Dijkstra là một thuật toán tham lam (Greedy) được sử dụng để tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh khác trong một đồ thị có trọng số không âm. Thuật toán này hoạt động bằng cách duy trì một tập hợp các đỉnh đã được thăm và sử dụng một hàng đợi ưu tiên (min-priority queue hoặc min-heap) để luôn chọn đỉnh có khoảng cách nhỏ nhất chưa được xét. Dijkstra không thể xử lý các cạnh có trọng số âm hoặc phát hiện chu trình âm. Độ phức tạp thời gian của Dijkstra thường là O(E log V) hoặc O(E + V log V) khi sử dụng min-priority queue (heap), hoặc O((V+E) log V) với binary heap. Độ phức tạp không gian là O(V) hoặc O(V + E) để lưu trữ đồ thị, khoảng cách và đỉnh cha.\n\nA* Algorithm là một thuật toán tìm kiếm đường đi và duyệt đồ thị, được cải tiến từ Dijkstra bằng cách sử dụng một hàm heuristic để ước lượng chi phí từ đỉnh hiện tại đến đỉnh đích. A* là một thuật toán tìm kiếm tốt nhất đầu tiên (best-first search) sử dụng hàng đợi ưu tiên để lưu trữ các node cần thăm, ưu tiên node có f(n) nhỏ nhất (f(n) = g(n) + h(n), với g(n) là chi phí thực tế và h(n) là chi phí ước lượng). A* hiệu quả hơn Dijkstra trong nhiều trường hợp vì nó có khả năng \"hướng dẫn\" tìm kiếm về phía đích, giúp tối ưu hóa việc tìm kiếm. Độ phức tạp thời gian của A* phụ thuộc vào chất lượng của hàm heuristic, trong trường hợp xấu nhất có thể tương tự Dijkstra (O(E log V) hoặc O(E) với Fibonacci heap), nhưng trong thực tế thường nhanh hơn nhiều.\n- Bellman-Ford là thuật toán tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh khác trong một đồ thị có trọng số, bao gồm cả trọng số âm. Thuật toán này có khả năng phát hiện chu trình âm (negative cycle), điều mà thuật toán Dijkstra không làm được. Ý tưởng chính là lặp lại quá trình \"relax\" tất cả các cạnh V-1 lần để đảm bảo tìm được đường đi ngắn nhất, sau đó một lần lặp thứ V được thực hiện để kiểm tra sự tồn tại của chu trình âm. Độ phức tạp thời gian của Bellman-Ford là O(VE) và độ phức tạp không gian là O(V) hoặc O(V + E).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n    return prices[dst] if prices[dst] != float('inf') else -1\n\n# Test\nflights = [[0,1,100], [1,2,100], [0,2,500]]\nprint(f\"Cheapest: {cheapest_flights_k_stops(3, flights, 0, 2, 1)}\")\n```\n\n---\n\n### 9. Tối ưu hóa và Biến thể\n\n#### 9.1. A* Algorithm\n\nCải tiến Dijkstra với heuristic function:\n\n```python\ndef a_star(graph, start, goal, heuristic):\n    \"\"\"\n    A* algorithm - Dijkstra + heuristic\n    heuristic(node, goal) = ước lượng khoảng cách đến goal\n    \n    f(n) = g(n) + h(n)\n    g(n) = cost từ start đến n\n    h(n) = heuristic từ n đến goal\n    \"\"\"\n    import heapq\n    \n    open_set = [(0 + heuristic(start, goal), 0, start)]\n    came_from = {}\n    g_score = {start: 0}\n    \n    while open_set:\n        _, current_g, current = heapq.heappop(open_set)\n        \n        if current == goal:\n            # Reconstruct path\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1], g_score[goal]\n        \n        for neighbor, weight in graph[current].items():\n            tentative_g = current_g + weight\n            \n            if neighbor not in g_score or tentative_g < g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g\n                f_score = tentative_g + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_score, tentative_g, neighbor))\n    \n    return None, float('inf')\n```\n\n#### 9.2. Bidirectional Dijkstra\n\nChạy Dijkstra từ cả 2 phía (start và end):\n\n```python\ndef bidirectional_dijkstra(graph, start, end):\n    \"\"\"\n    Dijkstra từ cả 2 phía\n    Nhanh hơn khi chỉ cần tìm 1 đường đi\n    \"\"\"\n    # Implement tương tự Dijkstra nhưng:\n    # - Chạy 2 searches song song\n    # - Dừng khi 2 searches gặp nhau\n    # - Kết hợp 2 paths\n    pass\n```\n\n\n**Các khái niệm quan trọng:**\n- Bidirectional Dijkstra là một biến thể của thuật toán Dijkstra, trong đó hai tìm kiếm Dijkstra được chạy song song: một từ đỉnh bắt đầu và một từ đỉnh kết thúc. Thuật toán dừng khi hai tìm kiếm gặp nhau. Kỹ thuật này thường nhanh hơn Dijkstra truyền thống khi chỉ cần tìm một đường đi duy nhất giữa hai đỉnh, đặc biệt trên các đồ thị lớn, vì nó khám phá ít đỉnh hơn. Độ phức tạp thời gian thường là O(E log V) hoặc O(E + V log V) nhưng với hằng số nhỏ hơn so với Dijkstra một chiều.\n\n**Mối quan hệ:**\n- Bidirectional Dijkstra giải quyết bài toán tìm đường đi ngắn nhất giữa hai đỉnh trong đồ thị.\n- Bidirectional Dijkstra là một biến thể của Dijkstra, thường nhanh hơn khi chỉ cần tìm một đường đi duy nhất giữa hai đỉnh.\n- Bidirectional Dijkstra có độ phức tạp thời gian là O(E log V) hoặc O(E + V log V) nhưng với hằng số nhỏ hơn so với Dijkstra một chiều.\n- Bidirectional Dijkstra là một biến thể của thuật toán Dijkstra, chạy tìm kiếm từ hai phía để tăng tốc độ.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n#### 5.1. Ý tưởng\n\n**Bellman-Ford** tìm đường đi ngắn nhất từ nguồn trong **weighted graph có thể có trọng số âm**.\n\n**Khác với Dijkstra:**\n- ✅ Xử lý được trọng số âm\n- ✅ Phát hiện được negative cycle\n- ❌ Chậm hơn: O(VE) vs O((V+E) log V)\n\n**Thuật toán:**\n1. Khởi tạo distance nguồn = 0, còn lại = ∞\n2. Lặp (V-1) lần:\n   - Relax tất cả các cạnh\n3. Kiểm tra negative cycle (lặp lần thứ V)\n\n#### 5.2. Cài đặt\n\n```python\ndef bellman_ford(graph, start):\n    \"\"\"\n    Bellman-Ford algorithm\n    Time: O(VE), Space: O(V)\n    \n    graph: list of edges [(u, v, weight)]\n    Returns: (distances, parent, has_negative_cycle)\n    \"\"\"\n    # Lấy tất cả vertices\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    # Khởi tạo\n    distances = {v: float('inf') for v in vertices}\n    distances[start] = 0\n    parent = {v: None for v in vertices}\n    \n    # Relax tất cả edges (V-1) lần\n    for _ in range(len(vertices) - 1):\n        updated = False\n        \n        for u, v, weight in graph:\n            if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n                distances[v] = distances[u] + weight\n                parent[v] = u\n                updated = True\n        \n        # Early termination nếu không có update\n        if not updated:\n            break\n    \n    # Kiểm tra negative cycle\n    has_negative_cycle = False\n    for u, v, weight in graph:\n        if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n            has_negative_cycle = True\n            break\n    \n    return distances, parent, has_negative_cycle\n\n# Test\nedges = [\n    ('A', 'B', 4),\n    ('A', 'C', 2),\n    ('B', 'C', 1),\n    ('B', 'D', 5),\n    ('C', 'D', 8),\n    ('C', 'E', 10),\n    ('D', 'E', 2),\n    ('D', 'F', 6),\n    ('E', 'F', 3)\n]\n\ndistances, parent, has_neg_cycle = bellman_ford(edges, 'A')\nprint(\"\nBellman-Ford from A:\")\nprint(f\"Has negative cycle: {has_neg_cycle}\")\nfor vertex in sorted(distances.keys()):\n    print(f\"A → {vertex}: {distances[vertex]}\")\n```\n\n#### 5.3. Phát hiện Negative Cycle\n\n```python\ndef detect_negative_cycle(graph):\n    \"\"\"\n    Phát hiện negative cycle trong graph\n    \"\"\"\n    # Thử từ mỗi vertex (cho disconnected graph)\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    for start in vertices:\n        _, _, has_cycle = bellman_ford(graph, start)\n        if has_cycle:\n            return True\n    \n    return False\n\n# Test với negative cycle\nedges_with_cycle = [\n    ('A', 'B', 1),\n    ('B', 'C', -3),\n    ('C', 'A', 1)  # Cycle A→B→C→A có tổng = -1\n]\n\nprint(f\"\nHas negative cycle: {detect_negative_cycle(edges_with_cycle)}\")\n```\n\n**Minh họa Negative Cycle:**\n```\nGraph with negative cycle:\n    A --1-→ B\n    ↑       |\n    1       -3\n    |       ↓\n    +←------C\n\nCycle: A → B → C → A\nWeight: 1 + (-3) + 1 = -1 (negative!)\n\nMỗi lần đi qua cycle, distance giảm → không có shortest path\n```\n\n---\n\n### 6. Floyd-Warshall Algorithm (All Pairs)\n\n#### 6.1. Ý tưởng\n\n\n**Các khái niệm quan trọng:**\n- Bellman-Ford là thuật toán tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh khác trong một đồ thị có trọng số, bao gồm cả trọng số âm. Thuật toán này có khả năng phát hiện chu trình âm (negative cycle), điều mà thuật toán Dijkstra không làm được. Ý tưởng chính là lặp lại quá trình \"relax\" tất cả các cạnh V-1 lần để đảm bảo tìm được đường đi ngắn nhất, sau đó một lần lặp thứ V được thực hiện để kiểm tra sự tồn tại của chu trình âm. Độ phức tạp thời gian của Bellman-Ford là O(VE) và độ phức tạp không gian là O(V) hoặc O(V + E).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n        # Đã xét rồi (vì có thể có nhiều entry trong heap)\n        if current in visited:\n            continue\n        \n        visited.add(current)\n        \n        # Không cần xét nếu distance đã lớn hơn\n        if current_dist > distances[current]:\n            continue\n        \n        # Relaxation\n        for neighbor, weight in graph[current].items():\n            distance = current_dist + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                parent[neighbor] = current\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances, parent\n\n# Test\nweighted_graph = {\n    'A': {'B': 4, 'C': 2},\n    'B': {'A': 4, 'C': 1, 'D': 5},\n    'C': {'A': 2, 'B': 1, 'D': 8, 'E': 10},\n    'D': {'B': 5, 'C': 8, 'E': 2, 'F': 6},\n    'E': {'C': 10, 'D': 2, 'F': 3},\n    'F': {'D': 6, 'E': 3}\n}\n\ndistances, parent = dijkstra(weighted_graph, 'A')\nprint(\"\nDijkstra from A:\")\nfor vertex in distances:\n    print(f\"A → {vertex}: {distances[vertex]}\")\n    path = reconstruct_path(parent, 'A', vertex)\n    print(f\"  Path: {' → '.join(path) if path else 'No path'}\")\n```\n\n**Minh họa từng bước:**\n```\nGraph:\n    A --4-- B --5-- D\n    |  \\    |  \\    |  \\\n    2   1   1   8   2   6\n    |    \\  |    \\  |    \\\n    C --8-- + --10- E --3-- F\n\nStep by step từ A:\n\nInitial: A=0, B=∞, C=∞, D=∞, E=∞, F=∞\n\n1. Chọn A (dist=0)\n   Relax: B=4, C=2\n   Heap: [(2,C), (4,B)]\n\n2. Chọn C (dist=2)\n   Relax: B=min(4,2+1)=3, D=10, E=12\n   Heap: [(3,B), (4,B), (10,D), (12,E)]\n\n3. Chọn B (dist=3)\n   Relax: D=min(10,3+5)=8\n   Heap: [(4,B), (8,D), (10,D), (12,E)]\n\n4. Chọn B (dist=4) - Skip (visited)\n\n5. Chọn D (dist=8)\n   Relax: E=min(12,8+2)=10, F=14\n   Heap: [(10,D), (10,E), (12,E), (14,F)]\n\n6. Chọn D (dist=10) - Skip\n\n7. Chọn E (dist=10)\n   Relax: F=min(14,10+3)=13\n   Heap: [(12,E), (13,F), (14,F)]\n\n8. Continue...\n\nFinal distances:\nA → A: 0\nA → B: 3 (A → C → B)\nA → C: 2 (A → C)\nA → D: 8 (A → C → B → D)\nA → E: 10 (A → C → B → D → E)\nA → F: 13 (A → C → B → D → E → F)\n```\n\n#### 4.3. Dijkstra với Path Reconstruction\n\n```python\ndef dijkstra_with_path(graph, start, end):\n    \"\"\"\n    Tìm đường đi ngắn nhất từ start đến end\n    \"\"\"\n    distances, parent = dijkstra(graph, start)\n    \n    if distances[end] == float('inf'):\n        return None, float('inf')\n    \n    path = reconstruct_path(parent, start, end)\n    return path, distances[end]\n\n# Test\npath, dist = dijkstra_with_path(weighted_graph, 'A', 'F')\nprint(f\"\nShortest path A → F: {' → '.join(path)}\")\nprint(f\"Distance: {dist}\")\n```\n\n---\n\n### 5. Bellman-Ford Algorithm\n\n\n**Các khái niệm quan trọng:**\n- dijkstra_with_path là một biến thể của thuật toán Dijkstra được thiết kế để không chỉ tìm khoảng cách ngắn nhất mà còn tái tạo lại đường đi ngắn nhất từ đỉnh nguồn đến một đỉnh đích cụ thể. Nó sử dụng kết quả từ hàm `dijkstra` (khoảng cách và đỉnh cha) để xây dựng lại đường đi.\n\n**Mối quan hệ:**\n- dijkstra_with_path sử dụng thuật toán reconstruct_path để xây dựng lại đường đi ngắn nhất từ đỉnh nguồn đến đỉnh đích.\n- dijkstra_with_path sử dụng thuật toán Dijkstra để tính toán khoảng cách và đỉnh cha trước khi tái tạo đường đi."
        },
        "output_without_context": {
            "question": "So sánh thuật toán Dijkstra và Bellman-Ford, thuật toán nào có thể xử lý đồ thị có trọng số âm?",
            "answer": "Bellman-Ford"
        }
    },
    {
        "topic_description": "Chủ đề này kiểm tra khả năng của học sinh trong việc áp dụng các khái niệm về chu trình âm để phát hiện chênh lệch giá trong đồ thị. Học sinh sẽ được đánh giá về khả năng giải quyết bài toán thông qua việc sử dụng trọng số cạnh và thuật toán Bellman-Ford.",
        "output_with_context": {
            "question": "Trong thuật toán Bellman-Ford, khi nào bạn cần kiểm tra sự tồn tại của chu trình âm trong đồ thị?",
            "answer": "Sau khi thực hiện V-1 lần lặp để relax tất cả các cạnh.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n| Bellman-Ford | Any weight | O(VE) | O(V) | ✅ | Detect |\n| Floyd-Warshall | Any weight | O(V³) | O(V²) | ✅ | Detect |\n\n**Khi nào dùng:**\n- **BFS:** Unweighted graph, đơn giản nhất\n- **Dijkstra:** Weighted graph, không có cạnh âm, nhanh nhất\n- **Bellman-Ford:** Có cạnh âm, hoặc cần detect negative cycle\n- **Floyd-Warshall:** Cần tất cả cặp shortest paths, graph nhỏ\n\n---\n\n### 8. Ứng dụng thực tế\n\n#### 8.1. Network Routing\n\n```python\ndef find_shortest_route(network, source, destination):\n    \"\"\"\n    Tìm tuyến đường ngắn nhất trong mạng\n    network: weighted graph (router graph)\n    \"\"\"\n    distances, parent = dijkstra(network, source)\n    \n    if distances[destination] == float('inf'):\n        return None, \"No route available\"\n    \n    path = reconstruct_path(parent, source, destination)\n    return path, distances[destination]\n```\n\n#### 8.2. Map Navigation (GPS)\n\n```python\ndef gps_navigation(map_graph, start, end):\n    \"\"\"\n    Tìm đường đi ngắn nhất trên bản đồ\n    Có thể mở rộng với A* algorithm\n    \"\"\"\n    path, distance = dijkstra_with_path(map_graph, start, end)\n    \n    if path is None:\n        return \"No route found\"\n    \n    return {\n        'path': path,\n        'distance': distance,\n        'estimated_time': distance / 60  # Giả sử 60km/h\n    }\n```\n\n#### 8.3. Currency Arbitrage Detection\n\n```python\ndef detect_arbitrage(exchange_rates):\n    \"\"\"\n    Phát hiện cơ hội arbitrage trong tỷ giá\n    Sử dụng negative cycle detection\n    \n    Chuyển đổi: weight = -log(exchange_rate)\n    Negative cycle = arbitrage opportunity\n    \"\"\"\n    import math\n    \n    edges = []\n    for source, targets in exchange_rates.items():\n        for target, rate in targets.items():\n            # Chuyển multiplication thành addition\n            weight = -math.log(rate)\n            edges.append((source, target, weight))\n    \n    return detect_negative_cycle(edges)\n```\n\n#### 8.4. Network Delay Time\n\n```python\ndef network_delay_time(times, n, k):\n    \"\"\"\n    Thời gian để tín hiệu đến tất cả nodes\n    times: [[u, v, w]] - từ u đến v mất w thời gian\n    n: số nodes\n    k: node nguồn\n    \"\"\"\n    # Build graph\n    graph = {i: {} for i in range(1, n + 1)}\n    for u, v, w in times:\n        graph[u][v] = w\n    \n    # Dijkstra\n    distances, _ = dijkstra(graph, k)\n    \n    # Max distance = thời gian cần\n    max_dist = max(distances.values())\n    \n    return max_dist if max_dist != float('inf') else -1\n\n# Test\ntimes = [[2,1,1], [2,3,1], [3,4,1]]\nprint(f\"Network delay: {network_delay_time(times, 4, 2)}\")\n```\n\n#### 8.5. Cheapest Flights Within K Stops\n\n```python\ndef cheapest_flights_k_stops(n, flights, src, dst, k):\n    \"\"\"\n    Tìm chuyến bay rẻ nhất với tối đa k điểm dừng\n    Modified Bellman-Ford\n    \"\"\"\n    # prices[i] = chi phí rẻ nhất đến đỉnh i\n    prices = [float('inf')] * n\n    prices[src] = 0\n    \n    # Lặp k+1 lần (tối đa k stops)\n    for _ in range(k + 1):\n        temp_prices = prices.copy()\n        \n        for u, v, price in flights:\n            if prices[u] != float('inf'):\n                temp_prices[v] = min(temp_prices[v], prices[u] + price)\n        \n        prices = temp_prices\n    \n\n**Các khái niệm quan trọng:**\n- Currency Arbitrage Detection là bài toán phát hiện cơ hội kiếm lời từ sự chênh lệch tỷ giá hối đoái giữa các loại tiền tệ. Bài toán này có thể được mô hình hóa thành việc tìm chu trình âm trong đồ thị tỷ giá, nơi trọng số cạnh được chuyển đổi thành -log(exchange_rate).\n- Negative Cycle Detection là kỹ thuật phát hiện chu trình có tổng trọng số âm trong đồ thị. Sự tồn tại của chu trình âm có thể làm cho bài toán đường đi ngắn nhất không xác định (đường đi có thể trở nên ngắn vô hạn). Thuật toán Bellman-Ford và Floyd-Warshall có khả năng phát hiện chu trình âm.\n- Bellman-Ford là thuật toán tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh khác trong một đồ thị có trọng số, bao gồm cả trọng số âm. Thuật toán này có khả năng phát hiện chu trình âm (negative cycle), điều mà thuật toán Dijkstra không làm được. Ý tưởng chính là lặp lại quá trình \"relax\" tất cả các cạnh V-1 lần để đảm bảo tìm được đường đi ngắn nhất, sau đó một lần lặp thứ V được thực hiện để kiểm tra sự tồn tại của chu trình âm. Độ phức tạp thời gian của Bellman-Ford là O(VE) và độ phức tạp không gian là O(V) hoặc O(V + E).\n\n**Mối quan hệ:**\n- Bellman-Ford đảm bảo khả năng phát hiện chu trình âm.\n- Bellman-Ford giải quyết bài toán Single Source Shortest Path (SSSP) trong Weighted Graph với Negative weights và có thể phát hiện Negative cycles.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n\n### 1. Giới thiệu về Graph (Đồ thị)\n\n#### 1.1. Khái niệm cơ bản\n\n**Graph (Đồ thị)** là một cấu trúc dữ liệu bao gồm:\n- **Vertices (V):** Tập các đỉnh (nodes)\n- **Edges (E):** Tập các cạnh kết nối các đỉnh\n\n**Ký hiệu:** G = (V, E)\n\n**Các loại graph:**\n\n**a) Directed vs Undirected:**\n```\nUndirected:           Directed (Digraph):\n    A --- B               A → B\n    |     |               ↓   ↓\n    C --- D               C → D\n```\n\n**b) Weighted vs Unweighted:**\n```\nUnweighted:           Weighted:\n    A --- B               A --5-- B\n    |     |               |       |\n    C --- D               3       7\n                          |       |\n                          C --2-- D\n```\n\n**c) Connected vs Disconnected:**\n```\nConnected:            Disconnected:\n    A --- B               A --- B    E --- F\n    |     |                          \n    C --- D               C --- D    \n```\n\n#### 1.2. Biểu diễn Graph\n\n**a) Adjacency Matrix (Ma trận kề):**\n```python\n# Không gian: O(V²)\ngraph = [\n    [0, 1, 1, 0],  # A kết nối với B, C\n    [1, 0, 0, 1],  # B kết nối với A, D\n    [1, 0, 0, 1],  # C kết nối với A, D\n    [0, 1, 1, 0]   # D kết nối với B, C\n]\n```\n\n**b) Adjacency List (Danh sách kề):**\n```python\n# Không gian: O(V + E)\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D'],\n    'C': ['A', 'D'],\n    'D': ['B', 'C']\n}\n\n# Weighted graph\nweighted_graph = {\n    'A': [('B', 5), ('C', 3)],\n    'B': [('A', 5), ('D', 7)],\n    'C': [('A', 3), ('D', 2)],\n    'D': [('B', 7), ('C', 2)]\n}\n```\n\n**So sánh:**\n\n| Đặc điểm | Adjacency Matrix | Adjacency List |\n|----------|------------------|----------------|\n| Space | O(V²) | O(V + E) |\n| Check edge (u,v) | O(1) | O(degree(u)) |\n| Iterate neighbors | O(V) | O(degree(u)) |\n| Add vertex | O(V²) | O(1) |\n| Add edge | O(1) | O(1) |\n\n---\n\n### 2. Bài toán Shortest Path (Đường đi ngắn nhất)\n\n**Phân loại:**\n\n1. **Single Source Shortest Path (SSSP):**\n   - Từ 1 đỉnh nguồn đến tất cả đỉnh khác\n   - Algorithms: BFS, Dijkstra, Bellman-Ford\n\n2. **All Pairs Shortest Path (APSP):**\n   - Giữa mọi cặp đỉnh\n   - Algorithm: Floyd-Warshall\n\n**Đặc điểm:**\n- **Unweighted:** BFS\n- **Non-negative weights:** Dijkstra\n- **Negative weights:** Bellman-Ford\n- **Negative cycles:** Bellman-Ford (detect)\n\n---\n\n### 3. BFS (Breadth-First Search) - Unweighted\n\n#### 3.1. Ý tưởng\n\nBFS tìm đường đi ngắn nhất trong **unweighted graph** bằng cách duyệt theo từng level.\n\n**Thuật toán:**\n1. Dùng queue, bắt đầu từ đỉnh nguồn\n2. Đánh dấu khoảng cách từ nguồn = 0\n\n**Các khái niệm quan trọng:**\n- Bellman-Ford là thuật toán tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh khác trong một đồ thị có trọng số, bao gồm cả trọng số âm. Thuật toán này có khả năng phát hiện chu trình âm (negative cycle), điều mà thuật toán Dijkstra không làm được. Ý tưởng chính là lặp lại quá trình \"relax\" tất cả các cạnh V-1 lần để đảm bảo tìm được đường đi ngắn nhất, sau đó một lần lặp thứ V được thực hiện để kiểm tra sự tồn tại của chu trình âm. Độ phức tạp thời gian của Bellman-Ford là O(VE) và độ phức tạp không gian là O(V) hoặc O(V + E).\n\n**Mối quan hệ:**\n- Bellman-Ford đảm bảo khả năng phát hiện chu trình âm.\n- Bellman-Ford giải quyết bài toán Single Source Shortest Path (SSSP) trong Weighted Graph với Negative weights và có thể phát hiện Negative cycles.\n- Bellman-Ford so sánh với Dijkstra ở khả năng xử lý trọng số âm và phát hiện chu trình âm, nhưng chậm hơn về độ phức tạp thời gian.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n#### 5.1. Ý tưởng\n\n**Bellman-Ford** tìm đường đi ngắn nhất từ nguồn trong **weighted graph có thể có trọng số âm**.\n\n**Khác với Dijkstra:**\n- ✅ Xử lý được trọng số âm\n- ✅ Phát hiện được negative cycle\n- ❌ Chậm hơn: O(VE) vs O((V+E) log V)\n\n**Thuật toán:**\n1. Khởi tạo distance nguồn = 0, còn lại = ∞\n2. Lặp (V-1) lần:\n   - Relax tất cả các cạnh\n3. Kiểm tra negative cycle (lặp lần thứ V)\n\n#### 5.2. Cài đặt\n\n```python\ndef bellman_ford(graph, start):\n    \"\"\"\n    Bellman-Ford algorithm\n    Time: O(VE), Space: O(V)\n    \n    graph: list of edges [(u, v, weight)]\n    Returns: (distances, parent, has_negative_cycle)\n    \"\"\"\n    # Lấy tất cả vertices\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    # Khởi tạo\n    distances = {v: float('inf') for v in vertices}\n    distances[start] = 0\n    parent = {v: None for v in vertices}\n    \n    # Relax tất cả edges (V-1) lần\n    for _ in range(len(vertices) - 1):\n        updated = False\n        \n        for u, v, weight in graph:\n            if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n                distances[v] = distances[u] + weight\n                parent[v] = u\n                updated = True\n        \n        # Early termination nếu không có update\n        if not updated:\n            break\n    \n    # Kiểm tra negative cycle\n    has_negative_cycle = False\n    for u, v, weight in graph:\n        if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n            has_negative_cycle = True\n            break\n    \n    return distances, parent, has_negative_cycle\n\n# Test\nedges = [\n    ('A', 'B', 4),\n    ('A', 'C', 2),\n    ('B', 'C', 1),\n    ('B', 'D', 5),\n    ('C', 'D', 8),\n    ('C', 'E', 10),\n    ('D', 'E', 2),\n    ('D', 'F', 6),\n    ('E', 'F', 3)\n]\n\ndistances, parent, has_neg_cycle = bellman_ford(edges, 'A')\nprint(\"\nBellman-Ford from A:\")\nprint(f\"Has negative cycle: {has_neg_cycle}\")\nfor vertex in sorted(distances.keys()):\n    print(f\"A → {vertex}: {distances[vertex]}\")\n```\n\n#### 5.3. Phát hiện Negative Cycle\n\n```python\ndef detect_negative_cycle(graph):\n    \"\"\"\n    Phát hiện negative cycle trong graph\n    \"\"\"\n    # Thử từ mỗi vertex (cho disconnected graph)\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    for start in vertices:\n        _, _, has_cycle = bellman_ford(graph, start)\n        if has_cycle:\n            return True\n    \n    return False\n\n# Test với negative cycle\nedges_with_cycle = [\n    ('A', 'B', 1),\n    ('B', 'C', -3),\n    ('C', 'A', 1)  # Cycle A→B→C→A có tổng = -1\n]\n\nprint(f\"\nHas negative cycle: {detect_negative_cycle(edges_with_cycle)}\")\n```\n\n**Minh họa Negative Cycle:**\n```\nGraph with negative cycle:\n    A --1-→ B\n    ↑       |\n    1       -3\n    |       ↓\n    +←------C\n\nCycle: A → B → C → A\nWeight: 1 + (-3) + 1 = -1 (negative!)\n\nMỗi lần đi qua cycle, distance giảm → không có shortest path\n```\n\n---\n\n### 6. Floyd-Warshall Algorithm (All Pairs)\n\n#### 6.1. Ý tưởng\n\n\n**Các khái niệm quan trọng:**\n- Bellman-Ford là thuật toán tìm đường đi ngắn nhất từ một đỉnh nguồn đến tất cả các đỉnh khác trong một đồ thị có trọng số, bao gồm cả trọng số âm. Thuật toán này có khả năng phát hiện chu trình âm (negative cycle), điều mà thuật toán Dijkstra không làm được. Ý tưởng chính là lặp lại quá trình \"relax\" tất cả các cạnh V-1 lần để đảm bảo tìm được đường đi ngắn nhất, sau đó một lần lặp thứ V được thực hiện để kiểm tra sự tồn tại của chu trình âm. Độ phức tạp thời gian của Bellman-Ford là O(VE) và độ phức tạp không gian là O(V) hoặc O(V + E).\n\n**Mối quan hệ:**\n- Bellman-Ford đảm bảo khả năng phát hiện chu trình âm.\n- Bellman-Ford giải quyết bài toán Single Source Shortest Path (SSSP) trong Weighted Graph với Negative weights và có thể phát hiện Negative cycles.\n- Bellman-Ford so sánh với Dijkstra ở khả năng xử lý trọng số âm và phát hiện chu trình âm, nhưng chậm hơn về độ phức tạp thời gian."
        },
        "output_without_context": {
            "question": "Khi áp dụng thuật toán Bellman-Ford để phát hiện chênh lệch giá trong đồ thị, điều gì là cần thiết để đảm bảo rằng thuật toán hoạt động chính xác?",
            "answer": "Cần có trọng số cạnh không âm hoặc có chu trình âm trong đồ thị."
        }
    },
    {
        "topic_description": "Chủ đề này tích hợp khái niệm từ tuần hiện tại về đường đi ngắn nhất với thuật toán sắp xếp tô pô, kiểm tra khả năng của học sinh trong việc áp dụng kiến thức từ tuần trước vào bài toán hiện tại. Học sinh sẽ phân tích cách sử dụng thuật toán sắp xếp tô pô để tìm đường đi ngắn nhất trong DAG.",
        "output_with_context": {
            "question": "Khi áp dụng thuật toán sắp xếp tô pô để tìm đường đi ngắn nhất trong một đồ thị có hướng (DAG), điều gì là cần thiết để đảm bảo rằng thuật toán hoạt động chính xác?",
            "answer": "Đồ thị phải không có chu trình, và các đỉnh cần được sắp xếp theo thứ tự mà các đỉnh phụ thuộc được xử lý trước.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n3. Duyệt các đỉnh kề, cập nhật khoảng cách\n4. Lặp lại cho đến khi queue rỗng\n\n#### 3.2. Cài đặt\n\n```python\nfrom collections import deque\n\ndef bfs_shortest_path(graph, start):\n    \"\"\"\n    Tìm đường đi ngắn nhất từ start đến tất cả đỉnh\n    Chỉ dùng cho unweighted graph\n    Time: O(V + E), Space: O(V)\n    \"\"\"\n    # Khởi tạo\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    parent = {vertex: None for vertex in graph}\n    \n    queue = deque([start])\n    \n    while queue:\n        current = queue.popleft()\n        \n        # Duyệt các đỉnh kề\n        for neighbor in graph[current]:\n            if distances[neighbor] == float('inf'):\n                distances[neighbor] = distances[current] + 1\n                parent[neighbor] = current\n                queue.append(neighbor)\n    \n    return distances, parent\n\ndef reconstruct_path(parent, start, end):\n    \"\"\"Tái tạo đường đi từ start đến end\"\"\"\n    if parent[end] is None and start != end:\n        return None  # Không có đường đi\n    \n    path = []\n    current = end\n    \n    while current is not None:\n        path.append(current)\n        current = parent[current]\n    \n    path.reverse()\n    return path\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\ndistances, parent = bfs_shortest_path(graph, 'A')\nprint(\"Distances from A:\", distances)\nprint(\"Path A to F:\", reconstruct_path(parent, 'A', 'F'))\n```\n\n**Minh họa:**\n```\nGraph:\n    A --- B --- D\n    |     |\n    C --- F --- E\n\nBFS từ A:\nLevel 0: A (distance = 0)\nLevel 1: B, C (distance = 1)\nLevel 2: D, E, F (distance = 2)\n\nShortest paths from A:\nA → B: 1\nA → C: 1\nA → D: 2 (A → B → D)\nA → E: 2 (A → B → E)\nA → F: 2 (A → C → F)\n```\n\n---\n\n### 4. Dijkstra's Algorithm\n\n#### 4.1. Ý tưởng\n\n**Dijkstra** tìm đường đi ngắn nhất từ nguồn đến tất cả đỉnh trong **weighted graph với trọng số không âm**.\n\n**Thuật toán (Greedy):**\n1. Khởi tạo khoảng cách nguồn = 0, còn lại = ∞\n2. Dùng min-heap (priority queue)\n3. Chọn đỉnh có khoảng cách nhỏ nhất chưa xét\n4. **Relaxation:** Cập nhật khoảng cách các đỉnh kề\n5. Lặp lại cho đến khi tất cả đỉnh được xét\n\n**Relaxation:**\n```\nif dist[u] + weight(u, v) < dist[v]:\n    dist[v] = dist[u] + weight(u, v)\n    parent[v] = u\n```\n\n#### 4.2. Cài đặt\n\n```python\nimport heapq\n\ndef dijkstra(graph, start):\n    \"\"\"\n    Dijkstra's algorithm cho weighted graph\n    Time: O((V + E) log V) với binary heap\n    Space: O(V)\n    \n    graph: dict of dict\n    graph[u][v] = weight of edge (u, v)\n    \"\"\"\n    # Khởi tạo\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    parent = {vertex: None for vertex in graph}\n    \n    # Min heap: (distance, vertex)\n    pq = [(0, start)]\n    visited = set()\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        \n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n- Graph Algorithms (Thuật toán đồ thị) là một lĩnh vực trong khoa học máy tính tập trung vào việc nghiên cứu và giải quyết các bài toán trên cấu trúc dữ liệu đồ thị. Các bài toán phổ biến bao gồm tìm đường đi ngắn nhất, tìm kiếm theo chiều sâu/rộng (duyệt đồ thị), tìm cây bao trùm tối thiểu/nhỏ nhất, v.v.\n\n**Mối quan hệ:**\n- BFS Shortest Path giải quyết bài toán tìm đường đi ngắn nhất trong unweighted graph.\n- Dijkstra's Algorithm giải quyết bài toán tìm đường đi ngắn nhất từ nguồn đến tất cả đỉnh.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n#### 5.1. Ý tưởng\n\n**Bellman-Ford** tìm đường đi ngắn nhất từ nguồn trong **weighted graph có thể có trọng số âm**.\n\n**Khác với Dijkstra:**\n- ✅ Xử lý được trọng số âm\n- ✅ Phát hiện được negative cycle\n- ❌ Chậm hơn: O(VE) vs O((V+E) log V)\n\n**Thuật toán:**\n1. Khởi tạo distance nguồn = 0, còn lại = ∞\n2. Lặp (V-1) lần:\n   - Relax tất cả các cạnh\n3. Kiểm tra negative cycle (lặp lần thứ V)\n\n#### 5.2. Cài đặt\n\n```python\ndef bellman_ford(graph, start):\n    \"\"\"\n    Bellman-Ford algorithm\n    Time: O(VE), Space: O(V)\n    \n    graph: list of edges [(u, v, weight)]\n    Returns: (distances, parent, has_negative_cycle)\n    \"\"\"\n    # Lấy tất cả vertices\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    # Khởi tạo\n    distances = {v: float('inf') for v in vertices}\n    distances[start] = 0\n    parent = {v: None for v in vertices}\n    \n    # Relax tất cả edges (V-1) lần\n    for _ in range(len(vertices) - 1):\n        updated = False\n        \n        for u, v, weight in graph:\n            if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n                distances[v] = distances[u] + weight\n                parent[v] = u\n                updated = True\n        \n        # Early termination nếu không có update\n        if not updated:\n            break\n    \n    # Kiểm tra negative cycle\n    has_negative_cycle = False\n    for u, v, weight in graph:\n        if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n            has_negative_cycle = True\n            break\n    \n    return distances, parent, has_negative_cycle\n\n# Test\nedges = [\n    ('A', 'B', 4),\n    ('A', 'C', 2),\n    ('B', 'C', 1),\n    ('B', 'D', 5),\n    ('C', 'D', 8),\n    ('C', 'E', 10),\n    ('D', 'E', 2),\n    ('D', 'F', 6),\n    ('E', 'F', 3)\n]\n\ndistances, parent, has_neg_cycle = bellman_ford(edges, 'A')\nprint(\"\nBellman-Ford from A:\")\nprint(f\"Has negative cycle: {has_neg_cycle}\")\nfor vertex in sorted(distances.keys()):\n    print(f\"A → {vertex}: {distances[vertex]}\")\n```\n\n#### 5.3. Phát hiện Negative Cycle\n\n```python\ndef detect_negative_cycle(graph):\n    \"\"\"\n    Phát hiện negative cycle trong graph\n    \"\"\"\n    # Thử từ mỗi vertex (cho disconnected graph)\n    vertices = set()\n    for u, v, _ in graph:\n        vertices.add(u)\n        vertices.add(v)\n    \n    for start in vertices:\n        _, _, has_cycle = bellman_ford(graph, start)\n        if has_cycle:\n            return True\n    \n    return False\n\n# Test với negative cycle\nedges_with_cycle = [\n    ('A', 'B', 1),\n    ('B', 'C', -3),\n    ('C', 'A', 1)  # Cycle A→B→C→A có tổng = -1\n]\n\nprint(f\"\nHas negative cycle: {detect_negative_cycle(edges_with_cycle)}\")\n```\n\n**Minh họa Negative Cycle:**\n```\nGraph with negative cycle:\n    A --1-→ B\n    ↑       |\n    1       -3\n    |       ↓\n    +←------C\n\nCycle: A → B → C → A\nWeight: 1 + (-3) + 1 = -1 (negative!)\n\nMỗi lần đi qua cycle, distance giảm → không có shortest path\n```\n\n---\n\n### 6. Floyd-Warshall Algorithm (All Pairs)\n\n#### 6.1. Ý tưởng\n\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n- Graph Algorithms (Thuật toán đồ thị) là một lĩnh vực trong khoa học máy tính tập trung vào việc nghiên cứu và giải quyết các bài toán trên cấu trúc dữ liệu đồ thị. Các bài toán phổ biến bao gồm tìm đường đi ngắn nhất, tìm kiếm theo chiều sâu/rộng (duyệt đồ thị), tìm cây bao trùm tối thiểu/nhỏ nhất, v.v.\n\n**Mối quan hệ:**\n- BFS Shortest Path giải quyết bài toán tìm đường đi ngắn nhất trong unweighted graph.\n- Dijkstra's Algorithm giải quyết bài toán tìm đường đi ngắn nhất từ nguồn đến tất cả đỉnh.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n\n### 1. Giới thiệu về Graph (Đồ thị)\n\n#### 1.1. Khái niệm cơ bản\n\n**Graph (Đồ thị)** là một cấu trúc dữ liệu bao gồm:\n- **Vertices (V):** Tập các đỉnh (nodes)\n- **Edges (E):** Tập các cạnh kết nối các đỉnh\n\n**Ký hiệu:** G = (V, E)\n\n**Các loại graph:**\n\n**a) Directed vs Undirected:**\n```\nUndirected:           Directed (Digraph):\n    A --- B               A → B\n    |     |               ↓   ↓\n    C --- D               C → D\n```\n\n**b) Weighted vs Unweighted:**\n```\nUnweighted:           Weighted:\n    A --- B               A --5-- B\n    |     |               |       |\n    C --- D               3       7\n                          |       |\n                          C --2-- D\n```\n\n**c) Connected vs Disconnected:**\n```\nConnected:            Disconnected:\n    A --- B               A --- B    E --- F\n    |     |                          \n    C --- D               C --- D    \n```\n\n#### 1.2. Biểu diễn Graph\n\n**a) Adjacency Matrix (Ma trận kề):**\n```python\n# Không gian: O(V²)\ngraph = [\n    [0, 1, 1, 0],  # A kết nối với B, C\n    [1, 0, 0, 1],  # B kết nối với A, D\n    [1, 0, 0, 1],  # C kết nối với A, D\n    [0, 1, 1, 0]   # D kết nối với B, C\n]\n```\n\n**b) Adjacency List (Danh sách kề):**\n```python\n# Không gian: O(V + E)\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D'],\n    'C': ['A', 'D'],\n    'D': ['B', 'C']\n}\n\n# Weighted graph\nweighted_graph = {\n    'A': [('B', 5), ('C', 3)],\n    'B': [('A', 5), ('D', 7)],\n    'C': [('A', 3), ('D', 2)],\n    'D': [('B', 7), ('C', 2)]\n}\n```\n\n**So sánh:**\n\n| Đặc điểm | Adjacency Matrix | Adjacency List |\n|----------|------------------|----------------|\n| Space | O(V²) | O(V + E) |\n| Check edge (u,v) | O(1) | O(degree(u)) |\n| Iterate neighbors | O(V) | O(degree(u)) |\n| Add vertex | O(V²) | O(1) |\n| Add edge | O(1) | O(1) |\n\n---\n\n### 2. Bài toán Shortest Path (Đường đi ngắn nhất)\n\n**Phân loại:**\n\n1. **Single Source Shortest Path (SSSP):**\n   - Từ 1 đỉnh nguồn đến tất cả đỉnh khác\n   - Algorithms: BFS, Dijkstra, Bellman-Ford\n\n2. **All Pairs Shortest Path (APSP):**\n   - Giữa mọi cặp đỉnh\n   - Algorithm: Floyd-Warshall\n\n**Đặc điểm:**\n- **Unweighted:** BFS\n- **Non-negative weights:** Dijkstra\n- **Negative weights:** Bellman-Ford\n- **Negative cycles:** Bellman-Ford (detect)\n\n---\n\n### 3. BFS (Breadth-First Search) - Unweighted\n\n#### 3.1. Ý tưởng\n\nBFS tìm đường đi ngắn nhất trong **unweighted graph** bằng cách duyệt theo từng level.\n\n**Thuật toán:**\n1. Dùng queue, bắt đầu từ đỉnh nguồn\n2. Đánh dấu khoảng cách từ nguồn = 0\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n\n**Mối quan hệ:**\n- BFS Shortest Path giải quyết bài toán tìm đường đi ngắn nhất trong unweighted graph.\n- Dijkstra's Algorithm giải quyết bài toán tìm đường đi ngắn nhất từ nguồn đến tất cả đỉnh.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Graph Algorithms – Shortest Path\n**Floyd-Warshall** tìm đường đi ngắn nhất giữa **mọi cặp đỉnh**.\n\n**Dynamic Programming:**\n- `dp[k][i][j]` = shortest path từ i đến j qua các đỉnh {1, 2, ..., k}\n- `dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])`\n\n**Có thể tối ưu:** Dùng 2D array thay vì 3D\n\n#### 6.2. Cài đặt\n\n```python\ndef floyd_warshall(graph):\n    \"\"\"\n    Floyd-Warshall algorithm\n    Time: O(V³), Space: O(V²)\n    \n    graph: adjacency matrix (2D list)\n    graph[i][j] = weight of edge (i, j)\n    Use float('inf') for no edge\n    \"\"\"\n    n = len(graph)\n    \n    # Copy graph để không thay đổi input\n    dist = [row[:] for row in graph]\n    \n    # next[i][j] = đỉnh tiếp theo trên đường đi từ i đến j\n    next_vertex = [[None] * n for _ in range(n)]\n    \n    # Khởi tạo next_vertex\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] != float('inf') and i != j:\n                next_vertex[i][j] = j\n    \n    # Floyd-Warshall\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i][k] + dist[k][j] < dist[i][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n                    next_vertex[i][j] = next_vertex[i][k]\n    \n    return dist, next_vertex\n\ndef reconstruct_path_floyd(next_vertex, i, j):\n    \"\"\"Tái tạo đường đi từ i đến j\"\"\"\n    if next_vertex[i][j] is None:\n        return None\n    \n    path = [i]\n    while i != j:\n        i = next_vertex[i][j]\n        path.append(i)\n    \n    return path\n\n# Test\nINF = float('inf')\nadj_matrix = [\n    [0,   4,   2,   INF, INF, INF],  # A\n    [4,   0,   1,   5,   INF, INF],  # B\n    [2,   1,   0,   8,   10,  INF],  # C\n    [INF, 5,   8,   0,   2,   6],    # D\n    [INF, INF, 10,  2,   0,   3],    # E\n    [INF, INF, INF, 6,   3,   0]     # F\n]\n\ndist, next_v = floyd_warshall(adj_matrix)\n\nvertices = ['A', 'B', 'C', 'D', 'E', 'F']\nprint(\"\nFloyd-Warshall (All Pairs):\")\nprint(\"\nDistance Matrix:\")\nfor i in range(len(vertices)):\n    for j in range(len(vertices)):\n        if dist[i][j] == INF:\n            print(\"INF\", end=\"\t\")\n        else:\n            print(f\"{dist[i][j]}\", end=\"\t\")\n    print(f\"  ({vertices[i]})\")\n\n# Ví dụ một vài đường đi\nprint(\"\nSample paths:\")\nfor i in range(3):\n    for j in range(3, 6):\n        path = reconstruct_path_floyd(next_v, i, j)\n        if path:\n            path_str = ' → '.join(vertices[k] for k in path)\n            print(f\"{vertices[i]} → {vertices[j]}: {dist[i][j]} ({path_str})\")\n```\n\n---\n\n### 7. So sánh các thuật toán\n\n| Algorithm | Graph Type | Time | Space | Negative Weight | Negative Cycle |\n|-----------|-----------|------|-------|-----------------|----------------|\n| BFS | Unweighted | O(V+E) | O(V) | N/A | N/A |\n| Dijkstra | Non-negative weight | O((V+E)logV) | O(V) | ❌ | ❌ |\n\n**Các khái niệm quan trọng:**\n- Shortest Path (Đường đi ngắn nhất) là một bài toán cơ bản và quan trọng trong lý thuyết đồ thị, nhằm tìm đường đi có tổng trọng số (hoặc số cạnh) nhỏ nhất. Bài toán này có thể tìm đường đi giữa hai đỉnh, từ một đỉnh nguồn đến tất cả các đỉnh khác, hoặc giữa mọi cặp đỉnh trong một đồ thị có trọng số. Các thuật toán phổ biến để giải quyết bài toán này bao gồm Bellman-Ford, Dijkstra và Floyd-Warshall. Bài toán Shortest Path có nhiều biến thể tùy thuộc vào loại đồ thị và yêu cầu cụ thể, và có nhiều ứng dụng thực tế.\n\n**Mối quan hệ:**\n- BFS Shortest Path giải quyết bài toán tìm đường đi ngắn nhất trong unweighted graph.\n- Dijkstra's Algorithm giải quyết bài toán tìm đường đi ngắn nhất từ nguồn đến tất cả đỉnh."
        },
        "output_without_context": {
            "question": "Trong một đồ thị có hướng không chu trình (DAG), thuật toán sắp xếp tô pô có thể được sử dụng để xác định thứ tự nào cho các đỉnh nhằm tìm đường đi ngắn nhất từ đỉnh nguồn đến các đỉnh còn lại?",
            "answer": "Thứ tự sắp xếp tô pô của các đỉnh."
        }
    }
]