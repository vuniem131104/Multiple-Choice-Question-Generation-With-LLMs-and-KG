[
    {
        "topic_description": "Chủ đề này tập trung vào khái niệm hàng đợi ưu tiên, cách thức hoạt động của nó và ứng dụng của nó trong khoa học máy tính như mô phỏng sự kiện và tối ưu hóa. Học sinh sẽ được đánh giá về hiểu biết của họ về các nguyên lý cơ bản và các ví dụ thực tế.",
        "output_with_context": {
            "question": "Hàng đợi ưu tiên (Priority Queue) là gì?",
            "answer": "Một cấu trúc dữ liệu trong đó mỗi phần tử có độ ưu tiên, phần tử có độ ưu tiên cao nhất được xử lý trước.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n**f) Size:** Trả về số lượng phần tử trong queue\n- Độ phức tạp: O(1)\n\n#### 2.3. Cài đặt Queue\n\n**Cách 1: Sử dụng mảng (Circular Queue)**\n\n```python\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = -1\n        self.rear = -1\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        if self.is_full():\n            raise Exception(\"Queue is full\")\n        \n        if self.front == -1:  # Queue rỗng\n            self.front = 0\n        \n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = item\n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.queue[self.front]\n        \n        if self.front == self.rear:  # Chỉ còn 1 phần tử\n            self.front = -1\n            self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue[self.front]\n    \n    def is_empty(self):\n        return self.front == -1\n    \n    def is_full(self):\n        return (self.rear + 1) % self.capacity == self.front\n    \n    def size(self):\n        return self.size_count\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass QueueLinkedList:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        new_node = Node(item)\n        \n        if self.rear is None:  # Queue rỗng\n            self.front = self.rear = new_node\n        else:\n            self.rear.next = new_node\n            self.rear = new_node\n        \n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.front.data\n        self.front = self.front.next\n        \n        if self.front is None:  # Queue trở nên rỗng\n            self.rear = None\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.front.data\n    \n    def is_empty(self):\n        return self.front is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 2.4. Các loại Queue đặc biệt\n\n**a) Deque (Double-ended Queue):**\nCho phép thêm và xóa phần tử ở cả hai đầu.\n\n```python\nfrom collections import deque\n\ndq = deque()\ndq.append(1)      # Thêm vào phải\ndq.appendleft(2)  # Thêm vào trái\ndq.pop()          # Xóa từ phải\ndq.popleft()      # Xóa từ trái\n```\n\n**b) Priority Queue (Hàng đợi ưu tiên):**\nMỗi phần tử có một độ ưu tiên, phần tử có độ ưu tiên cao nhất được xử lý trước.\n\n```python\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, item, priority):\n        heapq.heappush(self.heap, (priority, item))\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Priority Queue is empty\")\n        return heapq.heappop(self.heap)[1]\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 2.5. Ứng dụng của Queue\n\n**a) BFS (Breadth-First Search) trong đồ thị:**\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    \n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n- Priority Queue (Hàng đợi ưu tiên) là một cấu trúc dữ liệu trừu tượng tương tự như Queue, nhưng mỗi phần tử có một \"độ ưu tiên\" đi kèm. Các phần tử được truy xuất hoặc phục vụ theo thứ tự ưu tiên của chúng, với phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào. Nếu hai phần tử có cùng độ ưu tiên, thứ tự của chúng có thể tuân theo nguyên tắc FIFO. Priority Queue thường được cài đặt bằng Heap (Binary Heap, min-heap hoặc max-heap) để đạt hiệu suất tối ưu cho các phép toán extract min/max, mặc dù cũng có thể được cài đặt bằng BST nhưng kém hiệu quả hơn.\n\n**Mối quan hệ:**\n- Priority Queue có thể được cài đặt bằng Unsorted Array.\n- Priority Queue là một loại Queue đặc biệt xử lý phần tử theo độ ưu tiên.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n| **In-place** | ✅ | ❌ | ✅ |\n| **Cache-friendly** | ✅ | ❌ | ⚠️ |\n\n#### 6.1. Khi nào dùng Quick Sort?\n\n**Nên dùng:**\n- ✅ Mảng trong RAM (in-memory sorting)\n- ✅ Cần sorting nhanh nhất average case\n- ✅ Bộ nhớ hạn chế\n- ✅ Random access data (array)\n- ✅ Không cần stable sort\n\n**Không nên dùng:**\n- ❌ Cần đảm bảo O(n log n) worst case\n- ❌ Cần stable sorting\n- ❌ Linked list (Merge Sort tốt hơn)\n- ❌ Dữ liệu đã gần sắp xếp (trừ khi dùng random pivot)\n\n---\n\n### 7. Quick Sort trong thư viện chuẩn\n\n#### 7.1. Python's sorted() và sort()\n\nPython sử dụng **Timsort** (hybrid của Merge Sort và Insertion Sort), không phải Quick Sort, vì:\n- Stable sorting\n- Tốt với dữ liệu có pattern\n- Worst case O(n log n) đảm bảo\n\n#### 7.2. C++ std::sort()\n\nC++ sử dụng **Introsort** (Introspective Sort):\n- Bắt đầu với Quick Sort\n- Chuyển sang Heap Sort nếu đệ quy quá sâu (tránh O(n²))\n- Dùng Insertion Sort cho mảng nhỏ\n\n#### 7.3. Java's Arrays.sort()\n\n- **Primitive types:** Dual-Pivot Quick Sort\n- **Object types:** Timsort (stable)\n\n---\n\n## Priority Queue & Binary Heap\n\n### 1. Giới thiệu Priority Queue\n\n#### 1.1. Khái niệm\n\n**Priority Queue (Hàng đợi ưu tiên)** là một cấu trúc dữ liệu trừu tượng trong đó mỗi phần tử có một độ ưu tiên (priority) được gán cho nó. Phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào.\n\n**Khác với Queue thông thường:**\n- Queue thông thường: FIFO (First In First Out)\n- Priority Queue: Phần tử có priority cao nhất ra trước\n\n**Ví dụ thực tế:**\n- **Hệ thống cấp cứu:** Bệnh nhân nguy kịch được ưu tiên khám trước\n- **CPU Scheduling:** Process có priority cao được xử lý trước\n- **Dijkstra Algorithm:** Chọn đỉnh có khoảng cách nhỏ nhất\n- **A* Search:** Chọn node có f(n) nhỏ nhất\n- **Huffman Coding:** Xây dựng cây mã hóa\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Insert/Enqueue:** Thêm phần tử với priority\n**b) Extract-Max/Min:** Lấy và xóa phần tử có priority cao/thấp nhất\n**c) Peek/Top:** Xem phần tử có priority cao/thấp nhất\n**d) Change Priority:** Thay đổi priority của phần tử\n**e) Delete:** Xóa phần tử bất kỳ\n\n#### 1.3. Các cách cài đặt\n\n| Cài đặt | Insert | Extract-Max | Peek |\n|---------|--------|-------------|------|\n| Array (unsorted) | O(1) | O(n) | O(n) |\n| Array (sorted) | O(n) | O(1) | O(1) |\n| Linked List | O(n) | O(1) | O(1) |\n| **Binary Heap** | **O(log n)** | **O(log n)** | **O(1)** |\n| Fibonacci Heap | O(1) | O(log n) | O(1) |\n\n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n- Priority Queue (Hàng đợi ưu tiên) là một cấu trúc dữ liệu trừu tượng tương tự như Queue, nhưng mỗi phần tử có một \"độ ưu tiên\" đi kèm. Các phần tử được truy xuất hoặc phục vụ theo thứ tự ưu tiên của chúng, với phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào. Nếu hai phần tử có cùng độ ưu tiên, thứ tự của chúng có thể tuân theo nguyên tắc FIFO. Priority Queue thường được cài đặt bằng Heap (Binary Heap, min-heap hoặc max-heap) để đạt hiệu suất tối ưu cho các phép toán extract min/max, mặc dù cũng có thể được cài đặt bằng BST nhưng kém hiệu quả hơn.\n\n**Mối quan hệ:**\n- Priority Queue có thể được cài đặt bằng Unsorted Array.\n- Priority Queue là một loại Queue đặc biệt xử lý phần tử theo độ ưu tiên.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n| Delete | O(log n) | O(log n) avg, O(n) worst | O(n) |\n| Build | O(n) | O(n log n) | O(n log n) |\n\n**Khi nào dùng Heap?**\n- ✅ Cần extract min/max nhiều lần\n- ✅ Priority Queue\n- ✅ Tìm k largest/smallest elements\n- ✅ Median trong stream\n- ✅ Scheduling problems\n\n**Khi nào không dùng Heap?**\n- ❌ Cần search phần tử cụ thể (dùng BST)\n- ❌ Cần duyệt theo thứ tự (dùng BST)\n- ❌ Cần truy cập ngẫu nhiên (dùng array)\n\n---\n\n## Binary Search Tree \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Binary Search Tree (BST)** là một cây nhị phân có tính chất đặc biệt:\n- Tất cả các node trong cây con trái có giá trị **< node gốc**\n- Tất cả các node trong cây con phải có giá trị **> node gốc**\n- Cây con trái và cây con phải cũng là BST\n\n**Ví dụ BST hợp lệ:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  7 13\n```\n\n**Không phải BST:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  9 13    <- 9 > 8, không thể ở cây con trái\n```\n\n#### 1.2. Tính chất quan trọng\n\n**a) Duyệt Inorder cho thứ tự tăng dần:**\n- Duyệt BST theo Inorder (Left-Root-Right) cho dãy số tăng dần\n- Ví dụ trên: 1, 3, 4, 6, 7, 8, 10, 13, 14\n\n**b) Tìm kiếm hiệu quả:**\n- Có thể loại bỏ 1 nửa cây ở mỗi bước\n- Average case: O(log n)\n- Worst case: O(n) - cây thoái hóa thành linked list\n\n**c) Dynamic data structure:**\n- Dễ dàng insert và delete\n- Không cần biết trước kích thước\n\n#### 1.3. Ứng dụng\n\n- **Database indexing:** B-Tree, B+ Tree (biến thể của BST)\n- **File system:** Tổ chức thư mục\n- **Expression parsing:** Cây biểu thức\n- **Priority Queue:** Có thể implement bằng BST\n- **Auto-complete:** Trie (dạng đặc biệt của cây)\n\n---\n\n### 2. Cấu trúc Node và BST\n\n#### 2.1. Định nghĩa Node\n\n```python\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n    \n    def __repr__(self):\n        return f\"Node({self.val})\"\n```\n\n#### 2.2. Lớp BST\n\n```python\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def is_empty(self):\n        return self.root is None\n    \n    def get_root(self):\n        return self.root\n```\n\n---\n\n### 3. Các thao tác cơ bản\n\n#### 3.1. Search (Tìm kiếm)\n\n```python\n    def search(self, val):\n        \"\"\"\n        Tìm node có giá trị val\n        Time: O(h) với h là chiều cao cây\n        Average: O(log n), Worst: O(n)\n        \"\"\"\n        return self._search_recursive(self.root, val)\n    \n\n**Các khái niệm quan trọng:**\n- Priority Queue (Hàng đợi ưu tiên) là một cấu trúc dữ liệu trừu tượng tương tự như Queue, nhưng mỗi phần tử có một \"độ ưu tiên\" đi kèm. Các phần tử được truy xuất hoặc phục vụ theo thứ tự ưu tiên của chúng, với phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào. Nếu hai phần tử có cùng độ ưu tiên, thứ tự của chúng có thể tuân theo nguyên tắc FIFO. Priority Queue thường được cài đặt bằng Heap (Binary Heap, min-heap hoặc max-heap) để đạt hiệu suất tối ưu cho các phép toán extract min/max, mặc dù cũng có thể được cài đặt bằng BST nhưng kém hiệu quả hơn.\n\n**Mối quan hệ:**\n- Priority Queue là một loại Queue đặc biệt xử lý phần tử theo độ ưu tiên.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n**Binary Heap là cài đặt phổ biến nhất** vì cân bằng tốt giữa các thao tác.\n\n---\n\n### 2. Binary Heap\n\n#### 2.1. Khái niệm\n\n**Binary Heap** là một cây nhị phân hoàn chỉnh (complete binary tree) thỏa mãn tính chất heap:\n\n**Max Heap:**\n- Giá trị của mỗi node ≥ giá trị của các node con\n- Node gốc có giá trị lớn nhất\n\n**Min Heap:**\n- Giá trị của mỗi node ≤ giá trị của các node con\n- Node gốc có giá trị nhỏ nhất\n\n#### 2.2. Tính chất\n\n**a) Complete Binary Tree:**\n- Tất cả các level đều đầy, trừ level cuối\n- Level cuối được điền từ trái sang phải\n\n**b) Biểu diễn bằng mảng:**\nVới node tại index `i`:\n- Parent: `(i - 1) // 2`\n- Left child: `2 * i + 1`\n- Right child: `2 * i + 2`\n\n**Ví dụ Max Heap:**\n```\n        50\n       /  \\\n      30   40\n     / \\   /\n    10 20 35\n\nMảng: [50, 30, 40, 10, 20, 35]\nIndex: 0   1   2   3   4   5\n```\n\n#### 2.3. Ưu điểm của Binary Heap\n\n- ✅ Không cần con trỏ (dùng mảng)\n- ✅ Cache-friendly (truy cập liên tiếp)\n- ✅ Cân bằng tự động\n- ✅ Dễ cài đặt\n- ✅ Hiệu quả: O(log n) cho insert và extract\n\n---\n\n### 3. Cài đặt Min Heap\n\n#### 3.1. Cấu trúc cơ bản\n\n```python\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n    \n    def parent(self, i):\n        return (i - 1) // 2\n    \n    def left_child(self, i):\n        return 2 * i + 1\n    \n    def right_child(self, i):\n        return 2 * i + 2\n    \n    def has_left_child(self, i):\n        return self.left_child(i) < len(self.heap)\n    \n    def has_right_child(self, i):\n        return self.right_child(i) < len(self.heap)\n    \n    def has_parent(self, i):\n        return self.parent(i) >= 0\n    \n    def swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n    \n    def size(self):\n        return len(self.heap)\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 3.2. Heapify Up (Bubble Up)\n\nDùng khi insert phần tử mới vào cuối heap.\n\n```python\n    def heapify_up(self, i):\n        \"\"\"\n        Di chuyển phần tử lên trên cho đến khi thỏa mãn heap property\n        \"\"\"\n        while self.has_parent(i) and self.heap[i] < self.heap[self.parent(i)]:\n            self.swap(i, self.parent(i))\n            i = self.parent(i)\n```\n\n**Minh họa:**\n```\nThêm 5 vào heap:\n\nBước 1: Thêm vào cuối\n      10\n     /  \\\n    20  15\n   / \\  /\n  30 25 5*  <- Thêm ở đây\n\nBước 2: So sánh với parent (15), swap\n      10\n     /  \\\n    20  5*\n   / \\  /\n  30 25 15\n\nBước 3: So sánh với parent (10), swap\n      5*\n     /  \\\n    20  10\n   / \\  /\n  30 25 15\n```\n\n#### 3.3. Heapify Down (Bubble Down)\n\n\n**Các khái niệm quan trọng:**\n- Priority Queue (Hàng đợi ưu tiên) là một cấu trúc dữ liệu trừu tượng tương tự như Queue, nhưng mỗi phần tử có một \"độ ưu tiên\" đi kèm. Các phần tử được truy xuất hoặc phục vụ theo thứ tự ưu tiên của chúng, với phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào. Nếu hai phần tử có cùng độ ưu tiên, thứ tự của chúng có thể tuân theo nguyên tắc FIFO. Priority Queue thường được cài đặt bằng Heap (Binary Heap, min-heap hoặc max-heap) để đạt hiệu suất tối ưu cho các phép toán extract min/max, mặc dù cũng có thể được cài đặt bằng BST nhưng kém hiệu quả hơn.\n\n**Mối quan hệ:**\n- Priority Queue có thể được cài đặt bằng Unsorted Array.\n- Priority Queue là một loại Queue đặc biệt xử lý phần tử theo độ ưu tiên.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return result\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\nprint(bfs(graph, 'A'))  # ['A', 'B', 'C', 'D', 'E', 'F']\n```\n\n**b) Quản lý tài nguyên chia sẻ:**\n- CPU scheduling\n- Disk scheduling\n- Printer queue\n\n**c) Xử lý bất đồng bộ:**\n- Message queue trong các hệ thống phân tán\n- Event handling trong GUI\n\n**d) Cache implementation:**\n- LRU (Least Recently Used) cache sử dụng kết hợp queue và hash map\n\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n```\n\n#### 2.6. So sánh Stack và Queue\n\n| Đặc điểm | Stack | Queue |\n|----------|-------|-------|\n| Nguyên tắc | LIFO | FIFO |\n| Thao tác chính | Push, Pop | Enqueue, Dequeue |\n| Truy cập | Chỉ ở đỉnh (top) | Ở đầu (front) và cuối (rear) |\n| Ứng dụng | Backtracking, Expression evaluation | BFS, Scheduling |\n| Cài đặt | Array, Linked List | Array (Circular), Linked List |\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n\n**Mối quan hệ:**\n- Priority Queue là một loại Queue đặc biệt xử lý phần tử theo độ ưu tiên."
        },
        "output_without_context": {
            "question": "Hàng đợi ưu tiên là gì trong khoa học máy tính?",
            "answer": "Một cấu trúc dữ liệu cho phép truy cập các phần tử theo thứ tự ưu tiên, không theo thứ tự thêm vào."
        }
    },
    {
        "topic_description": "Chủ đề này khám phá các phương thức và công thức của API hàng đợi ưu tiên trong Java, bao gồm cách tạo và sử dụng các hàng đợi ưu tiên. Kiến thức về các phép toán như delMax() và insert() sẽ được kiểm tra.",
        "output_with_context": {
            "question": "Trong API hàng đợi ưu tiên trong Java, phép toán nào được sử dụng để thêm một phần tử mới vào hàng đợi?",
            "answer": "insert()",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n| **In-place** | ✅ | ❌ | ✅ |\n| **Cache-friendly** | ✅ | ❌ | ⚠️ |\n\n#### 6.1. Khi nào dùng Quick Sort?\n\n**Nên dùng:**\n- ✅ Mảng trong RAM (in-memory sorting)\n- ✅ Cần sorting nhanh nhất average case\n- ✅ Bộ nhớ hạn chế\n- ✅ Random access data (array)\n- ✅ Không cần stable sort\n\n**Không nên dùng:**\n- ❌ Cần đảm bảo O(n log n) worst case\n- ❌ Cần stable sorting\n- ❌ Linked list (Merge Sort tốt hơn)\n- ❌ Dữ liệu đã gần sắp xếp (trừ khi dùng random pivot)\n\n---\n\n### 7. Quick Sort trong thư viện chuẩn\n\n#### 7.1. Python's sorted() và sort()\n\nPython sử dụng **Timsort** (hybrid của Merge Sort và Insertion Sort), không phải Quick Sort, vì:\n- Stable sorting\n- Tốt với dữ liệu có pattern\n- Worst case O(n log n) đảm bảo\n\n#### 7.2. C++ std::sort()\n\nC++ sử dụng **Introsort** (Introspective Sort):\n- Bắt đầu với Quick Sort\n- Chuyển sang Heap Sort nếu đệ quy quá sâu (tránh O(n²))\n- Dùng Insertion Sort cho mảng nhỏ\n\n#### 7.3. Java's Arrays.sort()\n\n- **Primitive types:** Dual-Pivot Quick Sort\n- **Object types:** Timsort (stable)\n\n---\n\n## Priority Queue & Binary Heap\n\n### 1. Giới thiệu Priority Queue\n\n#### 1.1. Khái niệm\n\n**Priority Queue (Hàng đợi ưu tiên)** là một cấu trúc dữ liệu trừu tượng trong đó mỗi phần tử có một độ ưu tiên (priority) được gán cho nó. Phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào.\n\n**Khác với Queue thông thường:**\n- Queue thông thường: FIFO (First In First Out)\n- Priority Queue: Phần tử có priority cao nhất ra trước\n\n**Ví dụ thực tế:**\n- **Hệ thống cấp cứu:** Bệnh nhân nguy kịch được ưu tiên khám trước\n- **CPU Scheduling:** Process có priority cao được xử lý trước\n- **Dijkstra Algorithm:** Chọn đỉnh có khoảng cách nhỏ nhất\n- **A* Search:** Chọn node có f(n) nhỏ nhất\n- **Huffman Coding:** Xây dựng cây mã hóa\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Insert/Enqueue:** Thêm phần tử với priority\n**b) Extract-Max/Min:** Lấy và xóa phần tử có priority cao/thấp nhất\n**c) Peek/Top:** Xem phần tử có priority cao/thấp nhất\n**d) Change Priority:** Thay đổi priority của phần tử\n**e) Delete:** Xóa phần tử bất kỳ\n\n#### 1.3. Các cách cài đặt\n\n| Cài đặt | Insert | Extract-Max | Peek |\n|---------|--------|-------------|------|\n| Array (unsorted) | O(1) | O(n) | O(n) |\n| Array (sorted) | O(n) | O(1) | O(1) |\n| Linked List | O(n) | O(1) | O(1) |\n| **Binary Heap** | **O(log n)** | **O(log n)** | **O(1)** |\n| Fibonacci Heap | O(1) | O(log n) | O(1) |\n\n\n**Các khái niệm quan trọng:**\n- Linked List cũng có thể được sử dụng để cài đặt Priority Queue. Tùy thuộc vào cách duy trì thứ tự, Insert có thể là O(n) và Extract-Max/Min là O(1) (nếu danh sách được sắp xếp theo ưu tiên) hoặc ngược lại.\n- Priority Queue có thể được cài đặt bằng Unsorted Array hoặc Sorted Array. Với Unsorted Array, phép toán Insert có độ phức tạp O(1) do chỉ cần thêm vào cuối mảng, nhưng Extract-Max/Min và Peek có độ phức tạp O(n) vì yêu cầu duyệt toàn bộ mảng. Ngược lại, với Sorted Array, phép toán Insert có độ phức tạp O(n) để duy trì thứ tự, nhưng Extract-Max/Min và Peek có độ phức tạp O(1) do phần tử ưu tiên cao nhất/thấp nhất nằm ở đầu hoặc cuối mảng.\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n\n**Mối quan hệ:**\n- Phép toán Insert trên Sorted Array (khi dùng làm Priority Queue) có độ phức tạp O(n).\n- Phép toán Extract Min/Max trên Sorted Array có độ phức tạp O(1).\n- Phép toán Insert trên Linked List (khi dùng làm Priority Queue) có độ phức tạp O(n).\n- Priority Queue có thể được cài đặt bằng Linked List.\n- Priority Queue là một loại Queue đặc biệt xử lý phần tử theo độ ưu tiên.\n- Priority Queue có thể được cài đặt bằng Sorted Array.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return result\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\nprint(bfs(graph, 'A'))  # ['A', 'B', 'C', 'D', 'E', 'F']\n```\n\n**b) Quản lý tài nguyên chia sẻ:**\n- CPU scheduling\n- Disk scheduling\n- Printer queue\n\n**c) Xử lý bất đồng bộ:**\n- Message queue trong các hệ thống phân tán\n- Event handling trong GUI\n\n**d) Cache implementation:**\n- LRU (Least Recently Used) cache sử dụng kết hợp queue và hash map\n\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n```\n\n#### 2.6. So sánh Stack và Queue\n\n| Đặc điểm | Stack | Queue |\n|----------|-------|-------|\n| Nguyên tắc | LIFO | FIFO |\n| Thao tác chính | Push, Pop | Enqueue, Dequeue |\n| Truy cập | Chỉ ở đỉnh (top) | Ở đầu (front) và cuối (rear) |\n| Ứng dụng | Backtracking, Expression evaluation | BFS, Scheduling |\n| Cài đặt | Array, Linked List | Array (Circular), Linked List |\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n\n**Mối quan hệ:**\n- Priority Queue là một loại Queue đặc biệt xử lý phần tử theo độ ưu tiên.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n**f) Size:** Trả về số lượng phần tử trong queue\n- Độ phức tạp: O(1)\n\n#### 2.3. Cài đặt Queue\n\n**Cách 1: Sử dụng mảng (Circular Queue)**\n\n```python\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = -1\n        self.rear = -1\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        if self.is_full():\n            raise Exception(\"Queue is full\")\n        \n        if self.front == -1:  # Queue rỗng\n            self.front = 0\n        \n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = item\n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.queue[self.front]\n        \n        if self.front == self.rear:  # Chỉ còn 1 phần tử\n            self.front = -1\n            self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue[self.front]\n    \n    def is_empty(self):\n        return self.front == -1\n    \n    def is_full(self):\n        return (self.rear + 1) % self.capacity == self.front\n    \n    def size(self):\n        return self.size_count\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass QueueLinkedList:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        new_node = Node(item)\n        \n        if self.rear is None:  # Queue rỗng\n            self.front = self.rear = new_node\n        else:\n            self.rear.next = new_node\n            self.rear = new_node\n        \n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.front.data\n        self.front = self.front.next\n        \n        if self.front is None:  # Queue trở nên rỗng\n            self.rear = None\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.front.data\n    \n    def is_empty(self):\n        return self.front is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 2.4. Các loại Queue đặc biệt\n\n**a) Deque (Double-ended Queue):**\nCho phép thêm và xóa phần tử ở cả hai đầu.\n\n```python\nfrom collections import deque\n\ndq = deque()\ndq.append(1)      # Thêm vào phải\ndq.appendleft(2)  # Thêm vào trái\ndq.pop()          # Xóa từ phải\ndq.popleft()      # Xóa từ trái\n```\n\n**b) Priority Queue (Hàng đợi ưu tiên):**\nMỗi phần tử có một độ ưu tiên, phần tử có độ ưu tiên cao nhất được xử lý trước.\n\n```python\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, item, priority):\n        heapq.heappush(self.heap, (priority, item))\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Priority Queue is empty\")\n        return heapq.heappop(self.heap)[1]\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 2.5. Ứng dụng của Queue\n\n**a) BFS (Breadth-First Search) trong đồ thị:**\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    \n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n- `heapq` là một module trong thư viện chuẩn của Python, cung cấp cài đặt hiệu quả của cấu trúc dữ liệu hàng đợi ưu tiên (priority queue) dựa trên thuật toán heap, cụ thể là min-heap (heap nhị phân). Nó cho phép các phần tử nhỏ nhất luôn được truy cập nhanh chóng. Module này hỗ trợ nhiều phép toán trên heap như `heappush` (thêm phần tử), `heappop` (lấy và loại bỏ phần tử nhỏ nhất), `heapify` (chuyển đổi một danh sách thành heap), `heapreplace` (thay thế phần tử nhỏ nhất), `nsmallest`, và `nlargest`. Các phép toán `heappush` và `heappop` có độ phức tạp thời gian logarit (O(log k) hoặc O(log n), với k hoặc n là số phần tử trong heap). Mặc dù là min-heap, nó có thể được sử dụng để mô phỏng max-heap bằng cách lưu trữ các giá trị âm. `heapq` được ứng dụng rộng rãi trong các thuật toán như A* (để lưu trữ các đỉnh cần khám phá, ưu tiên các đỉnh có f_score thấp nhất), Dijkstra (để lưu trữ các cặp (khoảng cách, đỉnh) và luôn lấy ra đỉnh có khoảng cách nhỏ nhất), K-way Merge, External Sorting (để gộp nhiều luồng dữ liệu đã sắp xếp), và quản lý các phần tử từ các file tạm trong quá trình merge.\n\n**Mối quan hệ:**\n- Module heapq trong Python được sử dụng để cài đặt Priority Queue.\n- Module heapq của Python cài đặt cấu trúc dữ liệu Min Heap.\n- Priority Queue là một loại Queue đặc biệt xử lý phần tử theo độ ưu tiên."
        },
        "output_without_context": {
            "question": "Trong API hàng đợi ưu tiên của Java, phương thức nào được sử dụng để chèn một phần tử vào hàng đợi?",
            "answer": "insert()"
        }
    },
    {
        "topic_description": "Chủ đề này sẽ yêu cầu học sinh nắm bắt cách thức hoạt động của heap nhị phân, từ cách biểu diễn đến thuộc tính của nó. Học sinh cần phải hiểu được cách xếp hạng các nút trong heap và các thao tác cơ bản liên quan đến nó.",
        "output_with_context": {
            "question": "Trong một heap nhị phân, thao tác nào được sử dụng để đảm bảo rằng tính chất heap được duy trì sau khi thêm một phần tử mới?",
            "answer": "Heapify up",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n        if len(self.min_heap) > len(self.max_heap):\n            val = heapq.heappop(self.min_heap)\n            heapq.heappush(self.max_heap, -val)\n    \n    def find_median(self):\n        \"\"\"Time: O(1)\"\"\"\n        if len(self.max_heap) > len(self.min_heap):\n            return -self.max_heap[0]\n        return (-self.max_heap[0] + self.min_heap[0]) / 2\n\n# Test\nmf = MedianFinder()\nstream = [5, 15, 1, 3, 8]\nfor num in stream:\n    mf.add_num(num)\n    print(f\"Added {num}, Median: {mf.find_median()}\")\n```\n\n#### 6.5. Task Scheduler\n\n```python\nimport heapq\nfrom collections import Counter, deque\n\ndef least_interval(tasks, n):\n    \"\"\"\n    Lập lịch task với cooling time\n    Time: O(N) với N là số task\n    \"\"\"\n    # Đếm số lần xuất hiện của mỗi task\n    task_counts = Counter(tasks)\n    \n    # Max heap để chọn task có count lớn nhất\n    max_heap = [-count for count in task_counts.values()]\n    heapq.heapify(max_heap)\n    \n    time = 0\n    queue = deque()  # (count, available_time)\n    \n    while max_heap or queue:\n        time += 1\n        \n        if max_heap:\n            count = -heapq.heappop(max_heap)\n            count -= 1\n            \n            if count > 0:\n                # Task này cần làm lại, thêm vào queue\n                queue.append((count, time + n))\n        \n        # Kiểm tra task nào đã sẵn sàng\n        if queue and queue[0][1] == time:\n            count, _ = queue.popleft()\n            heapq.heappush(max_heap, -count)\n    \n    return time\n\n# Test\ntasks = ['A', 'A', 'A', 'B', 'B', 'B']\nn = 2  # Cooling time\nprint(f\"Minimum intervals: {least_interval(tasks, n)}\")\n```\n\n---\n\n### 7. Python heapq Module\n\nPython cung cấp module `heapq` cho Min Heap:\n\n```python\nimport heapq\n\n# Tạo heap\nheap = []\n\n# Thêm phần tử\nheapq.heappush(heap, 5)\nheapq.heappush(heap, 3)\nheapq.heappush(heap, 8)\nprint(\"Heap:\", heap)  # [3, 5, 8]\n\n# Lấy min\nmin_val = heapq.heappop(heap)\nprint(\"Min:\", min_val)  # 3\n\n# Build heap từ list\narr = [5, 7, 9, 1, 3]\nheapq.heapify(arr)\nprint(\"Heapified:\", arr)  # [1, 3, 9, 7, 5]\n\n# N smallest/largest\narr = [3, 2, 1, 5, 6, 4]\nprint(\"3 smallest:\", heapq.nsmallest(3, arr))  # [1, 2, 3]\nprint(\"3 largest:\", heapq.nlargest(3, arr))    # [6, 5, 4]\n\n# Replace (pop và push trong 1 operation)\nheapq.heapreplace(heap, 10)\n\n# Push và pop\nheapq.heappushpop(heap, 2)\n\n# Max Heap trick (dùng số âm)\nmax_heap = []\nheapq.heappush(max_heap, -5)\nheapq.heappush(max_heap, -3)\nheapq.heappush(max_heap, -8)\nmax_val = -heapq.heappop(max_heap)\nprint(\"Max:\", max_val)  # 8\n```\n\n---\n\n### 8. So sánh độ phức tạp\n\n| Thao tác | Min/Max Heap | Binary Search Tree | Sorted Array |\n|----------|--------------|-------------------|--------------|\n| Insert | O(log n) | O(log n) avg, O(n) worst | O(n) |\n| Extract Min/Max | O(log n) | O(log n) avg, O(n) worst | O(1) |\n| Peek | O(1) | O(log n) avg, O(n) worst | O(1) |\n| Search | O(n) | O(log n) avg, O(n) worst | O(log n) |\n\n**Các khái niệm quan trọng:**\n- heapify là một phép toán/thuật toán có hai ứng dụng chính: chuyển đổi một danh sách thành một heap tại chỗ với độ phức tạp thời gian O(n), và duy trì tính chất heap của một cây nhị phân. Khi một phần tử bị thay đổi, thêm hoặc bớt, heapify sẽ điều chỉnh vị trí của phần tử đó bằng cách hoán đổi với con lớn nhất (hoặc nhỏ nhất) của nó cho đến khi tính chất heap được khôi phục, với độ phức tạp thời gian O(log n) cho một lần điều chỉnh.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\nDùng khi extract phần tử root.\n\n```python\n    def heapify_down(self, i):\n        \"\"\"\n        Di chuyển phần tử xuống dưới cho đến khi thỏa mãn heap property\n        \"\"\"\n        while self.has_left_child(i):\n            # Tìm con nhỏ hơn\n            smaller_child_index = self.left_child(i)\n            \n            if (self.has_right_child(i) and \n                self.heap[self.right_child(i)] < self.heap[smaller_child_index]):\n                smaller_child_index = self.right_child(i)\n            \n            # Nếu phần tử hiện tại nhỏ hơn cả 2 con, dừng\n            if self.heap[i] <= self.heap[smaller_child_index]:\n                break\n            \n            # Swap với con nhỏ hơn\n            self.swap(i, smaller_child_index)\n            i = smaller_child_index\n```\n\n**Minh họa:**\n```\nExtract min (5):\n\nBước 1: Thay thế root bằng phần tử cuối\n      15*\n     /  \\\n    20  10\n   / \\\n  30 25\n\nBước 2: Heapify down, swap với 10\n      10\n     /  \\\n    20  15*\n   / \\\n  30 25\n\nDừng: 15 < 30 và 15 < 25 (không có con phải)\n```\n\n#### 3.4. Insert (Thêm phần tử)\n\n```python\n    def insert(self, value):\n        \"\"\"\n        Thêm phần tử vào heap\n        Time Complexity: O(log n)\n        \"\"\"\n        # Thêm vào cuối\n        self.heap.append(value)\n        # Heapify up\n        self.heapify_up(len(self.heap) - 1)\n```\n\n#### 3.5. Extract Min (Lấy phần tử nhỏ nhất)\n\n```python\n    def extract_min(self):\n        \"\"\"\n        Lấy và xóa phần tử nhỏ nhất\n        Time Complexity: O(log n)\n        \"\"\"\n        if self.is_empty():\n            raise Exception(\"Heap is empty\")\n        \n        # Lấy phần tử root\n        min_value = self.heap[0]\n        \n        # Thay thế root bằng phần tử cuối\n        self.heap[0] = self.heap[-1]\n        self.heap.pop()\n        \n        # Heapify down nếu heap không rỗng\n        if not self.is_empty():\n            self.heapify_down(0)\n        \n        return min_value\n```\n\n#### 3.6. Peek (Xem phần tử nhỏ nhất)\n\n```python\n    def peek(self):\n        \"\"\"\n        Xem phần tử nhỏ nhất mà không xóa\n        Time Complexity: O(1)\n        \"\"\"\n        if self.is_empty():\n            raise Exception(\"Heap is empty\")\n        return self.heap[0]\n```\n\n#### 3.7. Build Heap (Xây dựng heap từ mảng)\n\n```python\n    def build_heap(self, arr):\n        \"\"\"\n        Xây dựng heap từ mảng cho trước\n        Time Complexity: O(n)\n        \"\"\"\n        self.heap = arr.copy()\n        \n        # Heapify từ node cuối cùng có con (từ dưới lên trên)\n        for i in range(len(self.heap) // 2 - 1, -1, -1):\n            self.heapify_down(i)\n```\n\n**Tại sao O(n) chứ không phải O(n log n)?**\n- Các node ở level cuối không cần heapify\n- Các node gần root có ít hơn, nhưng chi phí heapify cao hơn\n- Tổng chi phí: Σ(h * nodes_at_level_h) ≈ O(n)\n\n---\n\n### 4. Cài đặt Max Heap\n\n```python\nclass MaxHeap:\n    def __init__(self):\n        self.heap = []\n    \n    def parent(self, i):\n        return (i - 1) // 2\n    \n    def left_child(self, i):\n        return 2 * i + 1\n    \n    def right_child(self, i):\n        return 2 * i + 2\n    \n    def swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n    \n    def heapify_up(self, i):\n\n**Các khái niệm quan trọng:**\n- Build Heap là một kỹ thuật hoặc thuật toán được sử dụng để xây dựng một Binary Heap (ví dụ: Max Heap) từ một mảng các phần tử không có thứ tự cho trước. Quá trình này bao gồm việc sao chép mảng vào cấu trúc heap và sau đó duyệt từ phần tử không phải lá cuối cùng (tại chỉ số n/2 - 1) ngược về gốc (chỉ số 0), gọi hàm heapify_down cho mỗi phần tử để sắp xếp lại chúng và đảm bảo thỏa mãn tính chất heap. Độ phức tạp thời gian của thuật toán Build Heap là O(n).\n\n**Mối quan hệ:**\n- Heap Sort bắt đầu bằng cách sử dụng kỹ thuật Build Heap để tạo ra một Max Heap từ mảng đầu vào.\n- Build Heap sử dụng thuật toán heapify_down lặp lại từ các node không phải lá để xây dựng heap.\n- Build Heap có độ phức tạp thời gian O(n) để xây dựng heap từ một mảng cho trước.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n        \"\"\"Max Heap: parent phải lớn hơn con\"\"\"\n        while i > 0 and self.heap[i] > self.heap[self.parent(i)]:\n            self.swap(i, self.parent(i))\n            i = self.parent(i)\n    \n    def heapify_down(self, i):\n        \"\"\"Max Heap: parent phải lớn hơn con\"\"\"\n        while self.left_child(i) < len(self.heap):\n            larger_child = self.left_child(i)\n            \n            if (self.right_child(i) < len(self.heap) and\n                self.heap[self.right_child(i)] > self.heap[larger_child]):\n                larger_child = self.right_child(i)\n            \n            if self.heap[i] >= self.heap[larger_child]:\n                break\n            \n            self.swap(i, larger_child)\n            i = larger_child\n    \n    def insert(self, value):\n        self.heap.append(value)\n        self.heapify_up(len(self.heap) - 1)\n    \n    def extract_max(self):\n        if not self.heap:\n            raise Exception(\"Heap is empty\")\n        \n        max_value = self.heap[0]\n        self.heap[0] = self.heap[-1]\n        self.heap.pop()\n        \n        if self.heap:\n            self.heapify_down(0)\n        \n        return max_value\n    \n    def peek(self):\n        if not self.heap:\n            raise Exception(\"Heap is empty\")\n        return self.heap[0]\n```\n\n---\n\n### 5. Test và Demo\n\n```python\n# Test Min Heap\nprint(\"=== MIN HEAP ===\")\nmin_heap = MinHeap()\n\n# Insert elements\nelements = [5, 3, 8, 1, 9, 2, 7]\nprint(f\"Inserting: {elements}\")\nfor elem in elements:\n    min_heap.insert(elem)\n    print(f\"After inserting {elem}: {min_heap.heap}\")\n\nprint(f\"\nMin element (peek): {min_heap.peek()}\")\n\n# Extract min\nprint(\"\nExtracting min elements:\")\nwhile not min_heap.is_empty():\n    min_val = min_heap.extract_min()\n    print(f\"Extracted: {min_val}, Remaining: {min_heap.heap}\")\n\n# Test Max Heap\nprint(\"\n=== MAX HEAP ===\")\nmax_heap = MaxHeap()\n\nprint(f\"Inserting: {elements}\")\nfor elem in elements:\n    max_heap.insert(elem)\n    print(f\"After inserting {elem}: {max_heap.heap}\")\n\nprint(f\"\nMax element (peek): {max_heap.peek()}\")\n\n# Extract max\nprint(\"\nExtracting max elements:\")\nwhile max_heap.heap:\n    max_val = max_heap.extract_max()\n    print(f\"Extracted: {max_val}, Remaining: {max_heap.heap}\")\n\n# Test Build Heap\nprint(\"\n=== BUILD HEAP ===\")\narr = [9, 5, 6, 2, 3, 7, 1, 4, 8]\nprint(f\"Original array: {arr}\")\n\nmin_heap2 = MinHeap()\nmin_heap2.build_heap(arr)\nprint(f\"Min Heap: {min_heap2.heap}\")\n\nmax_heap2 = MaxHeap()\nmax_heap2.heap = arr.copy()\nfor i in range(len(max_heap2.heap) // 2 - 1, -1, -1):\n    max_heap2.heapify_down(i)\nprint(f\"Max Heap: {max_heap2.heap}\")\n```\n\n---\n\n### 6. Ứng dụng thực tế\n\n#### 6.1. Heap Sort\n\n```python\ndef heap_sort(arr):\n    \"\"\"\n    Sắp xếp mảng sử dụng heap\n    Time Complexity: O(n log n)\n    Space Complexity: O(1) - in-place\n    \"\"\"\n    n = len(arr)\n    \n    # Build max heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements one by one\n    for i in range(n - 1, 0, -1):\n        # Swap root (max) với phần tử cuối\n        arr[0], arr[i] = arr[i], arr[0]\n        # Heapify root với heap size giảm dần\n        heapify(arr, i, 0)\n    \n    return arr\n\ndef heapify(arr, n, i):\n    \"\"\"Heapify subtree rooted at index i\"\"\"\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n\n**Các khái niệm quan trọng:**\n- Heap property là tính chất cơ bản của một Binary Heap, quy định mối quan hệ giá trị giữa node cha và các node con. Đối với Min Heap, giá trị của mỗi node cha phải nhỏ hơn hoặc bằng giá trị của tất cả các node con của nó, đảm bảo phần tử nhỏ nhất luôn nằm ở gốc. Đối với Max Heap, giá trị của mỗi node cha phải lớn hơn hoặc bằng giá trị của tất cả các node con của nó, đảm bảo phần tử lớn nhất luôn nằm ở gốc. Tính chất này phải được duy trì sau mỗi phép toán thêm hoặc xóa phần tử.\n- Build Heap là một kỹ thuật hoặc thuật toán được sử dụng để xây dựng một Binary Heap (ví dụ: Max Heap) từ một mảng các phần tử không có thứ tự cho trước. Quá trình này bao gồm việc sao chép mảng vào cấu trúc heap và sau đó duyệt từ phần tử không phải lá cuối cùng (tại chỉ số n/2 - 1) ngược về gốc (chỉ số 0), gọi hàm heapify_down cho mỗi phần tử để sắp xếp lại chúng và đảm bảo thỏa mãn tính chất heap. Độ phức tạp thời gian của thuật toán Build Heap là O(n).\n\n**Mối quan hệ:**\n- heapify_down đảm bảo tính chất Max Heap được duy trì sau khi loại bỏ hoặc thay đổi phần tử gốc.\n- heapify_up đảm bảo tính chất Max Heap được duy trì sau khi thêm phần tử.\n- Heap Sort bắt đầu bằng cách sử dụng kỹ thuật Build Heap để tạo ra một Max Heap từ mảng đầu vào.\n- Build Heap có độ phức tạp thời gian O(n) để xây dựng heap từ một mảng cho trước.\n- Build Heap sử dụng thuật toán heapify_down lặp lại từ các node không phải lá để xây dựng heap.\n- Max Heap có tính chất Heap Property (Max Heap) là node cha lớn hơn hoặc bằng con."
        },
        "output_without_context": {
            "question": "Trong heap nhị phân, thuộc tính nào đảm bảo rằng mỗi nút cha có giá trị lớn hơn hoặc bằng (đối với max heap) hoặc nhỏ hơn hoặc bằng (đối với min heap) giá trị của các nút con?",
            "answer": "Thuộc tính heap."
        }
    },
    {
        "topic_description": "Chủ đề này phân tích quy trình chèn và xóa mục tối đa trong heap nhị phân. Học sinh sẽ được yêu cầu mô tả các bước và cách hoạt động của việc 'bơi lên' và 'chìm xuống' để duy trì tính chính xác của heap.",
        "output_with_context": {
            "question": "Khi chèn một phần tử vào heap nhị phân, thuật toán nào được sử dụng để đảm bảo tính chất heap được duy trì?",
            "answer": "heapify_up",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n        if len(self.min_heap) > len(self.max_heap):\n            val = heapq.heappop(self.min_heap)\n            heapq.heappush(self.max_heap, -val)\n    \n    def find_median(self):\n        \"\"\"Time: O(1)\"\"\"\n        if len(self.max_heap) > len(self.min_heap):\n            return -self.max_heap[0]\n        return (-self.max_heap[0] + self.min_heap[0]) / 2\n\n# Test\nmf = MedianFinder()\nstream = [5, 15, 1, 3, 8]\nfor num in stream:\n    mf.add_num(num)\n    print(f\"Added {num}, Median: {mf.find_median()}\")\n```\n\n#### 6.5. Task Scheduler\n\n```python\nimport heapq\nfrom collections import Counter, deque\n\ndef least_interval(tasks, n):\n    \"\"\"\n    Lập lịch task với cooling time\n    Time: O(N) với N là số task\n    \"\"\"\n    # Đếm số lần xuất hiện của mỗi task\n    task_counts = Counter(tasks)\n    \n    # Max heap để chọn task có count lớn nhất\n    max_heap = [-count for count in task_counts.values()]\n    heapq.heapify(max_heap)\n    \n    time = 0\n    queue = deque()  # (count, available_time)\n    \n    while max_heap or queue:\n        time += 1\n        \n        if max_heap:\n            count = -heapq.heappop(max_heap)\n            count -= 1\n            \n            if count > 0:\n                # Task này cần làm lại, thêm vào queue\n                queue.append((count, time + n))\n        \n        # Kiểm tra task nào đã sẵn sàng\n        if queue and queue[0][1] == time:\n            count, _ = queue.popleft()\n            heapq.heappush(max_heap, -count)\n    \n    return time\n\n# Test\ntasks = ['A', 'A', 'A', 'B', 'B', 'B']\nn = 2  # Cooling time\nprint(f\"Minimum intervals: {least_interval(tasks, n)}\")\n```\n\n---\n\n### 7. Python heapq Module\n\nPython cung cấp module `heapq` cho Min Heap:\n\n```python\nimport heapq\n\n# Tạo heap\nheap = []\n\n# Thêm phần tử\nheapq.heappush(heap, 5)\nheapq.heappush(heap, 3)\nheapq.heappush(heap, 8)\nprint(\"Heap:\", heap)  # [3, 5, 8]\n\n# Lấy min\nmin_val = heapq.heappop(heap)\nprint(\"Min:\", min_val)  # 3\n\n# Build heap từ list\narr = [5, 7, 9, 1, 3]\nheapq.heapify(arr)\nprint(\"Heapified:\", arr)  # [1, 3, 9, 7, 5]\n\n# N smallest/largest\narr = [3, 2, 1, 5, 6, 4]\nprint(\"3 smallest:\", heapq.nsmallest(3, arr))  # [1, 2, 3]\nprint(\"3 largest:\", heapq.nlargest(3, arr))    # [6, 5, 4]\n\n# Replace (pop và push trong 1 operation)\nheapq.heapreplace(heap, 10)\n\n# Push và pop\nheapq.heappushpop(heap, 2)\n\n# Max Heap trick (dùng số âm)\nmax_heap = []\nheapq.heappush(max_heap, -5)\nheapq.heappush(max_heap, -3)\nheapq.heappush(max_heap, -8)\nmax_val = -heapq.heappop(max_heap)\nprint(\"Max:\", max_val)  # 8\n```\n\n---\n\n### 8. So sánh độ phức tạp\n\n| Thao tác | Min/Max Heap | Binary Search Tree | Sorted Array |\n|----------|--------------|-------------------|--------------|\n| Insert | O(log n) | O(log n) avg, O(n) worst | O(n) |\n| Extract Min/Max | O(log n) | O(log n) avg, O(n) worst | O(1) |\n| Peek | O(1) | O(log n) avg, O(n) worst | O(1) |\n| Search | O(n) | O(log n) avg, O(n) worst | O(log n) |\n\n**Các khái niệm quan trọng:**\n- heapify là một phép toán/thuật toán có hai ứng dụng chính: chuyển đổi một danh sách thành một heap tại chỗ với độ phức tạp thời gian O(n), và duy trì tính chất heap của một cây nhị phân. Khi một phần tử bị thay đổi, thêm hoặc bớt, heapify sẽ điều chỉnh vị trí của phần tử đó bằng cách hoán đổi với con lớn nhất (hoặc nhỏ nhất) của nó cho đến khi tính chất heap được khôi phục, với độ phức tạp thời gian O(log n) cho một lần điều chỉnh.\n- heappush là phép toán thêm một phần tử mới vào cấu trúc dữ liệu heap (cụ thể là min-heap), duy trì tính chất heap (phần tử cha luôn nhỏ hơn hoặc bằng các phần tử con). Độ phức tạp thời gian của nó là O(log k), với k là số phần tử trong heap. heappop là phép toán loại bỏ và trả về phần tử nhỏ nhất (gốc của heap) từ heap, đồng thời duy trì tính chất heap. Độ phức tạp thời gian của nó cũng là O(log k). heapreplace là phép toán loại bỏ phần tử nhỏ nhất từ heap và thêm một phần tử mới vào, sau đó duy trì tính chất heap; nó hiệu quả hơn việc thực hiện heappop rồi heappush. heappushpop là phép toán thêm một phần tử vào heap, sau đó loại bỏ và trả về phần tử nhỏ nhất; nó hiệu quả hơn việc thực hiện heappush rồi heappop. Cả heapreplace và heappushpop đều có độ phức tạp thời gian là O(log n).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n        \"\"\"Max Heap: parent phải lớn hơn con\"\"\"\n        while i > 0 and self.heap[i] > self.heap[self.parent(i)]:\n            self.swap(i, self.parent(i))\n            i = self.parent(i)\n    \n    def heapify_down(self, i):\n        \"\"\"Max Heap: parent phải lớn hơn con\"\"\"\n        while self.left_child(i) < len(self.heap):\n            larger_child = self.left_child(i)\n            \n            if (self.right_child(i) < len(self.heap) and\n                self.heap[self.right_child(i)] > self.heap[larger_child]):\n                larger_child = self.right_child(i)\n            \n            if self.heap[i] >= self.heap[larger_child]:\n                break\n            \n            self.swap(i, larger_child)\n            i = larger_child\n    \n    def insert(self, value):\n        self.heap.append(value)\n        self.heapify_up(len(self.heap) - 1)\n    \n    def extract_max(self):\n        if not self.heap:\n            raise Exception(\"Heap is empty\")\n        \n        max_value = self.heap[0]\n        self.heap[0] = self.heap[-1]\n        self.heap.pop()\n        \n        if self.heap:\n            self.heapify_down(0)\n        \n        return max_value\n    \n    def peek(self):\n        if not self.heap:\n            raise Exception(\"Heap is empty\")\n        return self.heap[0]\n```\n\n---\n\n### 5. Test và Demo\n\n```python\n# Test Min Heap\nprint(\"=== MIN HEAP ===\")\nmin_heap = MinHeap()\n\n# Insert elements\nelements = [5, 3, 8, 1, 9, 2, 7]\nprint(f\"Inserting: {elements}\")\nfor elem in elements:\n    min_heap.insert(elem)\n    print(f\"After inserting {elem}: {min_heap.heap}\")\n\nprint(f\"\nMin element (peek): {min_heap.peek()}\")\n\n# Extract min\nprint(\"\nExtracting min elements:\")\nwhile not min_heap.is_empty():\n    min_val = min_heap.extract_min()\n    print(f\"Extracted: {min_val}, Remaining: {min_heap.heap}\")\n\n# Test Max Heap\nprint(\"\n=== MAX HEAP ===\")\nmax_heap = MaxHeap()\n\nprint(f\"Inserting: {elements}\")\nfor elem in elements:\n    max_heap.insert(elem)\n    print(f\"After inserting {elem}: {max_heap.heap}\")\n\nprint(f\"\nMax element (peek): {max_heap.peek()}\")\n\n# Extract max\nprint(\"\nExtracting max elements:\")\nwhile max_heap.heap:\n    max_val = max_heap.extract_max()\n    print(f\"Extracted: {max_val}, Remaining: {max_heap.heap}\")\n\n# Test Build Heap\nprint(\"\n=== BUILD HEAP ===\")\narr = [9, 5, 6, 2, 3, 7, 1, 4, 8]\nprint(f\"Original array: {arr}\")\n\nmin_heap2 = MinHeap()\nmin_heap2.build_heap(arr)\nprint(f\"Min Heap: {min_heap2.heap}\")\n\nmax_heap2 = MaxHeap()\nmax_heap2.heap = arr.copy()\nfor i in range(len(max_heap2.heap) // 2 - 1, -1, -1):\n    max_heap2.heapify_down(i)\nprint(f\"Max Heap: {max_heap2.heap}\")\n```\n\n---\n\n### 6. Ứng dụng thực tế\n\n#### 6.1. Heap Sort\n\n```python\ndef heap_sort(arr):\n    \"\"\"\n    Sắp xếp mảng sử dụng heap\n    Time Complexity: O(n log n)\n    Space Complexity: O(1) - in-place\n    \"\"\"\n    n = len(arr)\n    \n    # Build max heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements one by one\n    for i in range(n - 1, 0, -1):\n        # Swap root (max) với phần tử cuối\n        arr[0], arr[i] = arr[i], arr[0]\n        # Heapify root với heap size giảm dần\n        heapify(arr, i, 0)\n    \n    return arr\n\ndef heapify(arr, n, i):\n    \"\"\"Heapify subtree rooted at index i\"\"\"\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n\n**Các khái niệm quan trọng:**\n- `heapify_up` (còn gọi là \"sift-up\" hoặc \"bubble-up\") và `heapify_down` (còn gọi là \"sift-down\" hoặc \"bubble-down\") là hai thuật toán cơ bản được sử dụng trong cấu trúc dữ liệu Heap (đặc biệt là Binary Heap) để duy trì tính chất heap sau các thao tác thêm hoặc xóa phần tử. Cả hai thuật toán đều có độ phức tạp thời gian là O(log n), trong đó n là số phần tử trong heap, do chúng di chuyển phần tử theo chiều cao của cây.\n\n**`heapify_up`**:\nThuật toán này được sử dụng sau khi một phần tử mới được thêm vào cuối heap. Nó di chuyển phần tử mới từ vị trí cuối cùng (hoặc vị trí hiện tại) lên phía gốc bằng cách so sánh và hoán đổi với node cha của nó. Quá trình này tiếp tục cho đến khi phần tử đó thỏa mãn tính chất heap (nhỏ hơn cha trong Min Heap, lớn hơn cha trong Max Heap) hoặc trở thành node gốc.\n\n**`heapify_down`**:\nThuật toán này được sử dụng sau khi phần tử gốc bị loại bỏ, một phần tử ở vị trí 'i' bị thay đổi, hoặc một phần tử được đưa lên gốc. Nó di chuyển phần tử từ vị trí hiện tại (thường là gốc) xuống dưới cây bằng cách so sánh và hoán đổi với node con có giá trị phù hợp (nhỏ hơn trong Min Heap, lớn hơn trong Max Heap). Quá trình này tiếp tục cho đến khi phần tử đó thỏa mãn tính chất heap hoặc trở thành node lá.\n\n**Mối quan hệ:**\n- heapify_up đảm bảo tính chất Max Heap được duy trì sau khi thêm phần tử.\n- heapify_up được sử dụng trong Max Heap để duy trì tính chất heap sau khi thêm một phần tử mới.\n- Thuật toán heapify_up sử dụng phép toán swap để hoán đổi vị trí các phần tử.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\nDùng khi extract phần tử root.\n\n```python\n    def heapify_down(self, i):\n        \"\"\"\n        Di chuyển phần tử xuống dưới cho đến khi thỏa mãn heap property\n        \"\"\"\n        while self.has_left_child(i):\n            # Tìm con nhỏ hơn\n            smaller_child_index = self.left_child(i)\n            \n            if (self.has_right_child(i) and \n                self.heap[self.right_child(i)] < self.heap[smaller_child_index]):\n                smaller_child_index = self.right_child(i)\n            \n            # Nếu phần tử hiện tại nhỏ hơn cả 2 con, dừng\n            if self.heap[i] <= self.heap[smaller_child_index]:\n                break\n            \n            # Swap với con nhỏ hơn\n            self.swap(i, smaller_child_index)\n            i = smaller_child_index\n```\n\n**Minh họa:**\n```\nExtract min (5):\n\nBước 1: Thay thế root bằng phần tử cuối\n      15*\n     /  \\\n    20  10\n   / \\\n  30 25\n\nBước 2: Heapify down, swap với 10\n      10\n     /  \\\n    20  15*\n   / \\\n  30 25\n\nDừng: 15 < 30 và 15 < 25 (không có con phải)\n```\n\n#### 3.4. Insert (Thêm phần tử)\n\n```python\n    def insert(self, value):\n        \"\"\"\n        Thêm phần tử vào heap\n        Time Complexity: O(log n)\n        \"\"\"\n        # Thêm vào cuối\n        self.heap.append(value)\n        # Heapify up\n        self.heapify_up(len(self.heap) - 1)\n```\n\n#### 3.5. Extract Min (Lấy phần tử nhỏ nhất)\n\n```python\n    def extract_min(self):\n        \"\"\"\n        Lấy và xóa phần tử nhỏ nhất\n        Time Complexity: O(log n)\n        \"\"\"\n        if self.is_empty():\n            raise Exception(\"Heap is empty\")\n        \n        # Lấy phần tử root\n        min_value = self.heap[0]\n        \n        # Thay thế root bằng phần tử cuối\n        self.heap[0] = self.heap[-1]\n        self.heap.pop()\n        \n        # Heapify down nếu heap không rỗng\n        if not self.is_empty():\n            self.heapify_down(0)\n        \n        return min_value\n```\n\n#### 3.6. Peek (Xem phần tử nhỏ nhất)\n\n```python\n    def peek(self):\n        \"\"\"\n        Xem phần tử nhỏ nhất mà không xóa\n        Time Complexity: O(1)\n        \"\"\"\n        if self.is_empty():\n            raise Exception(\"Heap is empty\")\n        return self.heap[0]\n```\n\n#### 3.7. Build Heap (Xây dựng heap từ mảng)\n\n```python\n    def build_heap(self, arr):\n        \"\"\"\n        Xây dựng heap từ mảng cho trước\n        Time Complexity: O(n)\n        \"\"\"\n        self.heap = arr.copy()\n        \n        # Heapify từ node cuối cùng có con (từ dưới lên trên)\n        for i in range(len(self.heap) // 2 - 1, -1, -1):\n            self.heapify_down(i)\n```\n\n**Tại sao O(n) chứ không phải O(n log n)?**\n- Các node ở level cuối không cần heapify\n- Các node gần root có ít hơn, nhưng chi phí heapify cao hơn\n- Tổng chi phí: Σ(h * nodes_at_level_h) ≈ O(n)\n\n---\n\n### 4. Cài đặt Max Heap\n\n```python\nclass MaxHeap:\n    def __init__(self):\n        self.heap = []\n    \n    def parent(self, i):\n        return (i - 1) // 2\n    \n    def left_child(self, i):\n        return 2 * i + 1\n    \n    def right_child(self, i):\n        return 2 * i + 2\n    \n    def swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n    \n    def heapify_up(self, i):\n\n**Các khái niệm quan trọng:**\n- `heapify_up` (còn gọi là \"sift-up\" hoặc \"bubble-up\") và `heapify_down` (còn gọi là \"sift-down\" hoặc \"bubble-down\") là hai thuật toán cơ bản được sử dụng trong cấu trúc dữ liệu Heap (đặc biệt là Binary Heap) để duy trì tính chất heap sau các thao tác thêm hoặc xóa phần tử. Cả hai thuật toán đều có độ phức tạp thời gian là O(log n), trong đó n là số phần tử trong heap, do chúng di chuyển phần tử theo chiều cao của cây.\n\n**`heapify_up`**:\nThuật toán này được sử dụng sau khi một phần tử mới được thêm vào cuối heap. Nó di chuyển phần tử mới từ vị trí cuối cùng (hoặc vị trí hiện tại) lên phía gốc bằng cách so sánh và hoán đổi với node cha của nó. Quá trình này tiếp tục cho đến khi phần tử đó thỏa mãn tính chất heap (nhỏ hơn cha trong Min Heap, lớn hơn cha trong Max Heap) hoặc trở thành node gốc.\n\n**`heapify_down`**:\nThuật toán này được sử dụng sau khi phần tử gốc bị loại bỏ, một phần tử ở vị trí 'i' bị thay đổi, hoặc một phần tử được đưa lên gốc. Nó di chuyển phần tử từ vị trí hiện tại (thường là gốc) xuống dưới cây bằng cách so sánh và hoán đổi với node con có giá trị phù hợp (nhỏ hơn trong Min Heap, lớn hơn trong Max Heap). Quá trình này tiếp tục cho đến khi phần tử đó thỏa mãn tính chất heap hoặc trở thành node lá.\n\n**Mối quan hệ:**\n- heapify_up đảm bảo tính chất Max Heap được duy trì sau khi thêm phần tử.\n- Thuật toán heapify_up sử dụng phép toán swap để hoán đổi vị trí các phần tử.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n**Binary Heap là cài đặt phổ biến nhất** vì cân bằng tốt giữa các thao tác.\n\n---\n\n### 2. Binary Heap\n\n#### 2.1. Khái niệm\n\n**Binary Heap** là một cây nhị phân hoàn chỉnh (complete binary tree) thỏa mãn tính chất heap:\n\n**Max Heap:**\n- Giá trị của mỗi node ≥ giá trị của các node con\n- Node gốc có giá trị lớn nhất\n\n**Min Heap:**\n- Giá trị của mỗi node ≤ giá trị của các node con\n- Node gốc có giá trị nhỏ nhất\n\n#### 2.2. Tính chất\n\n**a) Complete Binary Tree:**\n- Tất cả các level đều đầy, trừ level cuối\n- Level cuối được điền từ trái sang phải\n\n**b) Biểu diễn bằng mảng:**\nVới node tại index `i`:\n- Parent: `(i - 1) // 2`\n- Left child: `2 * i + 1`\n- Right child: `2 * i + 2`\n\n**Ví dụ Max Heap:**\n```\n        50\n       /  \\\n      30   40\n     / \\   /\n    10 20 35\n\nMảng: [50, 30, 40, 10, 20, 35]\nIndex: 0   1   2   3   4   5\n```\n\n#### 2.3. Ưu điểm của Binary Heap\n\n- ✅ Không cần con trỏ (dùng mảng)\n- ✅ Cache-friendly (truy cập liên tiếp)\n- ✅ Cân bằng tự động\n- ✅ Dễ cài đặt\n- ✅ Hiệu quả: O(log n) cho insert và extract\n\n---\n\n### 3. Cài đặt Min Heap\n\n#### 3.1. Cấu trúc cơ bản\n\n```python\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n    \n    def parent(self, i):\n        return (i - 1) // 2\n    \n    def left_child(self, i):\n        return 2 * i + 1\n    \n    def right_child(self, i):\n        return 2 * i + 2\n    \n    def has_left_child(self, i):\n        return self.left_child(i) < len(self.heap)\n    \n    def has_right_child(self, i):\n        return self.right_child(i) < len(self.heap)\n    \n    def has_parent(self, i):\n        return self.parent(i) >= 0\n    \n    def swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n    \n    def size(self):\n        return len(self.heap)\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 3.2. Heapify Up (Bubble Up)\n\nDùng khi insert phần tử mới vào cuối heap.\n\n```python\n    def heapify_up(self, i):\n        \"\"\"\n        Di chuyển phần tử lên trên cho đến khi thỏa mãn heap property\n        \"\"\"\n        while self.has_parent(i) and self.heap[i] < self.heap[self.parent(i)]:\n            self.swap(i, self.parent(i))\n            i = self.parent(i)\n```\n\n**Minh họa:**\n```\nThêm 5 vào heap:\n\nBước 1: Thêm vào cuối\n      10\n     /  \\\n    20  15\n   / \\  /\n  30 25 5*  <- Thêm ở đây\n\nBước 2: So sánh với parent (15), swap\n      10\n     /  \\\n    20  5*\n   / \\  /\n  30 25 15\n\nBước 3: So sánh với parent (10), swap\n      5*\n     /  \\\n    20  10\n   / \\  /\n  30 25 15\n```\n\n#### 3.3. Heapify Down (Bubble Down)\n\n\n**Các khái niệm quan trọng:**\n- Extract là phép toán lấy ra phần tử có độ ưu tiên cao nhất (node gốc) từ Binary Heap. Sau khi lấy ra, phần tử cuối cùng của heap được đưa lên làm gốc, sau đó được di chuyển xuống dưới (heapify_down) để duy trì tính chất heap. Độ phức tạp thời gian là O(log n).\n- `heapify_up` (còn gọi là \"sift-up\" hoặc \"bubble-up\") và `heapify_down` (còn gọi là \"sift-down\" hoặc \"bubble-down\") là hai thuật toán cơ bản được sử dụng trong cấu trúc dữ liệu Heap (đặc biệt là Binary Heap) để duy trì tính chất heap sau các thao tác thêm hoặc xóa phần tử. Cả hai thuật toán đều có độ phức tạp thời gian là O(log n), trong đó n là số phần tử trong heap, do chúng di chuyển phần tử theo chiều cao của cây.\n\n**`heapify_up`**:\nThuật toán này được sử dụng sau khi một phần tử mới được thêm vào cuối heap. Nó di chuyển phần tử mới từ vị trí cuối cùng (hoặc vị trí hiện tại) lên phía gốc bằng cách so sánh và hoán đổi với node cha của nó. Quá trình này tiếp tục cho đến khi phần tử đó thỏa mãn tính chất heap (nhỏ hơn cha trong Min Heap, lớn hơn cha trong Max Heap) hoặc trở thành node gốc.\n\n**`heapify_down`**:\nThuật toán này được sử dụng sau khi phần tử gốc bị loại bỏ, một phần tử ở vị trí 'i' bị thay đổi, hoặc một phần tử được đưa lên gốc. Nó di chuyển phần tử từ vị trí hiện tại (thường là gốc) xuống dưới cây bằng cách so sánh và hoán đổi với node con có giá trị phù hợp (nhỏ hơn trong Min Heap, lớn hơn trong Max Heap). Quá trình này tiếp tục cho đến khi phần tử đó thỏa mãn tính chất heap hoặc trở thành node lá.\n\n**Mối quan hệ:**\n- Thuật toán heapify_down được sử dụng trong phép toán Extract để duy trì tính chất heap.\n- heapify_up đảm bảo tính chất Max Heap được duy trì sau khi thêm phần tử.\n- Thuật toán heapify_up sử dụng phép toán swap để hoán đổi vị trí các phần tử."
        },
        "output_without_context": {
            "question": "Trong quá trình chèn một mục vào heap nhị phân, thao tác nào được thực hiện để duy trì tính chính xác của heap?",
            "answer": "Bơi lên"
        }
    },
    {
        "topic_description": "Chủ đề phân tích Heapsort, một thuật toán sắp xếp quan trọng, bao gồm cách thức hoạt động và quá trình sắp xếp. Học sinh sẽ cần phải nắm vững các thuật toán và độ phức tạp của chúng liên quan đến số lần so sánh và không gian nhớ.",
        "output_with_context": {
            "question": "Trong thuật toán Heapsort, độ phức tạp thời gian trong trường hợp xấu nhất là gì?",
            "answer": "O(n²)",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n        [11, 12, 22, 25, 64]\n\nBước 4: Tìm min = 25, không cần hoán đổi\n        [11, 12, 22, 25, 64]\n```\n\n#### 3.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n²)\n- **Average case:** O(n²)\n- **Worst case:** O(n²)\n- Số lần so sánh luôn cố định: n(n-1)/2\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ❌ Unstable (có thể làm stable với cài đặt khác)\n- ✅ In-place\n- ❌ Không adaptive\n- ✅ Số lần hoán đổi ít nhất: O(n)\n\n**Ưu điểm:**\n- Đơn giản, dễ hiểu\n- Số lần hoán đổi ít (tốt khi chi phí hoán đổi cao)\n- Hoạt động tốt với mảng nhỏ\n\n**Nhược điểm:**\n- Không hiệu quả với dữ liệu lớn\n- Không tận dụng được dữ liệu đã sắp xếp\n\n---\n\n### 4. Insertion Sort (Sắp xếp chèn)\n\n#### 4.1. Ý tưởng\n\nInsertion Sort xây dựng mảng đã sắp xếp từng phần tử một. Nó giống như cách chúng ta sắp xếp bài trong tay: lấy một lá bài và chèn nó vào đúng vị trí trong phần đã sắp xếp.\n\n**Nguyên lý:**\n1. Bắt đầu từ phần tử thứ hai\n2. So sánh với các phần tử bên trái\n3. Dịch các phần tử lớn hơn sang phải\n4. Chèn phần tử vào vị trí đúng\n\n#### 4.2. Thuật toán\n\n```python\ndef insertion_sort(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        key = arr[i]\n        j = i - 1\n        \n        # Di chuyển các phần tử lớn hơn key sang phải\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        \n        # Chèn key vào vị trí đúng\n        arr[j + 1] = key\n    \n    return arr\n\n# Test\narr = [12, 11, 13, 5, 6]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", insertion_sort(arr.copy()))\n```\n\n#### 4.3. Minh họa từng bước\n\n```\nMảng: [12, 11, 13, 5, 6]\n\nBước 1: key = 11\n        [11, 12, 13, 5, 6]\n\nBước 2: key = 13, không thay đổi\n        [11, 12, 13, 5, 6]\n\nBước 3: key = 5\n        [5, 11, 12, 13, 6]\n\nBước 4: key = 6\n        [5, 6, 11, 12, 13]\n```\n\n#### 4.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive\n- ✅ Online\n\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Insertion Sort giải quyết bài toán Sorting bằng cách chèn từng phần tử vào đúng vị trí trong phần đã sắp xếp của mảng.\n- Insertion Sort giải quyết bài toán sắp xếp bằng cách chèn từng phần tử vào đúng vị trí trong phần đã sắp xếp của mảng."
        },
        "output_without_context": {
            "question": "Trong thuật toán Heapsort, độ phức tạp thời gian tốt nhất là bao nhiêu trong trường hợp sắp xếp một mảng đã được sắp xếp trước?",
            "answer": "O(n log n)"
        }
    },
    {
        "topic_description": "Nhằm tạo ra cái nhìn tổng quan về các ứng dụng của hàng đợi ưu tiên trong mô phỏng. Học sinh sẽ được kiểm tra khả năng liên kết các khái niệm của hàng đợi ưu tiên với thực tế mô phỏng theo sự kiện.",
        "output_with_context": {
            "question": "Trong mô phỏng theo sự kiện, khi nào nên sử dụng hàng đợi ưu tiên thay vì hàng đợi thông thường?",
            "answer": "Khi cần xử lý các phần tử theo độ ưu tiên, như trong hệ thống cấp cứu hoặc lập lịch CPU.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n| **In-place** | ✅ | ❌ | ✅ |\n| **Cache-friendly** | ✅ | ❌ | ⚠️ |\n\n#### 6.1. Khi nào dùng Quick Sort?\n\n**Nên dùng:**\n- ✅ Mảng trong RAM (in-memory sorting)\n- ✅ Cần sorting nhanh nhất average case\n- ✅ Bộ nhớ hạn chế\n- ✅ Random access data (array)\n- ✅ Không cần stable sort\n\n**Không nên dùng:**\n- ❌ Cần đảm bảo O(n log n) worst case\n- ❌ Cần stable sorting\n- ❌ Linked list (Merge Sort tốt hơn)\n- ❌ Dữ liệu đã gần sắp xếp (trừ khi dùng random pivot)\n\n---\n\n### 7. Quick Sort trong thư viện chuẩn\n\n#### 7.1. Python's sorted() và sort()\n\nPython sử dụng **Timsort** (hybrid của Merge Sort và Insertion Sort), không phải Quick Sort, vì:\n- Stable sorting\n- Tốt với dữ liệu có pattern\n- Worst case O(n log n) đảm bảo\n\n#### 7.2. C++ std::sort()\n\nC++ sử dụng **Introsort** (Introspective Sort):\n- Bắt đầu với Quick Sort\n- Chuyển sang Heap Sort nếu đệ quy quá sâu (tránh O(n²))\n- Dùng Insertion Sort cho mảng nhỏ\n\n#### 7.3. Java's Arrays.sort()\n\n- **Primitive types:** Dual-Pivot Quick Sort\n- **Object types:** Timsort (stable)\n\n---\n\n## Priority Queue & Binary Heap\n\n### 1. Giới thiệu Priority Queue\n\n#### 1.1. Khái niệm\n\n**Priority Queue (Hàng đợi ưu tiên)** là một cấu trúc dữ liệu trừu tượng trong đó mỗi phần tử có một độ ưu tiên (priority) được gán cho nó. Phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào.\n\n**Khác với Queue thông thường:**\n- Queue thông thường: FIFO (First In First Out)\n- Priority Queue: Phần tử có priority cao nhất ra trước\n\n**Ví dụ thực tế:**\n- **Hệ thống cấp cứu:** Bệnh nhân nguy kịch được ưu tiên khám trước\n- **CPU Scheduling:** Process có priority cao được xử lý trước\n- **Dijkstra Algorithm:** Chọn đỉnh có khoảng cách nhỏ nhất\n- **A* Search:** Chọn node có f(n) nhỏ nhất\n- **Huffman Coding:** Xây dựng cây mã hóa\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Insert/Enqueue:** Thêm phần tử với priority\n**b) Extract-Max/Min:** Lấy và xóa phần tử có priority cao/thấp nhất\n**c) Peek/Top:** Xem phần tử có priority cao/thấp nhất\n**d) Change Priority:** Thay đổi priority của phần tử\n**e) Delete:** Xóa phần tử bất kỳ\n\n#### 1.3. Các cách cài đặt\n\n| Cài đặt | Insert | Extract-Max | Peek |\n|---------|--------|-------------|------|\n| Array (unsorted) | O(1) | O(n) | O(n) |\n| Array (sorted) | O(n) | O(1) | O(1) |\n| Linked List | O(n) | O(1) | O(1) |\n| **Binary Heap** | **O(log n)** | **O(log n)** | **O(1)** |\n| Fibonacci Heap | O(1) | O(log n) | O(1) |\n\n\n**Các khái niệm quan trọng:**\n- Priority Queue có thể được cài đặt bằng Unsorted Array hoặc Sorted Array. Với Unsorted Array, phép toán Insert có độ phức tạp O(1) do chỉ cần thêm vào cuối mảng, nhưng Extract-Max/Min và Peek có độ phức tạp O(n) vì yêu cầu duyệt toàn bộ mảng. Ngược lại, với Sorted Array, phép toán Insert có độ phức tạp O(n) để duy trì thứ tự, nhưng Extract-Max/Min và Peek có độ phức tạp O(1) do phần tử ưu tiên cao nhất/thấp nhất nằm ở đầu hoặc cuối mảng.\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n\n**Mối quan hệ:**\n- Queue được sử dụng để giải quyết bài toán Disk scheduling.\n- Priority Queue có thể được cài đặt bằng Unsorted Array.\n- Priority Queue là một loại Queue đặc biệt xử lý phần tử theo độ ưu tiên.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\n# Test\nprint(is_valid_parentheses(\"()[]{}\"))  # True\nprint(is_valid_parentheses(\"([)]\"))    # False\n```\n\n**b) Chuyển đổi biểu thức Infix sang Postfix:**\n\n```python\ndef infix_to_postfix(expression):\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    stack = []\n    output = []\n    \n    for char in expression:\n        if char.isalnum():  # Toán hạng\n            output.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output.append(stack.pop())\n            stack.pop()  # Loại bỏ '('\n        else:  # Toán tử\n            while (stack and stack[-1] != '(' and\n                   precedence.get(stack[-1], 0) >= precedence.get(char, 0)):\n                output.append(stack.pop())\n            stack.append(char)\n    \n    while stack:\n        output.append(stack.pop())\n    \n    return ''.join(output)\n\n# Test\nprint(infix_to_postfix(\"A+B*C\"))  # ABC*+\n```\n\n**c) Tính giá trị biểu thức Postfix:**\n\n```python\ndef evaluate_postfix(expression):\n    stack = []\n    \n    for char in expression:\n        if char.isdigit():\n            stack.append(int(char))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            \n            if char == '+':\n                stack.append(a + b)\n            elif char == '-':\n                stack.append(a - b)\n            elif char == '*':\n                stack.append(a * b)\n            elif char == '/':\n                stack.append(a // b)\n    \n    return stack.pop()\n\n# Test\nprint(evaluate_postfix(\"23*5+\"))  # 11\n```\n\n**d) Thuật toán quay lui (Backtracking):**\nStack được sử dụng trong các thuật toán quay lui như giải mê cung, N-Queens, sudoku solver.\n\n**e) Đánh giá biểu thức số học và biên dịch:**\nCompiler sử dụng stack để parse và đánh giá các biểu thức.\n\n---\n\n### 2. Queue (Hàng đợi)\n\n#### 2.1. Khái niệm cơ bản\n\nQueue là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **FIFO (First In First Out)** - \"vào trước ra trước\". Phần tử được thêm vào đầu tiên sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Hàng người xếp hàng mua vé: Người đến trước được phục vụ trước\n- Hàng đợi in ấn: Tài liệu gửi in trước sẽ được in trước\n- Hàng đợi xử lý trong hệ thống: CPU scheduling, disk scheduling\n\n#### 2.2. Các thao tác cơ bản\n\n**a) Enqueue (Thêm vào):** Thêm phần tử vào cuối queue\n- Độ phức tạp: O(1)\n\n**b) Dequeue (Lấy ra):** Xóa và trả về phần tử ở đầu queue\n- Độ phức tạp: O(1)\n\n**c) Front/Peek:** Xem phần tử ở đầu queue mà không xóa\n- Độ phức tạp: O(1)\n\n**d) Rear:** Xem phần tử ở cuối queue\n- Độ phức tạp: O(1)\n\n**e) isEmpty:** Kiểm tra queue có rỗng không\n- Độ phức tạp: O(1)\n\n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n\n**Mối quan hệ:**\n- Queue được sử dụng để giải quyết bài toán Disk scheduling.\n- Queue được sử dụng để giải quyết bài toán CPU scheduling.\n- Priority Queue là một loại Queue đặc biệt xử lý phần tử theo độ ưu tiên.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return result\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\nprint(bfs(graph, 'A'))  # ['A', 'B', 'C', 'D', 'E', 'F']\n```\n\n**b) Quản lý tài nguyên chia sẻ:**\n- CPU scheduling\n- Disk scheduling\n- Printer queue\n\n**c) Xử lý bất đồng bộ:**\n- Message queue trong các hệ thống phân tán\n- Event handling trong GUI\n\n**d) Cache implementation:**\n- LRU (Least Recently Used) cache sử dụng kết hợp queue và hash map\n\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n```\n\n#### 2.6. So sánh Stack và Queue\n\n| Đặc điểm | Stack | Queue |\n|----------|-------|-------|\n| Nguyên tắc | LIFO | FIFO |\n| Thao tác chính | Push, Pop | Enqueue, Dequeue |\n| Truy cập | Chỉ ở đỉnh (top) | Ở đầu (front) và cuối (rear) |\n| Ứng dụng | Backtracking, Expression evaluation | BFS, Scheduling |\n| Cài đặt | Array, Linked List | Array (Circular), Linked List |\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n\n**Mối quan hệ:**\n- Queue được sử dụng để giải quyết bài toán Disk scheduling.\n- Priority Queue là một loại Queue đặc biệt xử lý phần tử theo độ ưu tiên.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n**f) Size:** Trả về số lượng phần tử trong queue\n- Độ phức tạp: O(1)\n\n#### 2.3. Cài đặt Queue\n\n**Cách 1: Sử dụng mảng (Circular Queue)**\n\n```python\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = -1\n        self.rear = -1\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        if self.is_full():\n            raise Exception(\"Queue is full\")\n        \n        if self.front == -1:  # Queue rỗng\n            self.front = 0\n        \n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = item\n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.queue[self.front]\n        \n        if self.front == self.rear:  # Chỉ còn 1 phần tử\n            self.front = -1\n            self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue[self.front]\n    \n    def is_empty(self):\n        return self.front == -1\n    \n    def is_full(self):\n        return (self.rear + 1) % self.capacity == self.front\n    \n    def size(self):\n        return self.size_count\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass QueueLinkedList:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        new_node = Node(item)\n        \n        if self.rear is None:  # Queue rỗng\n            self.front = self.rear = new_node\n        else:\n            self.rear.next = new_node\n            self.rear = new_node\n        \n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.front.data\n        self.front = self.front.next\n        \n        if self.front is None:  # Queue trở nên rỗng\n            self.rear = None\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.front.data\n    \n    def is_empty(self):\n        return self.front is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 2.4. Các loại Queue đặc biệt\n\n**a) Deque (Double-ended Queue):**\nCho phép thêm và xóa phần tử ở cả hai đầu.\n\n```python\nfrom collections import deque\n\ndq = deque()\ndq.append(1)      # Thêm vào phải\ndq.appendleft(2)  # Thêm vào trái\ndq.pop()          # Xóa từ phải\ndq.popleft()      # Xóa từ trái\n```\n\n**b) Priority Queue (Hàng đợi ưu tiên):**\nMỗi phần tử có một độ ưu tiên, phần tử có độ ưu tiên cao nhất được xử lý trước.\n\n```python\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, item, priority):\n        heapq.heappush(self.heap, (priority, item))\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Priority Queue is empty\")\n        return heapq.heappop(self.heap)[1]\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 2.5. Ứng dụng của Queue\n\n**a) BFS (Breadth-First Search) trong đồ thị:**\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    \n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n\n**Mối quan hệ:**\n- Queue được sử dụng để giải quyết bài toán Disk scheduling.\n- Priority Queue là một loại Queue đặc biệt xử lý phần tử theo độ ưu tiên."
        },
        "output_without_context": {
            "question": "Trong mô phỏng theo sự kiện, hàng đợi ưu tiên thường được sử dụng để xử lý các sự kiện nào có độ ưu tiên cao hơn?",
            "answer": "Các sự kiện quan trọng hơn hoặc cần xử lý nhanh hơn."
        }
    },
    {
        "topic_description": "Chủ đề này kết hợp kiến thức từ tuần 3 và tuần 5, nhấn mạnh sự khác biệt và ưu điểm của Mergesort và Heapsort trong việc xử lý dữ liệu. Học sinh cần phân tích hiệu suất và các yếu tố của từng thuật toán để ứng dụng trong tình huống cụ thể.",
        "output_with_context": {
            "question": "So với Heapsort, Mergesort có ưu điểm gì nổi bật trong việc xử lý dữ liệu lớn không vừa trong RAM?",
            "answer": "Mergesort có thể thực hiện sắp xếp ngoài (external sorting) hiệu quả hơn nhờ vào khả năng chia và gộp dữ liệu, trong khi Heapsort không hỗ trợ tốt cho việc này.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n---\n\n## Mergesort\n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\nMerge Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật **Chia để trị (Divide and Conquer)**. Thuật toán chia mảng thành các phần nhỏ hơn, sắp xếp chúng, sau đó gộp (merge) các phần đã sắp xếp lại với nhau.\n\n**Nguyên lý Divide and Conquer:**\n1. **Divide (Chia):** Chia bài toán thành các bài toán con nhỏ hơn\n2. **Conquer (Chinh phục):** Giải quyết các bài toán con (đệ quy)\n3. **Combine (Kết hợp):** Gộp các lời giải của bài toán con\n\n#### 1.2. Ý tưởng chính\n\n```\nMảng: [38, 27, 43, 3, 9, 82, 10]\n\nBước 1 - Chia:\n[38, 27, 43, 3] | [9, 82, 10]\n\nBước 2 - Chia tiếp:\n[38, 27] | [43, 3] | [9, 82] | [10]\n\nBước 3 - Chia đến mức cơ sở:\n[38] | [27] | [43] | [3] | [9] | [82] | [10]\n\nBước 4 - Gộp:\n[27, 38] | [3, 43] | [9, 82] | [10]\n\nBước 5 - Gộp tiếp:\n[3, 27, 38, 43] | [9, 10, 82]\n\nBước 6 - Gộp cuối:\n[3, 9, 10, 27, 38, 43, 82]\n```\n\n---\n\n### 2. Thuật toán Merge Sort\n\n#### 2.1. Cài đặt cơ bản\n\n```python\ndef merge_sort(arr):\n    \"\"\"\n    Sắp xếp mảng sử dụng Merge Sort\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    # Chia mảng thành 2 nửa\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Đệ quy sắp xếp 2 nửa\n    left = merge_sort(left)\n    right = merge_sort(right)\n    \n    # Gộp 2 nửa đã sắp xếp\n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    Gộp 2 mảng đã sắp xếp thành 1 mảng sắp xếp\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # So sánh từng phần tử và thêm phần tử nhỏ hơn vào result\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # Thêm các phần tử còn lại (nếu có)\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", merge_sort(arr))\n```\n\n#### 2.2. Cài đặt In-place (tối ưu bộ nhớ)\n\n```python\ndef merge_sort_inplace(arr, left, right):\n    \"\"\"\n    Merge Sort in-place để tiết kiệm bộ nhớ\n    \"\"\"\n    if left < right:\n        mid = (left + right) // 2\n        \n        # Sắp xếp 2 nửa\n        merge_sort_inplace(arr, left, mid)\n        merge_sort_inplace(arr, mid + 1, right)\n        \n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n```python\ndef hybrid_merge_sort(arr, threshold=10):\n    \"\"\"\n    Sử dụng Insertion Sort cho mảng nhỏ\n    \"\"\"\n    def insertion_sort_range(arr, left, right):\n        for i in range(left + 1, right + 1):\n            key = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key\n    \n    def merge_sort_helper(left, right):\n        if right - left + 1 <= threshold:\n            insertion_sort_range(arr, left, right)\n        elif left < right:\n            mid = (left + right) // 2\n            merge_sort_helper(left, mid)\n            merge_sort_helper(mid + 1, right)\n            merge_inplace(arr, left, mid, right)\n    \n    merge_sort_helper(0, len(arr) - 1)\n    return arr\n```\n\n#### 4.4. 3-way Merge Sort\n\nChia mảng thành 3 phần thay vì 2.\n\n```python\ndef three_way_merge_sort(arr):\n    \"\"\"\n    Chia mảng thành 3 phần\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    n = len(arr)\n    third = n // 3\n    \n    # Chia thành 3 phần\n    left = merge_sort(arr[:third])\n    middle = merge_sort(arr[third:2*third])\n    right = merge_sort(arr[2*third:])\n    \n    # Gộp 3 phần\n    return merge_three(left, middle, right)\n\ndef merge_three(left, middle, right):\n    \"\"\"\n    Gộp 3 mảng đã sắp xếp\n    \"\"\"\n    result = []\n    i = j = k = 0\n    \n    while i < len(left) and j < len(middle) and k < len(right):\n        if left[i] <= middle[j] and left[i] <= right[k]:\n            result.append(left[i])\n            i += 1\n        elif middle[j] <= left[i] and middle[j] <= right[k]:\n            result.append(middle[j])\n            j += 1\n        else:\n            result.append(right[k])\n            k += 1\n    \n    # Gộp 2 mảng còn lại\n    while i < len(left) and j < len(middle):\n        if left[i] <= middle[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(middle[j])\n            j += 1\n    \n    while i < len(left) and k < len(right):\n        if left[i] <= right[k]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[k])\n            k += 1\n    \n    while j < len(middle) and k < len(right):\n        if middle[j] <= right[k]:\n            result.append(middle[j])\n            j += 1\n        else:\n            result.append(right[k])\n            k += 1\n    \n    # Thêm phần tử còn lại\n    result.extend(left[i:])\n    result.extend(middle[j:])\n    result.extend(right[k:])\n    \n    return result\n```\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. External Sorting (Sắp xếp file lớn)\n\n```python\nimport os\nimport heapq\n\ndef external_merge_sort(input_file, output_file, chunk_size=1000):\n    \"\"\"\n    Sắp xếp file lớn không fit trong RAM\n    \"\"\"\n    # Bước 1: Chia file thành các chunk nhỏ và sắp xếp\n    temp_files = []\n    with open(input_file, 'r') as f:\n        chunk = []\n        for line in f:\n            chunk.append(int(line.strip()))\n            \n            if len(chunk) >= chunk_size:\n                chunk.sort()\n                temp_file = f\"temp_{len(temp_files)}.txt\"\n                with open(temp_file, 'w') as tf:\n                    tf.writelines(f\"{x}\n\" for x in chunk)\n                temp_files.append(temp_file)\n                chunk = []\n        \n        # Xử lý chunk cuối\n        if chunk:\n            chunk.sort()\n            temp_file = f\"temp_{len(temp_files)}.txt\"\n            with open(temp_file, 'w') as tf:\n                tf.writelines(f\"{x}\n\" for x in chunk)\n            temp_files.append(temp_file)\n    \n\n**Các khái niệm quan trọng:**\n- Merge Sort (hoặc Mergesort) là một thuật toán sắp xếp hiệu quả dựa trên kỹ thuật chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chia mảng thành hai nửa, sắp xếp đệ quy từng nửa, sau đó trộn (gộp) hai nửa đã sắp xếp lại với nhau. Merge Sort là một thuật toán sắp xếp ổn định (stable) và có độ phức tạp thời gian O(n log n) trong mọi trường hợp (best, average, worst case). Độ phức tạp không gian của nó là O(n) do cần không gian phụ (mảng tạm) để thực hiện quá trình trộn. Merge Sort có thể được cài đặt bằng đệ quy hoặc lặp, thích hợp cho việc sắp xếp dữ liệu lớn không vừa trong RAM (external sorting), có thể song song hóa, và hiệu quả khi sắp xếp các cấu trúc dữ liệu như linked list. Ngoài ra, Mergesort có thể được sửa đổi để đếm số lần đảo ngược trong một mảng, với một hàm phụ trợ `merge_count` có độ phức tạp O(k) để đếm đảo ngược khi trộn hai mảng con.\n\n**Mối quan hệ:**\n- Mergesort giải quyết bài toán Comparison-based sorting một cách hiệu quả.\n- Mergesort trong ngữ cảnh trộn các file tạm sử dụng Heap để quản lý các phần tử nhỏ nhất từ các file khác nhau, đảm bảo việc trộn hiệu quả.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n        # Gộp 2 nửa\n        merge_inplace(arr, left, mid, right)\n\ndef merge_inplace(arr, left, mid, right):\n    \"\"\"\n    Gộp 2 phần đã sắp xếp trong mảng\n    \"\"\"\n    # Tạo mảng tạm\n    left_arr = arr[left:mid + 1]\n    right_arr = arr[mid + 1:right + 1]\n    \n    i = j = 0\n    k = left\n    \n    # Gộp vào mảng gốc\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n    \n    # Copy phần tử còn lại\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    \n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nmerge_sort_inplace(arr, 0, len(arr) - 1)\nprint(\"Mảng sau khi sắp xếp:\", arr)\n```\n\n#### 2.3. Cài đặt với iteration (không đệ quy)\n\n```python\ndef merge_sort_iterative(arr):\n    \"\"\"\n    Merge Sort sử dụng vòng lặp thay vì đệ quy\n    \"\"\"\n    n = len(arr)\n    current_size = 1\n    \n    # Bắt đầu với kích thước 1, tăng gấp đôi mỗi lần\n    while current_size < n:\n        left = 0\n        \n        while left < n - 1:\n            # Tìm điểm giữa và điểm cuối\n            mid = min(left + current_size - 1, n - 1)\n            right = min(left + 2 * current_size - 1, n - 1)\n            \n            # Gộp các phần con\n            merge_inplace(arr, left, mid, right)\n            \n            # Di chuyển đến phần con tiếp theo\n            left += 2 * current_size\n        \n        # Tăng kích thước gấp đôi\n        current_size *= 2\n    \n    return arr\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Mảng sau khi sắp xếp:\", merge_sort_iterative(arr))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Phân tích bằng Master Theorem:**\n- Công thức đệ quy: T(n) = 2T(n/2) + O(n)\n- Trong đó:\n  - 2T(n/2): Chi phí sắp xếp 2 nửa\n  - O(n): Chi phí gộp\n\n**Độ cao cây đệ quy:** log₂(n)\n**Chi phí mỗi tầng:** O(n)\n**Tổng chi phí:** O(n log n)\n\n**Kết quả:**\n- **Best case:** O(n log n)\n- **Average case:** O(n log n)\n- **Worst case:** O(n log n)\n\n**Đặc điểm độ phức tạp:**\n- Luôn là O(n log n), không phụ thuộc vào dữ liệu đầu vào\n- Tốt hơn các thuật toán O(n²)\n- Là thuật toán optimal cho comparison-based sorting trong worst case\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:** O(n)\n- Cần thêm bộ nhớ để lưu các mảng tạm trong quá trình merge\n- Với đệ quy: O(n) cho mảng tạm + O(log n) cho stack\n- Tổng: O(n)\n\n**Cải thiện bộ nhớ:**\n\n**Các khái niệm quan trọng:**\n- Merge Sort (hoặc Mergesort) là một thuật toán sắp xếp hiệu quả dựa trên kỹ thuật chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chia mảng thành hai nửa, sắp xếp đệ quy từng nửa, sau đó trộn (gộp) hai nửa đã sắp xếp lại với nhau. Merge Sort là một thuật toán sắp xếp ổn định (stable) và có độ phức tạp thời gian O(n log n) trong mọi trường hợp (best, average, worst case). Độ phức tạp không gian của nó là O(n) do cần không gian phụ (mảng tạm) để thực hiện quá trình trộn. Merge Sort có thể được cài đặt bằng đệ quy hoặc lặp, thích hợp cho việc sắp xếp dữ liệu lớn không vừa trong RAM (external sorting), có thể song song hóa, và hiệu quả khi sắp xếp các cấu trúc dữ liệu như linked list. Ngoài ra, Mergesort có thể được sửa đổi để đếm số lần đảo ngược trong một mảng, với một hàm phụ trợ `merge_count` có độ phức tạp O(k) để đếm đảo ngược khi trộn hai mảng con.\n- Comparison-based sorting là một loại bài toán sắp xếp mà các thuật toán chỉ có thể truy cập các phần tử thông qua phép so sánh giữa chúng. Mergesort là một thuật toán sắp xếp dựa trên so sánh và được coi là tối ưu trong worst case với độ phức tạp O(n log n).\n\n**Mối quan hệ:**\n- Mergesort giải quyết bài toán Comparison-based sorting một cách hiệu quả.\n- Mergesort trong ngữ cảnh trộn các file tạm sử dụng Heap để quản lý các phần tử nhỏ nhất từ các file khác nhau, đảm bảo việc trộn hiệu quả.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n```python\ndef merge_sort_optimized(arr):\n    \"\"\"\n    Sử dụng một mảng phụ duy nhất cho toàn bộ quá trình\n    \"\"\"\n    n = len(arr)\n    temp = [0] * n\n    \n    def sort_helper(left, right):\n        if left < right:\n            mid = (left + right) // 2\n            sort_helper(left, mid)\n            sort_helper(mid + 1, right)\n            merge_with_temp(left, mid, right)\n    \n    def merge_with_temp(left, mid, right):\n        # Copy vào mảng tạm\n        for i in range(left, right + 1):\n            temp[i] = arr[i]\n        \n        i, j = left, mid + 1\n        k = left\n        \n        while i <= mid and j <= right:\n            if temp[i] <= temp[j]:\n                arr[k] = temp[i]\n                i += 1\n            else:\n                arr[k] = temp[j]\n                j += 1\n            k += 1\n        \n        while i <= mid:\n            arr[k] = temp[i]\n            i += 1\n            k += 1\n    \n    sort_helper(0, n - 1)\n    return arr\n```\n\n#### 3.3. Đặc điểm\n\n**Ưu điểm:**\n- ✅ **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- ✅ **Predictable:** Luôn O(n log n) cho mọi trường hợp\n- ✅ **Parallelizable:** Có thể song song hóa dễ dàng\n- ✅ **External sorting:** Thích hợp cho sắp xếp dữ liệu lớn không fit trong RAM\n\n**Nhược điểm:**\n- ❌ **Space:** Cần O(n) bộ nhớ phụ\n- ❌ **Not in-place:** (Phiên bản chuẩn)\n- ❌ **Overhead:** Chi phí đệ quy và copy dữ liệu\n\n---\n\n### 4. Các biến thể và tối ưu hóa\n\n#### 4.1. Natural Merge Sort\n\nTận dụng các phần đã sắp xếp tự nhiên trong mảng.\n\n```python\ndef natural_merge_sort(arr):\n    \"\"\"\n    Tận dụng các dãy con đã được sắp xếp sẵn\n    \"\"\"\n    n = len(arr)\n    \n    def get_runs():\n        \"\"\"Tìm các dãy con đã sắp xếp\"\"\"\n        runs = []\n        i = 0\n        \n        while i < n:\n            start = i\n            # Tìm dãy tăng dần\n            while i < n - 1 and arr[i] <= arr[i + 1]:\n                i += 1\n            runs.append((start, i))\n            i += 1\n        \n        return runs\n    \n    while True:\n        runs = get_runs()\n        if len(runs) <= 1:\n            break\n        \n        # Gộp các runs liên tiếp\n        new_runs = []\n        for i in range(0, len(runs), 2):\n            if i + 1 < len(runs):\n                left_start, left_end = runs[i]\n                right_start, right_end = runs[i + 1]\n                merge_inplace(arr, left_start, left_end, right_end)\n                new_runs.append((left_start, right_end))\n            else:\n                new_runs.append(runs[i])\n    \n    return arr\n```\n\n#### 4.2. Bottom-up Merge Sort\n\n```python\ndef bottom_up_merge_sort(arr):\n    \"\"\"\n    Merge sort không dùng đệ quy, gộp từ dưới lên\n    \"\"\"\n    n = len(arr)\n    width = 1\n    \n    while width < n:\n        left = 0\n        while left < n:\n            mid = min(left + width - 1, n - 1)\n            right = min(left + 2 * width - 1, n - 1)\n            \n            if mid < right:\n                merge_inplace(arr, left, mid, right)\n            \n            left += 2 * width\n        \n        width *= 2\n    \n    return arr\n```\n\n#### 4.3. Hybrid Merge Sort (Tim Sort inspired)\n\nKết hợp với Insertion Sort cho các mảng con nhỏ.\n\n\n**Các khái niệm quan trọng:**\n- Merge Sort (hoặc Mergesort) là một thuật toán sắp xếp hiệu quả dựa trên kỹ thuật chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chia mảng thành hai nửa, sắp xếp đệ quy từng nửa, sau đó trộn (gộp) hai nửa đã sắp xếp lại với nhau. Merge Sort là một thuật toán sắp xếp ổn định (stable) và có độ phức tạp thời gian O(n log n) trong mọi trường hợp (best, average, worst case). Độ phức tạp không gian của nó là O(n) do cần không gian phụ (mảng tạm) để thực hiện quá trình trộn. Merge Sort có thể được cài đặt bằng đệ quy hoặc lặp, thích hợp cho việc sắp xếp dữ liệu lớn không vừa trong RAM (external sorting), có thể song song hóa, và hiệu quả khi sắp xếp các cấu trúc dữ liệu như linked list. Ngoài ra, Mergesort có thể được sửa đổi để đếm số lần đảo ngược trong một mảng, với một hàm phụ trợ `merge_count` có độ phức tạp O(k) để đếm đảo ngược khi trộn hai mảng con.\n\n**Mối quan hệ:**\n- Mergesort giải quyết bài toán Comparison-based sorting một cách hiệu quả.\n- Mergesort trong ngữ cảnh trộn các file tạm sử dụng Heap để quản lý các phần tử nhỏ nhất từ các file khác nhau, đảm bảo việc trộn hiệu quả.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n    Segment(15, 18)\n]\nresult = merge_intervals(segments)\nprint(\"Các đoạn sau khi gộp:\", result)\n```\n\n#### 5.4. K-way Merge\n\n```python\nimport heapq\n\ndef k_way_merge(lists):\n    \"\"\"\n    Gộp k danh sách đã sắp xếp thành 1 danh sách\n    Ứng dụng: Merge output từ nhiều sorted files\n    \"\"\"\n    heap = []\n    result = []\n    \n    # Thêm phần tử đầu tiên của mỗi list vào heap\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    \n    # Extract min và thêm phần tử tiếp theo\n    while heap:\n        value, list_idx, element_idx = heapq.heappop(heap)\n        result.append(value)\n        \n        # Thêm phần tử tiếp theo từ cùng list\n        if element_idx + 1 < len(lists[list_idx]):\n            next_value = lists[list_idx][element_idx + 1]\n            heapq.heappush(heap, (next_value, list_idx, element_idx + 1))\n    \n    return result\n\n# Test\nlists = [\n    [1, 4, 7],\n    [2, 5, 8],\n    [3, 6, 9]\n]\nprint(\"K-way merge:\", k_way_merge(lists))\n```\n\n---\n\n### 6. So sánh với các thuật toán khác\n\n| Thuật toán | Best | Average | Worst | Space | Stable | In-place |\n|------------|------|---------|-------|-------|--------|----------|\n| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ | ❌ |\n| Quick Sort | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ | ✅ |\n| Heap Sort | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ | ✅ |\n| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) | ✅ | ✅ |\n\n#### 6.1. Khi nào sử dụng Merge Sort?\n\n**Nên sử dụng khi:**\n- ✅ Cần thuật toán stable\n- ✅ Cần độ phức tạp guaranteed O(n log n)\n- ✅ Sắp xếp linked list (không cần bộ nhớ phụ)\n- ✅ External sorting (dữ liệu không fit trong RAM)\n- ✅ Parallel/distributed sorting\n- ✅ Counting inversions\n- ✅ Dữ liệu đến dần dần (online)\n\n**Không nên sử dụng khi:**\n- ❌ Bộ nhớ bị hạn chế nghiêm ngặt\n- ❌ Cần in-place sorting\n- ❌ Mảng nhỏ (overhead đệ quy cao)\n\n---\n\n### 7. Merge Sort cho Linked List\n\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge_sort_linked_list(head):\n    \"\"\"\n    Merge sort cho linked list - O(1) space!\n    \"\"\"\n    if not head or not head.next:\n        return head\n    \n    # Tìm điểm giữa\n    slow = fast = head\n    prev = None\n    \n    while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Chia list thành 2 phần\n    prev.next = None\n    \n    # Sắp xếp đệ quy\n    left = merge_sort_linked_list(head)\n    right = merge_sort_linked_list(slow)\n    \n    # Merge\n    return merge_linked_lists(left, right)\n\ndef merge_linked_lists(l1, l2):\n    \"\"\"\n    Gộp 2 linked lists đã sắp xếp\n    \"\"\"\n    dummy = ListNode(0)\n    current = dummy\n    \n    while l1 and l2:\n        if l1.val <= l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n\n**Các khái niệm quan trọng:**\n- Merge Sort (hoặc Mergesort) là một thuật toán sắp xếp hiệu quả dựa trên kỹ thuật chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chia mảng thành hai nửa, sắp xếp đệ quy từng nửa, sau đó trộn (gộp) hai nửa đã sắp xếp lại với nhau. Merge Sort là một thuật toán sắp xếp ổn định (stable) và có độ phức tạp thời gian O(n log n) trong mọi trường hợp (best, average, worst case). Độ phức tạp không gian của nó là O(n) do cần không gian phụ (mảng tạm) để thực hiện quá trình trộn. Merge Sort có thể được cài đặt bằng đệ quy hoặc lặp, thích hợp cho việc sắp xếp dữ liệu lớn không vừa trong RAM (external sorting), có thể song song hóa, và hiệu quả khi sắp xếp các cấu trúc dữ liệu như linked list. Ngoài ra, Mergesort có thể được sửa đổi để đếm số lần đảo ngược trong một mảng, với một hàm phụ trợ `merge_count` có độ phức tạp O(k) để đếm đảo ngược khi trộn hai mảng con.\n\n**Mối quan hệ:**\n- Mergesort giải quyết bài toán Comparison-based sorting một cách hiệu quả.\n- Mergesort trong ngữ cảnh trộn các file tạm sử dụng Heap để quản lý các phần tử nhỏ nhất từ các file khác nhau, đảm bảo việc trộn hiệu quả."
        },
        "output_without_context": {
            "question": "So sánh hiệu suất của Mergesort và Heapsort trong việc xử lý dữ liệu lớn, thuật toán nào thường có hiệu suất tốt hơn trong trường hợp dữ liệu đã được sắp xếp một phần?",
            "answer": "Mergesort"
        }
    },
    {
        "topic_description": "Chủ đề này kết hợp kiến thức từ các tuần trước về cấu trúc dữ liệu (đặc biệt là queue và heap) và thuật toán sắp xếp. Học sinh sẽ được yêu cầu so sánh các cấu trúc này và hiểu rõ về ứng dụng của chúng trong việc sắp xếp và quản lý dữ liệu.",
        "output_with_context": {
            "question": "Khi nào nên sử dụng thuật toán Quick Sort để sắp xếp dữ liệu?",
            "answer": "Khi cần sắp xếp mảng trong RAM với yêu cầu tốc độ nhanh nhất trong trường hợp trung bình và không cần sắp xếp ổn định.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n| **In-place** | ✅ | ❌ | ✅ |\n| **Cache-friendly** | ✅ | ❌ | ⚠️ |\n\n#### 6.1. Khi nào dùng Quick Sort?\n\n**Nên dùng:**\n- ✅ Mảng trong RAM (in-memory sorting)\n- ✅ Cần sorting nhanh nhất average case\n- ✅ Bộ nhớ hạn chế\n- ✅ Random access data (array)\n- ✅ Không cần stable sort\n\n**Không nên dùng:**\n- ❌ Cần đảm bảo O(n log n) worst case\n- ❌ Cần stable sorting\n- ❌ Linked list (Merge Sort tốt hơn)\n- ❌ Dữ liệu đã gần sắp xếp (trừ khi dùng random pivot)\n\n---\n\n### 7. Quick Sort trong thư viện chuẩn\n\n#### 7.1. Python's sorted() và sort()\n\nPython sử dụng **Timsort** (hybrid của Merge Sort và Insertion Sort), không phải Quick Sort, vì:\n- Stable sorting\n- Tốt với dữ liệu có pattern\n- Worst case O(n log n) đảm bảo\n\n#### 7.2. C++ std::sort()\n\nC++ sử dụng **Introsort** (Introspective Sort):\n- Bắt đầu với Quick Sort\n- Chuyển sang Heap Sort nếu đệ quy quá sâu (tránh O(n²))\n- Dùng Insertion Sort cho mảng nhỏ\n\n#### 7.3. Java's Arrays.sort()\n\n- **Primitive types:** Dual-Pivot Quick Sort\n- **Object types:** Timsort (stable)\n\n---\n\n## Priority Queue & Binary Heap\n\n### 1. Giới thiệu Priority Queue\n\n#### 1.1. Khái niệm\n\n**Priority Queue (Hàng đợi ưu tiên)** là một cấu trúc dữ liệu trừu tượng trong đó mỗi phần tử có một độ ưu tiên (priority) được gán cho nó. Phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào.\n\n**Khác với Queue thông thường:**\n- Queue thông thường: FIFO (First In First Out)\n- Priority Queue: Phần tử có priority cao nhất ra trước\n\n**Ví dụ thực tế:**\n- **Hệ thống cấp cứu:** Bệnh nhân nguy kịch được ưu tiên khám trước\n- **CPU Scheduling:** Process có priority cao được xử lý trước\n- **Dijkstra Algorithm:** Chọn đỉnh có khoảng cách nhỏ nhất\n- **A* Search:** Chọn node có f(n) nhỏ nhất\n- **Huffman Coding:** Xây dựng cây mã hóa\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Insert/Enqueue:** Thêm phần tử với priority\n**b) Extract-Max/Min:** Lấy và xóa phần tử có priority cao/thấp nhất\n**c) Peek/Top:** Xem phần tử có priority cao/thấp nhất\n**d) Change Priority:** Thay đổi priority của phần tử\n**e) Delete:** Xóa phần tử bất kỳ\n\n#### 1.3. Các cách cài đặt\n\n| Cài đặt | Insert | Extract-Max | Peek |\n|---------|--------|-------------|------|\n| Array (unsorted) | O(1) | O(n) | O(n) |\n| Array (sorted) | O(n) | O(1) | O(1) |\n| Linked List | O(n) | O(1) | O(1) |\n| **Binary Heap** | **O(log n)** | **O(log n)** | **O(1)** |\n| Fibonacci Heap | O(1) | O(log n) | O(1) |\n\n\n**Các khái niệm quan trọng:**\n- Priority Queue có thể được cài đặt bằng Unsorted Array hoặc Sorted Array. Với Unsorted Array, phép toán Insert có độ phức tạp O(1) do chỉ cần thêm vào cuối mảng, nhưng Extract-Max/Min và Peek có độ phức tạp O(n) vì yêu cầu duyệt toàn bộ mảng. Ngược lại, với Sorted Array, phép toán Insert có độ phức tạp O(n) để duy trì thứ tự, nhưng Extract-Max/Min và Peek có độ phức tạp O(1) do phần tử ưu tiên cao nhất/thấp nhất nằm ở đầu hoặc cuối mảng.\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n\n**Mối quan hệ:**\n- Phép toán Insert trên Unsorted Array (khi dùng làm Priority Queue) có độ phức tạp O(1).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n| Delete | O(log n) | O(log n) avg, O(n) worst | O(n) |\n| Build | O(n) | O(n log n) | O(n log n) |\n\n**Khi nào dùng Heap?**\n- ✅ Cần extract min/max nhiều lần\n- ✅ Priority Queue\n- ✅ Tìm k largest/smallest elements\n- ✅ Median trong stream\n- ✅ Scheduling problems\n\n**Khi nào không dùng Heap?**\n- ❌ Cần search phần tử cụ thể (dùng BST)\n- ❌ Cần duyệt theo thứ tự (dùng BST)\n- ❌ Cần truy cập ngẫu nhiên (dùng array)\n\n---\n\n## Binary Search Tree \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Binary Search Tree (BST)** là một cây nhị phân có tính chất đặc biệt:\n- Tất cả các node trong cây con trái có giá trị **< node gốc**\n- Tất cả các node trong cây con phải có giá trị **> node gốc**\n- Cây con trái và cây con phải cũng là BST\n\n**Ví dụ BST hợp lệ:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  7 13\n```\n\n**Không phải BST:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  9 13    <- 9 > 8, không thể ở cây con trái\n```\n\n#### 1.2. Tính chất quan trọng\n\n**a) Duyệt Inorder cho thứ tự tăng dần:**\n- Duyệt BST theo Inorder (Left-Root-Right) cho dãy số tăng dần\n- Ví dụ trên: 1, 3, 4, 6, 7, 8, 10, 13, 14\n\n**b) Tìm kiếm hiệu quả:**\n- Có thể loại bỏ 1 nửa cây ở mỗi bước\n- Average case: O(log n)\n- Worst case: O(n) - cây thoái hóa thành linked list\n\n**c) Dynamic data structure:**\n- Dễ dàng insert và delete\n- Không cần biết trước kích thước\n\n#### 1.3. Ứng dụng\n\n- **Database indexing:** B-Tree, B+ Tree (biến thể của BST)\n- **File system:** Tổ chức thư mục\n- **Expression parsing:** Cây biểu thức\n- **Priority Queue:** Có thể implement bằng BST\n- **Auto-complete:** Trie (dạng đặc biệt của cây)\n\n---\n\n### 2. Cấu trúc Node và BST\n\n#### 2.1. Định nghĩa Node\n\n```python\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n    \n    def __repr__(self):\n        return f\"Node({self.val})\"\n```\n\n#### 2.2. Lớp BST\n\n```python\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def is_empty(self):\n        return self.root is None\n    \n    def get_root(self):\n        return self.root\n```\n\n---\n\n### 3. Các thao tác cơ bản\n\n#### 3.1. Search (Tìm kiếm)\n\n```python\n    def search(self, val):\n        \"\"\"\n        Tìm node có giá trị val\n        Time: O(h) với h là chiều cao cây\n        Average: O(log n), Worst: O(n)\n        \"\"\"\n        return self._search_recursive(self.root, val)\n    \n\n**Các khái niệm quan trọng:**\n- Scheduling problems là các bài toán liên quan đến việc sắp xếp thứ tự thực hiện các tác vụ dựa trên một số tiêu chí ưu tiên. Priority Queue (thường cài đặt bằng Heap) là một cấu trúc dữ liệu lý tưởng để giải quyết các bài toán này.\n\n**Mối quan hệ:**\n- Binary Heap được sử dụng để giải quyết các bài toán lập lịch.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n### 1. Giới thiệu về Sắp xếp\n\n#### 1.1. Khái niệm\n\nSắp xếp (Sorting) là quá trình sắp đặt các phần tử trong một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một trong những thao tác cơ bản và quan trọng nhất trong khoa học máy tính.\n\n**Tại sao sắp xếp quan trọng?**\n- Giúp tìm kiếm nhanh hơn (Binary Search)\n- Tối ưu hóa các thuật toán khác\n- Cải thiện hiệu suất của database\n- Trực quan hóa và phân tích dữ liệu\n\n#### 1.2. Phân loại thuật toán sắp xếp\n\n**a) Theo phương pháp:**\n- **Comparison-based:** So sánh các phần tử (Bubble, Selection, Insertion, Merge, Quick)\n- **Non-comparison-based:** Không so sánh trực tiếp (Counting, Radix, Bucket)\n\n**b) Theo tính ổn định (Stability):**\n- **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- **Unstable:** Không đảm bảo thứ tự tương đối\n\n**c) Theo bộ nhớ:**\n- **In-place:** Sử dụng O(1) bộ nhớ phụ\n- **Out-of-place:** Cần thêm bộ nhớ phụ\n\n#### 1.3. Các tiêu chí đánh giá\n\n- **Time Complexity:** Độ phức tạp thời gian (Best, Average, Worst case)\n- **Space Complexity:** Độ phức tạp không gian\n- **Stability:** Tính ổn định\n- **Adaptive:** Hiệu quả với dữ liệu đã gần sắp xếp\n- **Online:** Có thể xử lý dữ liệu đến theo thời gian thực\n\n---\n\n### 2. Bubble Sort (Sắp xếp nổi bọt)\n\n#### 2.1. Ý tưởng\n\nBubble Sort so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này lặp lại cho đến khi mảng được sắp xếp. Phần tử lớn nhất sẽ \"nổi\" lên vị trí cuối cùng sau mỗi lượt.\n\n**Hình ảnh trực quan:**\n- Lượt 1: Phần tử lớn nhất \"nổi\" lên cuối\n- Lượt 2: Phần tử lớn thứ hai nổi lên vị trí kế cuối\n- Tiếp tục cho đến khi mảng được sắp xếp\n\n#### 2.2. Thuật toán\n\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # Duyệt qua tất cả các phần tử\n    for i in range(n):\n        # Cờ để tối ưu hóa\n        swapped = False\n        \n        # Phần tử cuối cùng i phần tử đã được sắp xếp\n        for j in range(0, n - i - 1):\n            # So sánh phần tử liền kề\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # Nếu không có hoán đổi nào, mảng đã sắp xếp\n        if not swapped:\n            break\n    \n    return arr\n\n# Test\narr = [64, 34, 25, 12, 22, 11, 90]\n\n**Các khái niệm quan trọng:**\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Sorting tối ưu hóa Binary Search bằng cách sắp xếp dữ liệu, cho phép Binary Search hoạt động hiệu quả hơn với độ phức tạp O(log n).\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn."
        },
        "output_without_context": {
            "question": "Trong các cấu trúc dữ liệu, cấu trúc nào thường được sử dụng để quản lý dữ liệu theo thứ tự ưu tiên trong thuật toán sắp xếp?",
            "answer": "Heap"
        }
    }
]