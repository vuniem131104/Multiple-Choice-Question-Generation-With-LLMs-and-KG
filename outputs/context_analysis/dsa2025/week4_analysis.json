[
    {
        "topic_description": "Khái niệm tổng quan về Quicksort, một trong những thuật toán sắp xếp cổ điển, bao gồm cách hoạt động của nó qua ba bước chính. Học sinh nên biết cách thuật toán thực hiện xáo trộn, phân vùng và sắp xếp đệ quy. Nội dung có thể được kiểm tra thông qua định nghĩa và mô tả các bước của thuật toán.",
        "output_with_context": {
            "question": "Quicksort là thuật toán sắp xếp sử dụng kỹ thuật nào để phân chia mảng?",
            "answer": "Chia để trị (Divide and Conquer)",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n    \n    current.next = l1 if l1 else l2\n    \n    return dummy.next\n\n# Helper function\ndef print_list(head):\n    values = []\n    while head:\n        values.append(head.val)\n        head = head.next\n    print(values)\n\n# Test\nhead = ListNode(4, ListNode(2, ListNode(1, ListNode(3))))\nprint(\"Trước khi sắp xếp:\")\nprint_list(head)\nsorted_head = merge_sort_linked_list(head)\nprint(\"Sau khi sắp xếp:\")\nprint_list(sorted_head)\n```\n\n---\n\n### 8. Parallel Merge Sort\n\n```python\nfrom concurrent.futures import ThreadPoolExecutor\nimport threading\n\ndef parallel_merge_sort(arr, depth=0, max_depth=3):\n    \"\"\"\n    Merge sort song song sử dụng threads\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Sử dụng parallel khi depth nhỏ\n    if depth < max_depth:\n        with ThreadPoolExecutor(max_workers=2) as executor:\n            future_left = executor.submit(parallel_merge_sort, left, depth + 1, max_depth)\n            future_right = executor.submit(parallel_merge_sort, right, depth + 1, max_depth)\n            \n            left = future_left.result()\n            right = future_right.result()\n    else:\n        # Sequential cho các phần nhỏ\n        left = merge_sort(left)\n        right = merge_sort(right)\n    \n    return merge(left, right)\n\n# Test\nimport time\narr = list(range(10000, 0, -1))\n\nstart = time.time()\nsorted_arr = merge_sort(arr.copy())\nsequential_time = time.time() - start\n\nstart = time.time()\nsorted_arr = parallel_merge_sort(arr.copy())\nparallel_time = time.time() - start\n\nprint(f\"Sequential: {sequential_time:.4f}s\")\nprint(f\"Parallel: {parallel_time:.4f}s\")\nprint(f\"Speedup: {sequential_time/parallel_time:.2f}x\")\n```\n\n---\n\n## Quicksort\n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\nQuick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật **Chia để trị (Divide and Conquer)**. Thuật toán chọn một phần tử làm \"pivot\" (chốt), phân hoạch mảng sao cho các phần tử nhỏ hơn pivot ở bên trái và các phần tử lớn hơn ở bên phải, sau đó đệ quy sắp xếp hai phần.\n\n**Đặc điểm nổi bật:**\n- Được phát minh bởi Tony Hoare năm 1960\n- Là thuật toán sắp xếp phổ biến nhất trong thực tế\n- Average case O(n log n), nhưng worst case O(n²)\n- In-place sorting (không cần bộ nhớ phụ nhiều)\n\n#### 1.2. Ý tưởng chính\n\n**Nguyên lý:**\n1. **Chọn Pivot:** Chọn một phần tử làm pivot (có thể là đầu, cuối, giữa, hoặc random)\n2. **Partition:** Sắp xếp lại mảng sao cho:\n   - Tất cả phần tử < pivot ở bên trái\n   - Tất cả phần tử > pivot ở bên phải\n   - Pivot ở đúng vị trí cuối cùng\n3. **Đệ quy:** Áp dụng quick sort cho phần trái và phần phải\n\n**Ví dụ trực quan:**\n```\nMảng: [10, 7, 8, 9, 1, 5]\nPivot: 5 (phần tử cuối)\n\nSau partition:\n[1] [5] [7, 8, 9, 10]\n ^   ^   ^\n Trái  Pivot  Phải\n\nĐệ quy sắp xếp [7, 8, 9, 10]:\nPivot: 10\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n- Partition (phân hoạch) là một phép toán trong thuật toán Quick Sort, có nhiệm vụ sắp xếp lại mảng con sao cho tất cả các phần tử nhỏ hơn pivot nằm ở bên trái của pivot, và tất cả các phần tử lớn hơn pivot nằm ở bên phải của pivot. Sau phép toán này, pivot sẽ nằm ở đúng vị trí cuối cùng của nó trong mảng đã sắp xếp.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n    lt = low       # arr[low..lt-1] < pivot\n    i = low + 1    # arr[lt..i-1] == pivot\n    gt = high      # arr[gt+1..high] > pivot\n    \n    while i <= gt:\n        if arr[i] < pivot:\n            arr[lt], arr[i] = arr[i], arr[lt]\n            lt += 1\n            i += 1\n        elif arr[i] > pivot:\n            arr[i], arr[gt] = arr[gt], arr[i]\n            gt -= 1\n        else:\n            i += 1\n    \n    return lt, gt\n\ndef quick_sort_3way(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort với 3-way partitioning\n    Tối ưu cho mảng có nhiều phần tử trùng\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        lt, gt = three_way_partition(arr, low, high)\n        quick_sort_3way(arr, low, lt - 1)\n        quick_sort_3way(arr, gt + 1, high)\n    \n    return arr\n\n# Test với mảng có nhiều phần tử trùng\narr = [4, 9, 4, 4, 1, 9, 4, 4, 9, 4, 4, 1, 4]\nprint(\"Mảng có nhiều phần tử trùng:\", arr)\nprint(\"Sau 3-way quick sort:\", quick_sort_3way(arr.copy()))\n```\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Quick Select - Tìm phần tử thứ k\n\n```python\ndef quick_select(arr, k):\n    \"\"\"\n    Tìm phần tử thứ k nhỏ nhất (0-indexed)\n    Average: O(n), Worst: O(n²)\n    \"\"\"\n    def select(arr, low, high, k):\n        if low == high:\n            return arr[low]\n        \n        pivot_index = partition(arr, low, high)\n        \n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return select(arr, low, pivot_index - 1, k)\n        else:\n            return select(arr, pivot_index + 1, high, k)\n    \n    return select(arr, 0, len(arr) - 1, k)\n\n# Test\narr = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(f\"Phần tử thứ {k+1} nhỏ nhất:\", quick_select(arr.copy(), k))\n\n# Tìm median\ndef find_median(arr):\n    n = len(arr)\n    if n % 2 == 1:\n        return quick_select(arr, n // 2)\n    else:\n        return (quick_select(arr.copy(), n // 2 - 1) + \n                quick_select(arr.copy(), n // 2)) / 2\n\nprint(\"Median:\", find_median([3, 2, 1, 5, 6, 4]))\n```\n\n#### 5.2. Kth Largest Element\n\n```python\ndef find_kth_largest(arr, k):\n    \"\"\"\n    Tìm phần tử lớn thứ k\n    \"\"\"\n    # Phần tử lớn thứ k = phần tử thứ (n-k) từ trái\n    return quick_select(arr, len(arr) - k)\n\n# Test\narr = [3, 2, 3, 1, 2, 4, 5, 5, 6]\nprint(f\"Phần tử lớn thứ 4:\", find_kth_largest(arr, 4))\n```\n\n---\n\n### 6. So sánh với các thuật toán khác\n\n| Đặc điểm | Quick Sort | Merge Sort | Heap Sort |\n|----------|------------|------------|-----------|\n| **Average Time** | O(n log n) | O(n log n) | O(n log n) |\n| **Worst Time** | O(n²) | O(n log n) | O(n log n) |\n| **Space** | O(log n) | O(n) | O(1) |\n| **Stable** | ❌ | ✅ | ❌ |\n\n**Các khái niệm quan trọng:**\n- quick_sort_3way là một phiên bản của Quicksort sử dụng kỹ thuật 3-way partitioning. Thuật toán này tối ưu cho các mảng có nhiều phần tử trùng lặp bằng cách nhóm tất cả các phần tử bằng pivot vào giữa, sau đó chỉ đệ quy sắp xếp hai phần còn lại (nhỏ hơn pivot và lớn hơn pivot). Điều này giúp giảm số lượng phần tử cần xử lý đệ quy, cải thiện hiệu suất trong các trường hợp cụ thể. Độ phức tạp thời gian trung bình là O(n log n), worst case là O(n²).\n- Divide and Conquer (Chia để trị) là một kỹ thuật thiết kế thuật toán mạnh mẽ, bao gồm ba bước chính: Chia (chia bài toán lớn thành các bài toán con nhỏ hơn cùng loại), Trị (giải quyết đệ quy các bài toán con), và Kết hợp (kết hợp các lời giải của bài toán con để tạo ra lời giải cho bài toán ban đầu). Mergesort và Quicksort là những ví dụ điển hình áp dụng kỹ thuật này.\n\n**Mối quan hệ:**\n- quick_sort_3way là một biến thể của Quicksort, được tối ưu hóa cho các mảng có nhiều phần tử trùng lặp.\n- Quicksort áp dụng kỹ thuật chia để trị.\n- quick_sort_3way có độ phức tạp thời gian xấu nhất O(n²).\n- quick_sort_3way có độ phức tạp thời gian trung bình O(n log n).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n### 1. Giới thiệu về Sắp xếp\n\n#### 1.1. Khái niệm\n\nSắp xếp (Sorting) là quá trình sắp đặt các phần tử trong một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một trong những thao tác cơ bản và quan trọng nhất trong khoa học máy tính.\n\n**Tại sao sắp xếp quan trọng?**\n- Giúp tìm kiếm nhanh hơn (Binary Search)\n- Tối ưu hóa các thuật toán khác\n- Cải thiện hiệu suất của database\n- Trực quan hóa và phân tích dữ liệu\n\n#### 1.2. Phân loại thuật toán sắp xếp\n\n**a) Theo phương pháp:**\n- **Comparison-based:** So sánh các phần tử (Bubble, Selection, Insertion, Merge, Quick)\n- **Non-comparison-based:** Không so sánh trực tiếp (Counting, Radix, Bucket)\n\n**b) Theo tính ổn định (Stability):**\n- **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- **Unstable:** Không đảm bảo thứ tự tương đối\n\n**c) Theo bộ nhớ:**\n- **In-place:** Sử dụng O(1) bộ nhớ phụ\n- **Out-of-place:** Cần thêm bộ nhớ phụ\n\n#### 1.3. Các tiêu chí đánh giá\n\n- **Time Complexity:** Độ phức tạp thời gian (Best, Average, Worst case)\n- **Space Complexity:** Độ phức tạp không gian\n- **Stability:** Tính ổn định\n- **Adaptive:** Hiệu quả với dữ liệu đã gần sắp xếp\n- **Online:** Có thể xử lý dữ liệu đến theo thời gian thực\n\n---\n\n### 2. Bubble Sort (Sắp xếp nổi bọt)\n\n#### 2.1. Ý tưởng\n\nBubble Sort so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này lặp lại cho đến khi mảng được sắp xếp. Phần tử lớn nhất sẽ \"nổi\" lên vị trí cuối cùng sau mỗi lượt.\n\n**Hình ảnh trực quan:**\n- Lượt 1: Phần tử lớn nhất \"nổi\" lên cuối\n- Lượt 2: Phần tử lớn thứ hai nổi lên vị trí kế cuối\n- Tiếp tục cho đến khi mảng được sắp xếp\n\n#### 2.2. Thuật toán\n\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # Duyệt qua tất cả các phần tử\n    for i in range(n):\n        # Cờ để tối ưu hóa\n        swapped = False\n        \n        # Phần tử cuối cùng i phần tử đã được sắp xếp\n        for j in range(0, n - i - 1):\n            # So sánh phần tử liền kề\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # Nếu không có hoán đổi nào, mảng đã sắp xếp\n        if not swapped:\n            break\n    \n    return arr\n\n# Test\narr = [64, 34, 25, 12, 22, 11, 90]\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Bubble Sort (Sắp xếp nổi bọt) là một thuật toán sắp xếp đơn giản, thuộc loại comparison-based, hoạt động bằng cách lặp đi lặp lại việc đi qua danh sách, so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này đẩy phần tử lớn nhất (hoặc nhỏ nhất) về cuối mảng sau mỗi lần lặp và lặp lại cho đến khi không còn cặp nào cần hoán đổi, tức là mảng đã được sắp xếp. Thuật toán này đơn giản, dễ cài đặt, stable và adaptive. Để tối ưu hóa, nó có thể sử dụng một cờ `swapped` để dừng sớm nếu không có hoán đổi nào xảy ra trong một lượt. Độ phức tạp thời gian: Best case O(n) (với tối ưu hóa dừng sớm), Average case O(n²), Worst case O(n²). Độ phức tạp không gian: O(1) vì nó là thuật toán tại chỗ (in-place).\n\n**Mối quan hệ:**\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn.\n- Bubble Sort là một thuật toán thuộc loại Comparison-based sorting vì nó dựa trên việc so sánh các cặp phần tử liền kề.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n[7, 8, 9] [10] []\n\nTiếp tục...\nKết quả: [1, 5, 7, 8, 9, 10]\n```\n\n---\n\n### 2. Thuật toán Quick Sort\n\n#### 2.1. Cài đặt cơ bản (Lomuto Partition)\n\n```python\ndef quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Lomuto partition scheme\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Partition và lấy vị trí pivot\n        pivot_index = partition(arr, low, high)\n        \n        # Đệ quy sắp xếp 2 phần\n        quick_sort(arr, low, pivot_index - 1)\n        quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef partition(arr, low, high):\n    \"\"\"\n    Lomuto partition: Chọn phần tử cuối làm pivot\n    \"\"\"\n    pivot = arr[high]\n    i = low - 1  # Index của phần tử nhỏ hơn\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Đặt pivot vào vị trí đúng\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", quick_sort(arr.copy()))\n```\n\n#### 2.2. Hoare Partition Scheme (Hiệu quả hơn)\n\n```python\ndef quick_sort_hoare(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Hoare partition scheme\n    Hiệu quả hơn Lomuto (ít swap hơn 3 lần)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = hoare_partition(arr, low, high)\n        quick_sort_hoare(arr, low, pivot_index)\n        quick_sort_hoare(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef hoare_partition(arr, low, high):\n    \"\"\"\n    Hoare partition: Pivot ở giữa, 2 con trỏ từ 2 đầu\n    \"\"\"\n    pivot = arr[low]\n    i = low - 1\n    j = high + 1\n    \n    while True:\n        # Tìm phần tử >= pivot từ trái\n        i += 1\n        while arr[i] < pivot:\n            i += 1\n        \n        # Tìm phần tử <= pivot từ phải\n        j -= 1\n        while arr[j] > pivot:\n            j -= 1\n        \n        # Nếu 2 con trỏ gặp nhau\n        if i >= j:\n            return j\n        \n        # Swap\n        arr[i], arr[j] = arr[j], arr[i]\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Hoare Partition:\", quick_sort_hoare(arr.copy()))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Best Case: O(n log n)**\n- Xảy ra khi pivot luôn chia mảng thành 2 phần bằng nhau\n- Độ cao cây đệ quy: log n\n- Mỗi tầng: O(n) cho partition\n- Tổng: O(n log n)\n\n**Average Case: O(n log n)**\n- Với pivot ngẫu nhiên, expected time là O(n log n)\n- Ngay cả khi không chia đều (tỉ lệ 9:1), vẫn là O(n log n)\n\n**Worst Case: O(n²)**\n- Xảy ra khi pivot luôn là phần tử nhỏ nhất hoặc lớn nhất\n\n**Các khái niệm quan trọng:**\n- Lomuto Partition và Hoare Partition là hai kỹ thuật phân hoạch được sử dụng trong thuật toán Quicksort. Lomuto Partition chọn phần tử cuối cùng của mảng làm pivot, duyệt qua mảng để di chuyển các phần tử nhỏ hơn hoặc bằng pivot về phía bên trái, sau đó đặt pivot vào vị trí đúng của nó, nhưng có thể dẫn đến nhiều phép swap hơn. Ngược lại, Hoare Partition thường hiệu quả hơn (ít swap hơn), chọn phần tử đầu tiên hoặc giữa làm pivot, và sử dụng hai con trỏ di chuyển từ hai đầu mảng vào giữa để tìm và hoán đổi các phần tử không đúng vị trí so với pivot, trả về chỉ số của phần tử cuối cùng trong phần bên trái của pivot.\n\n**Mối quan hệ:**\n- Quicksort có thể sử dụng Lomuto Partition để phân hoạch mảng trong quá trình sắp xếp."
        },
        "output_without_context": {
            "question": "Quicksort là thuật toán sắp xếp hoạt động qua ba bước chính nào?",
            "answer": "Xáo trộn, phân vùng và sắp xếp đệ quy."
        }
    },
    {
        "topic_description": "Thảo luận về quy trình phân vùng trong thuật toán Quicksort, bao gồm cách sử dụng các con trỏ để quét mảng và hoán đổi các phần tử. Học sinh cần hiểu rõ các bước thực hiện phân vùng và tối ưu hóa sử dụng trong mã Java để thực hiện điều này. Nội dung có thể được kiểm tra thông qua phân tích và mô tả quy trình.",
        "output_with_context": {
            "question": "Trong quy trình phân vùng của thuật toán Quicksort, phần tử nào được chọn làm pivot để phân chia mảng thành các phần tử nhỏ hơn và lớn hơn?",
            "answer": "Pivot",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n    \n    current.next = l1 if l1 else l2\n    \n    return dummy.next\n\n# Helper function\ndef print_list(head):\n    values = []\n    while head:\n        values.append(head.val)\n        head = head.next\n    print(values)\n\n# Test\nhead = ListNode(4, ListNode(2, ListNode(1, ListNode(3))))\nprint(\"Trước khi sắp xếp:\")\nprint_list(head)\nsorted_head = merge_sort_linked_list(head)\nprint(\"Sau khi sắp xếp:\")\nprint_list(sorted_head)\n```\n\n---\n\n### 8. Parallel Merge Sort\n\n```python\nfrom concurrent.futures import ThreadPoolExecutor\nimport threading\n\ndef parallel_merge_sort(arr, depth=0, max_depth=3):\n    \"\"\"\n    Merge sort song song sử dụng threads\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Sử dụng parallel khi depth nhỏ\n    if depth < max_depth:\n        with ThreadPoolExecutor(max_workers=2) as executor:\n            future_left = executor.submit(parallel_merge_sort, left, depth + 1, max_depth)\n            future_right = executor.submit(parallel_merge_sort, right, depth + 1, max_depth)\n            \n            left = future_left.result()\n            right = future_right.result()\n    else:\n        # Sequential cho các phần nhỏ\n        left = merge_sort(left)\n        right = merge_sort(right)\n    \n    return merge(left, right)\n\n# Test\nimport time\narr = list(range(10000, 0, -1))\n\nstart = time.time()\nsorted_arr = merge_sort(arr.copy())\nsequential_time = time.time() - start\n\nstart = time.time()\nsorted_arr = parallel_merge_sort(arr.copy())\nparallel_time = time.time() - start\n\nprint(f\"Sequential: {sequential_time:.4f}s\")\nprint(f\"Parallel: {parallel_time:.4f}s\")\nprint(f\"Speedup: {sequential_time/parallel_time:.2f}x\")\n```\n\n---\n\n## Quicksort\n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\nQuick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật **Chia để trị (Divide and Conquer)**. Thuật toán chọn một phần tử làm \"pivot\" (chốt), phân hoạch mảng sao cho các phần tử nhỏ hơn pivot ở bên trái và các phần tử lớn hơn ở bên phải, sau đó đệ quy sắp xếp hai phần.\n\n**Đặc điểm nổi bật:**\n- Được phát minh bởi Tony Hoare năm 1960\n- Là thuật toán sắp xếp phổ biến nhất trong thực tế\n- Average case O(n log n), nhưng worst case O(n²)\n- In-place sorting (không cần bộ nhớ phụ nhiều)\n\n#### 1.2. Ý tưởng chính\n\n**Nguyên lý:**\n1. **Chọn Pivot:** Chọn một phần tử làm pivot (có thể là đầu, cuối, giữa, hoặc random)\n2. **Partition:** Sắp xếp lại mảng sao cho:\n   - Tất cả phần tử < pivot ở bên trái\n   - Tất cả phần tử > pivot ở bên phải\n   - Pivot ở đúng vị trí cuối cùng\n3. **Đệ quy:** Áp dụng quick sort cho phần trái và phần phải\n\n**Ví dụ trực quan:**\n```\nMảng: [10, 7, 8, 9, 1, 5]\nPivot: 5 (phần tử cuối)\n\nSau partition:\n[1] [5] [7, 8, 9, 10]\n ^   ^   ^\n Trái  Pivot  Phải\n\nĐệ quy sắp xếp [7, 8, 9, 10]:\nPivot: 10\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n- Partition (phân hoạch) là một phép toán trong thuật toán Quick Sort, có nhiệm vụ sắp xếp lại mảng con sao cho tất cả các phần tử nhỏ hơn pivot nằm ở bên trái của pivot, và tất cả các phần tử lớn hơn pivot nằm ở bên phải của pivot. Sau phép toán này, pivot sẽ nằm ở đúng vị trí cuối cùng của nó trong mảng đã sắp xếp.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n[7, 8, 9] [10] []\n\nTiếp tục...\nKết quả: [1, 5, 7, 8, 9, 10]\n```\n\n---\n\n### 2. Thuật toán Quick Sort\n\n#### 2.1. Cài đặt cơ bản (Lomuto Partition)\n\n```python\ndef quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Lomuto partition scheme\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Partition và lấy vị trí pivot\n        pivot_index = partition(arr, low, high)\n        \n        # Đệ quy sắp xếp 2 phần\n        quick_sort(arr, low, pivot_index - 1)\n        quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef partition(arr, low, high):\n    \"\"\"\n    Lomuto partition: Chọn phần tử cuối làm pivot\n    \"\"\"\n    pivot = arr[high]\n    i = low - 1  # Index của phần tử nhỏ hơn\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Đặt pivot vào vị trí đúng\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", quick_sort(arr.copy()))\n```\n\n#### 2.2. Hoare Partition Scheme (Hiệu quả hơn)\n\n```python\ndef quick_sort_hoare(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Hoare partition scheme\n    Hiệu quả hơn Lomuto (ít swap hơn 3 lần)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = hoare_partition(arr, low, high)\n        quick_sort_hoare(arr, low, pivot_index)\n        quick_sort_hoare(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef hoare_partition(arr, low, high):\n    \"\"\"\n    Hoare partition: Pivot ở giữa, 2 con trỏ từ 2 đầu\n    \"\"\"\n    pivot = arr[low]\n    i = low - 1\n    j = high + 1\n    \n    while True:\n        # Tìm phần tử >= pivot từ trái\n        i += 1\n        while arr[i] < pivot:\n            i += 1\n        \n        # Tìm phần tử <= pivot từ phải\n        j -= 1\n        while arr[j] > pivot:\n            j -= 1\n        \n        # Nếu 2 con trỏ gặp nhau\n        if i >= j:\n            return j\n        \n        # Swap\n        arr[i], arr[j] = arr[j], arr[i]\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Hoare Partition:\", quick_sort_hoare(arr.copy()))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Best Case: O(n log n)**\n- Xảy ra khi pivot luôn chia mảng thành 2 phần bằng nhau\n- Độ cao cây đệ quy: log n\n- Mỗi tầng: O(n) cho partition\n- Tổng: O(n log n)\n\n**Average Case: O(n log n)**\n- Với pivot ngẫu nhiên, expected time là O(n log n)\n- Ngay cả khi không chia đều (tỉ lệ 9:1), vẫn là O(n log n)\n\n**Worst Case: O(n²)**\n- Xảy ra khi pivot luôn là phần tử nhỏ nhất hoặc lớn nhất\n\n**Các khái niệm quan trọng:**\n- Partition là một hàm phụ trợ và phép toán cốt lõi được sử dụng trong các thuật toán Quicksort và Quick Select. Chức năng chính của nó là phân chia hoặc sắp xếp lại một mảng (hoặc mảng con) thành hai phần dựa trên một phần tử được chọn làm pivot. Cụ thể, tất cả các phần tử nhỏ hơn (hoặc nhỏ hơn hoặc bằng) pivot được đặt ở một bên của pivot, và tất cả các phần tử lớn hơn pivot được đặt ở phía còn lại. Sau khi phân hoạch, hàm này trả về chỉ số (hoặc vị trí cuối cùng) của pivot.\n- Lomuto Partition và Hoare Partition là hai kỹ thuật phân hoạch được sử dụng trong thuật toán Quicksort. Lomuto Partition chọn phần tử cuối cùng của mảng làm pivot, duyệt qua mảng để di chuyển các phần tử nhỏ hơn hoặc bằng pivot về phía bên trái, sau đó đặt pivot vào vị trí đúng của nó, nhưng có thể dẫn đến nhiều phép swap hơn. Ngược lại, Hoare Partition thường hiệu quả hơn (ít swap hơn), chọn phần tử đầu tiên hoặc giữa làm pivot, và sử dụng hai con trỏ di chuyển từ hai đầu mảng vào giữa để tìm và hoán đổi các phần tử không đúng vị trí so với pivot, trả về chỉ số của phần tử cuối cùng trong phần bên trái của pivot.\n\n**Mối quan hệ:**\n- Hoare Partition thường hiệu quả hơn Lomuto Partition do thực hiện ít phép swap hơn.\n- Quick Select sử dụng hàm partition để phân chia mảng và xác định vị trí của pivot.\n- Quicksort có thể sử dụng Hoare Partition để phân hoạch mảng trong quá trình sắp xếp, đây là một phương pháp thường hiệu quả hơn Lomuto Partition.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n- Ví dụ: Mảng đã sắp xếp với pivot là phần tử đầu/cuối\n- Độ cao cây đệ quy: n\n- Tổng: O(n²)\n\n**Minh họa Worst Case:**\n```\nMảng: [1, 2, 3, 4, 5] (pivot = cuối)\n\nLần 1: [1,2,3,4] | 5 | []       - n operations\nLần 2: [1,2,3] | 4 | []         - (n-1) operations\nLần 3: [1,2] | 3 | []           - (n-2) operations\n...\nTổng: n + (n-1) + (n-2) + ... + 1 = n(n+1)/2 = O(n²)\n```\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:**\n- **Best/Average case:** O(log n) - Chiều cao cây đệ quy\n- **Worst case:** O(n) - Cây đệ quy thoái hóa\n\n**In-place:** ✅ (không cần mảng phụ, chỉ dùng stack cho đệ quy)\n\n#### 3.3. Đặc điểm\n\n**Ưu điểm:**\n- ✅ Rất nhanh trong thực tế (cache-friendly)\n- ✅ In-place (O(log n) space)\n- ✅ Dễ song song hóa\n- ✅ Có thể tối ưu cho nhiều trường hợp\n\n**Nhược điểm:**\n- ❌ Unstable (không giữ thứ tự tương đối)\n- ❌ Worst case O(n²) (có thể tránh với random pivot)\n- ❌ Không tốt với dữ liệu đã sắp xếp (nếu không tối ưu)\n\n---\n\n### 4. Tối ưu hóa Quick Sort\n\n#### 4.1. Random Pivot (Tránh worst case)\n\n```python\nimport random\n\ndef randomized_partition(arr, low, high):\n    \"\"\"\n    Chọn pivot ngẫu nhiên\n    \"\"\"\n    # Chọn random index và đổi về cuối\n    random_index = random.randint(low, high)\n    arr[random_index], arr[high] = arr[high], arr[random_index]\n    return partition(arr, low, high)\n\ndef randomized_quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Randomized Quick Sort - Tránh worst case O(n²)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = randomized_partition(arr, low, high)\n        randomized_quick_sort(arr, low, pivot_index - 1)\n        randomized_quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n```\n\n#### 4.2. Median-of-Three (Tối ưu)\n\n```python\ndef median_of_three(arr, low, high):\n    \"\"\"\n    Chọn median của 3 phần tử làm pivot\n    \"\"\"\n    mid = (low + high) // 2\n    \n    # Sắp xếp 3 phần tử\n    if arr[low] > arr[mid]:\n        arr[low], arr[mid] = arr[mid], arr[low]\n    if arr[low] > arr[high]:\n        arr[low], arr[high] = arr[high], arr[low]\n    if arr[mid] > arr[high]:\n        arr[mid], arr[high] = arr[high], arr[mid]\n    \n    # Đặt median (arr[mid]) vào vị trí high-1\n    arr[mid], arr[high - 1] = arr[high - 1], arr[mid]\n    return arr[high - 1]\n```\n\n#### 4.3. Three-Way Partitioning (Dutch National Flag)\n\nXử lý tốt khi có nhiều phần tử trùng lặp.\n\n```python\ndef three_way_partition(arr, low, high):\n    \"\"\"\n    Chia mảng thành 3 phần: < pivot, = pivot, > pivot\n    \"\"\"\n    if high <= low:\n        return low, high\n    \n    pivot = arr[low]\n\n**Các khái niệm quan trọng:**\n- Partition là một hàm phụ trợ và phép toán cốt lõi được sử dụng trong các thuật toán Quicksort và Quick Select. Chức năng chính của nó là phân chia hoặc sắp xếp lại một mảng (hoặc mảng con) thành hai phần dựa trên một phần tử được chọn làm pivot. Cụ thể, tất cả các phần tử nhỏ hơn (hoặc nhỏ hơn hoặc bằng) pivot được đặt ở một bên của pivot, và tất cả các phần tử lớn hơn pivot được đặt ở phía còn lại. Sau khi phân hoạch, hàm này trả về chỉ số (hoặc vị trí cuối cùng) của pivot.\n- Three-Way Partitioning, còn được gọi là Dutch National Flag algorithm, là một kỹ thuật phân hoạch được sử dụng trong Quicksort để xử lý hiệu quả các mảng có nhiều phần tử trùng lặp. Kỹ thuật này chia mảng thành ba phần: các phần tử nhỏ hơn pivot, các phần tử bằng pivot, và các phần tử lớn hơn pivot.\n\n**Mối quan hệ:**\n- Three-Way Partitioning tối ưu hóa Quicksort khi có nhiều phần tử trùng lặp, bằng cách chia mảng thành ba phần.\n- Quick Select sử dụng hàm partition để phân chia mảng và xác định vị trí của pivot.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n    lt = low       # arr[low..lt-1] < pivot\n    i = low + 1    # arr[lt..i-1] == pivot\n    gt = high      # arr[gt+1..high] > pivot\n    \n    while i <= gt:\n        if arr[i] < pivot:\n            arr[lt], arr[i] = arr[i], arr[lt]\n            lt += 1\n            i += 1\n        elif arr[i] > pivot:\n            arr[i], arr[gt] = arr[gt], arr[i]\n            gt -= 1\n        else:\n            i += 1\n    \n    return lt, gt\n\ndef quick_sort_3way(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort với 3-way partitioning\n    Tối ưu cho mảng có nhiều phần tử trùng\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        lt, gt = three_way_partition(arr, low, high)\n        quick_sort_3way(arr, low, lt - 1)\n        quick_sort_3way(arr, gt + 1, high)\n    \n    return arr\n\n# Test với mảng có nhiều phần tử trùng\narr = [4, 9, 4, 4, 1, 9, 4, 4, 9, 4, 4, 1, 4]\nprint(\"Mảng có nhiều phần tử trùng:\", arr)\nprint(\"Sau 3-way quick sort:\", quick_sort_3way(arr.copy()))\n```\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Quick Select - Tìm phần tử thứ k\n\n```python\ndef quick_select(arr, k):\n    \"\"\"\n    Tìm phần tử thứ k nhỏ nhất (0-indexed)\n    Average: O(n), Worst: O(n²)\n    \"\"\"\n    def select(arr, low, high, k):\n        if low == high:\n            return arr[low]\n        \n        pivot_index = partition(arr, low, high)\n        \n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return select(arr, low, pivot_index - 1, k)\n        else:\n            return select(arr, pivot_index + 1, high, k)\n    \n    return select(arr, 0, len(arr) - 1, k)\n\n# Test\narr = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(f\"Phần tử thứ {k+1} nhỏ nhất:\", quick_select(arr.copy(), k))\n\n# Tìm median\ndef find_median(arr):\n    n = len(arr)\n    if n % 2 == 1:\n        return quick_select(arr, n // 2)\n    else:\n        return (quick_select(arr.copy(), n // 2 - 1) + \n                quick_select(arr.copy(), n // 2)) / 2\n\nprint(\"Median:\", find_median([3, 2, 1, 5, 6, 4]))\n```\n\n#### 5.2. Kth Largest Element\n\n```python\ndef find_kth_largest(arr, k):\n    \"\"\"\n    Tìm phần tử lớn thứ k\n    \"\"\"\n    # Phần tử lớn thứ k = phần tử thứ (n-k) từ trái\n    return quick_select(arr, len(arr) - k)\n\n# Test\narr = [3, 2, 3, 1, 2, 4, 5, 5, 6]\nprint(f\"Phần tử lớn thứ 4:\", find_kth_largest(arr, 4))\n```\n\n---\n\n### 6. So sánh với các thuật toán khác\n\n| Đặc điểm | Quick Sort | Merge Sort | Heap Sort |\n|----------|------------|------------|-----------|\n| **Average Time** | O(n log n) | O(n log n) | O(n log n) |\n| **Worst Time** | O(n²) | O(n log n) | O(n log n) |\n| **Space** | O(log n) | O(n) | O(1) |\n| **Stable** | ❌ | ✅ | ❌ |\n\n**Các khái niệm quan trọng:**\n- Partition là một hàm phụ trợ và phép toán cốt lõi được sử dụng trong các thuật toán Quicksort và Quick Select. Chức năng chính của nó là phân chia hoặc sắp xếp lại một mảng (hoặc mảng con) thành hai phần dựa trên một phần tử được chọn làm pivot. Cụ thể, tất cả các phần tử nhỏ hơn (hoặc nhỏ hơn hoặc bằng) pivot được đặt ở một bên của pivot, và tất cả các phần tử lớn hơn pivot được đặt ở phía còn lại. Sau khi phân hoạch, hàm này trả về chỉ số (hoặc vị trí cuối cùng) của pivot.\n- Pivot (chốt) là một phần tử được chọn trong thuật toán Quick Sort hoặc Quick Select, đóng vai trò làm mốc để phân hoạch mảng. Các phần tử khác trong mảng được so sánh với pivot: những phần tử nhỏ hơn pivot sẽ được chuyển sang một bên, và những phần tử lớn hơn pivot sẽ được chuyển sang bên còn lại. Việc lựa chọn pivot ảnh hưởng lớn đến hiệu suất của thuật toán.\n\n**Mối quan hệ:**\n- Quick Select sử dụng hàm partition để phân chia mảng và xác định vị trí của pivot.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n| **In-place** | ✅ | ❌ | ✅ |\n| **Cache-friendly** | ✅ | ❌ | ⚠️ |\n\n#### 6.1. Khi nào dùng Quick Sort?\n\n**Nên dùng:**\n- ✅ Mảng trong RAM (in-memory sorting)\n- ✅ Cần sorting nhanh nhất average case\n- ✅ Bộ nhớ hạn chế\n- ✅ Random access data (array)\n- ✅ Không cần stable sort\n\n**Không nên dùng:**\n- ❌ Cần đảm bảo O(n log n) worst case\n- ❌ Cần stable sorting\n- ❌ Linked list (Merge Sort tốt hơn)\n- ❌ Dữ liệu đã gần sắp xếp (trừ khi dùng random pivot)\n\n---\n\n### 7. Quick Sort trong thư viện chuẩn\n\n#### 7.1. Python's sorted() và sort()\n\nPython sử dụng **Timsort** (hybrid của Merge Sort và Insertion Sort), không phải Quick Sort, vì:\n- Stable sorting\n- Tốt với dữ liệu có pattern\n- Worst case O(n log n) đảm bảo\n\n#### 7.2. C++ std::sort()\n\nC++ sử dụng **Introsort** (Introspective Sort):\n- Bắt đầu với Quick Sort\n- Chuyển sang Heap Sort nếu đệ quy quá sâu (tránh O(n²))\n- Dùng Insertion Sort cho mảng nhỏ\n\n#### 7.3. Java's Arrays.sort()\n\n- **Primitive types:** Dual-Pivot Quick Sort\n- **Object types:** Timsort (stable)\n\n---\n\n## Priority Queue & Binary Heap\n\n### 1. Giới thiệu Priority Queue\n\n#### 1.1. Khái niệm\n\n**Priority Queue (Hàng đợi ưu tiên)** là một cấu trúc dữ liệu trừu tượng trong đó mỗi phần tử có một độ ưu tiên (priority) được gán cho nó. Phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào.\n\n**Khác với Queue thông thường:**\n- Queue thông thường: FIFO (First In First Out)\n- Priority Queue: Phần tử có priority cao nhất ra trước\n\n**Ví dụ thực tế:**\n- **Hệ thống cấp cứu:** Bệnh nhân nguy kịch được ưu tiên khám trước\n- **CPU Scheduling:** Process có priority cao được xử lý trước\n- **Dijkstra Algorithm:** Chọn đỉnh có khoảng cách nhỏ nhất\n- **A* Search:** Chọn node có f(n) nhỏ nhất\n- **Huffman Coding:** Xây dựng cây mã hóa\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Insert/Enqueue:** Thêm phần tử với priority\n**b) Extract-Max/Min:** Lấy và xóa phần tử có priority cao/thấp nhất\n**c) Peek/Top:** Xem phần tử có priority cao/thấp nhất\n**d) Change Priority:** Thay đổi priority của phần tử\n**e) Delete:** Xóa phần tử bất kỳ\n\n#### 1.3. Các cách cài đặt\n\n| Cài đặt | Insert | Extract-Max | Peek |\n|---------|--------|-------------|------|\n| Array (unsorted) | O(1) | O(n) | O(n) |\n| Array (sorted) | O(n) | O(1) | O(1) |\n| Linked List | O(n) | O(1) | O(1) |\n| **Binary Heap** | **O(log n)** | **O(log n)** | **O(1)** |\n| Fibonacci Heap | O(1) | O(log n) | O(1) |\n\n\n**Các khái niệm quan trọng:**\n- Dual-Pivot Quick Sort là một biến thể của Quicksort sử dụng hai pivot thay vì một. Nó chia mảng thành ba phần thay vì hai, thường mang lại hiệu suất tốt hơn so với Quicksort truyền thống, đặc biệt là trên các tập dữ liệu lớn. Java's Arrays.sort() sử dụng Dual-Pivot Quick Sort cho các kiểu dữ liệu nguyên thủy.\n\n**Mối quan hệ:**\n- Dual-Pivot Quick Sort là một biến thể của Quicksort."
        },
        "output_without_context": {
            "question": "Trong quy trình phân vùng của thuật toán Quicksort, mục tiêu chính của việc sử dụng các con trỏ là gì?",
            "answer": "Để quét mảng và hoán đổi các phần tử sao cho các phần tử nhỏ hơn hoặc bằng giá trị phân vùng nằm bên trái và các phần tử lớn hơn nằm bên phải."
        }
    },
    {
        "topic_description": "Đánh giá hiệu suất của Quicksort bằng cách phân tích các trường hợp tốt nhất, xấu nhất và trung bình. Học sinh sẽ cần biết công thức và cách tính toán số lần so sánh trong từng trường hợp. Nội dung này bổ sung kiến thức về Mergesort từ tuần trước để so sánh hiệu suất và ứng dụng thực tế.",
        "output_with_context": {
            "question": "Trong thuật toán Quicksort, độ phức tạp thời gian trung bình là gì khi pivot được chọn ngẫu nhiên?",
            "answer": "O(n log n)",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n[7, 8, 9] [10] []\n\nTiếp tục...\nKết quả: [1, 5, 7, 8, 9, 10]\n```\n\n---\n\n### 2. Thuật toán Quick Sort\n\n#### 2.1. Cài đặt cơ bản (Lomuto Partition)\n\n```python\ndef quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Lomuto partition scheme\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Partition và lấy vị trí pivot\n        pivot_index = partition(arr, low, high)\n        \n        # Đệ quy sắp xếp 2 phần\n        quick_sort(arr, low, pivot_index - 1)\n        quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef partition(arr, low, high):\n    \"\"\"\n    Lomuto partition: Chọn phần tử cuối làm pivot\n    \"\"\"\n    pivot = arr[high]\n    i = low - 1  # Index của phần tử nhỏ hơn\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Đặt pivot vào vị trí đúng\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", quick_sort(arr.copy()))\n```\n\n#### 2.2. Hoare Partition Scheme (Hiệu quả hơn)\n\n```python\ndef quick_sort_hoare(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Hoare partition scheme\n    Hiệu quả hơn Lomuto (ít swap hơn 3 lần)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = hoare_partition(arr, low, high)\n        quick_sort_hoare(arr, low, pivot_index)\n        quick_sort_hoare(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef hoare_partition(arr, low, high):\n    \"\"\"\n    Hoare partition: Pivot ở giữa, 2 con trỏ từ 2 đầu\n    \"\"\"\n    pivot = arr[low]\n    i = low - 1\n    j = high + 1\n    \n    while True:\n        # Tìm phần tử >= pivot từ trái\n        i += 1\n        while arr[i] < pivot:\n            i += 1\n        \n        # Tìm phần tử <= pivot từ phải\n        j -= 1\n        while arr[j] > pivot:\n            j -= 1\n        \n        # Nếu 2 con trỏ gặp nhau\n        if i >= j:\n            return j\n        \n        # Swap\n        arr[i], arr[j] = arr[j], arr[i]\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Hoare Partition:\", quick_sort_hoare(arr.copy()))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Best Case: O(n log n)**\n- Xảy ra khi pivot luôn chia mảng thành 2 phần bằng nhau\n- Độ cao cây đệ quy: log n\n- Mỗi tầng: O(n) cho partition\n- Tổng: O(n log n)\n\n**Average Case: O(n log n)**\n- Với pivot ngẫu nhiên, expected time là O(n log n)\n- Ngay cả khi không chia đều (tỉ lệ 9:1), vẫn là O(n log n)\n\n**Worst Case: O(n²)**\n- Xảy ra khi pivot luôn là phần tử nhỏ nhất hoặc lớn nhất\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n\n**Mối quan hệ:**\n- Quicksort yêu cầu xem xét Best/Average case để đánh giá hiệu suất thực tế của nó, thường là O(n log n).\n- Quicksort yêu cầu xem xét Worst Case để hiểu giới hạn hiệu suất của nó, đặc biệt khi pivot được chọn không tối ưu.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n    lt = low       # arr[low..lt-1] < pivot\n    i = low + 1    # arr[lt..i-1] == pivot\n    gt = high      # arr[gt+1..high] > pivot\n    \n    while i <= gt:\n        if arr[i] < pivot:\n            arr[lt], arr[i] = arr[i], arr[lt]\n            lt += 1\n            i += 1\n        elif arr[i] > pivot:\n            arr[i], arr[gt] = arr[gt], arr[i]\n            gt -= 1\n        else:\n            i += 1\n    \n    return lt, gt\n\ndef quick_sort_3way(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort với 3-way partitioning\n    Tối ưu cho mảng có nhiều phần tử trùng\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        lt, gt = three_way_partition(arr, low, high)\n        quick_sort_3way(arr, low, lt - 1)\n        quick_sort_3way(arr, gt + 1, high)\n    \n    return arr\n\n# Test với mảng có nhiều phần tử trùng\narr = [4, 9, 4, 4, 1, 9, 4, 4, 9, 4, 4, 1, 4]\nprint(\"Mảng có nhiều phần tử trùng:\", arr)\nprint(\"Sau 3-way quick sort:\", quick_sort_3way(arr.copy()))\n```\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Quick Select - Tìm phần tử thứ k\n\n```python\ndef quick_select(arr, k):\n    \"\"\"\n    Tìm phần tử thứ k nhỏ nhất (0-indexed)\n    Average: O(n), Worst: O(n²)\n    \"\"\"\n    def select(arr, low, high, k):\n        if low == high:\n            return arr[low]\n        \n        pivot_index = partition(arr, low, high)\n        \n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return select(arr, low, pivot_index - 1, k)\n        else:\n            return select(arr, pivot_index + 1, high, k)\n    \n    return select(arr, 0, len(arr) - 1, k)\n\n# Test\narr = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(f\"Phần tử thứ {k+1} nhỏ nhất:\", quick_select(arr.copy(), k))\n\n# Tìm median\ndef find_median(arr):\n    n = len(arr)\n    if n % 2 == 1:\n        return quick_select(arr, n // 2)\n    else:\n        return (quick_select(arr.copy(), n // 2 - 1) + \n                quick_select(arr.copy(), n // 2)) / 2\n\nprint(\"Median:\", find_median([3, 2, 1, 5, 6, 4]))\n```\n\n#### 5.2. Kth Largest Element\n\n```python\ndef find_kth_largest(arr, k):\n    \"\"\"\n    Tìm phần tử lớn thứ k\n    \"\"\"\n    # Phần tử lớn thứ k = phần tử thứ (n-k) từ trái\n    return quick_select(arr, len(arr) - k)\n\n# Test\narr = [3, 2, 3, 1, 2, 4, 5, 5, 6]\nprint(f\"Phần tử lớn thứ 4:\", find_kth_largest(arr, 4))\n```\n\n---\n\n### 6. So sánh với các thuật toán khác\n\n| Đặc điểm | Quick Sort | Merge Sort | Heap Sort |\n|----------|------------|------------|-----------|\n| **Average Time** | O(n log n) | O(n log n) | O(n log n) |\n| **Worst Time** | O(n²) | O(n log n) | O(n log n) |\n| **Space** | O(log n) | O(n) | O(1) |\n| **Stable** | ❌ | ✅ | ❌ |\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n\n**Mối quan hệ:**\n- Quicksort yêu cầu xem xét Best/Average case để đánh giá hiệu suất thực tế của nó, thường là O(n log n).\n- Quicksort yêu cầu xem xét Worst Case để hiểu giới hạn hiệu suất của nó, đặc biệt khi pivot được chọn không tối ưu.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n- Ví dụ: Mảng đã sắp xếp với pivot là phần tử đầu/cuối\n- Độ cao cây đệ quy: n\n- Tổng: O(n²)\n\n**Minh họa Worst Case:**\n```\nMảng: [1, 2, 3, 4, 5] (pivot = cuối)\n\nLần 1: [1,2,3,4] | 5 | []       - n operations\nLần 2: [1,2,3] | 4 | []         - (n-1) operations\nLần 3: [1,2] | 3 | []           - (n-2) operations\n...\nTổng: n + (n-1) + (n-2) + ... + 1 = n(n+1)/2 = O(n²)\n```\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:**\n- **Best/Average case:** O(log n) - Chiều cao cây đệ quy\n- **Worst case:** O(n) - Cây đệ quy thoái hóa\n\n**In-place:** ✅ (không cần mảng phụ, chỉ dùng stack cho đệ quy)\n\n#### 3.3. Đặc điểm\n\n**Ưu điểm:**\n- ✅ Rất nhanh trong thực tế (cache-friendly)\n- ✅ In-place (O(log n) space)\n- ✅ Dễ song song hóa\n- ✅ Có thể tối ưu cho nhiều trường hợp\n\n**Nhược điểm:**\n- ❌ Unstable (không giữ thứ tự tương đối)\n- ❌ Worst case O(n²) (có thể tránh với random pivot)\n- ❌ Không tốt với dữ liệu đã sắp xếp (nếu không tối ưu)\n\n---\n\n### 4. Tối ưu hóa Quick Sort\n\n#### 4.1. Random Pivot (Tránh worst case)\n\n```python\nimport random\n\ndef randomized_partition(arr, low, high):\n    \"\"\"\n    Chọn pivot ngẫu nhiên\n    \"\"\"\n    # Chọn random index và đổi về cuối\n    random_index = random.randint(low, high)\n    arr[random_index], arr[high] = arr[high], arr[random_index]\n    return partition(arr, low, high)\n\ndef randomized_quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Randomized Quick Sort - Tránh worst case O(n²)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = randomized_partition(arr, low, high)\n        randomized_quick_sort(arr, low, pivot_index - 1)\n        randomized_quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n```\n\n#### 4.2. Median-of-Three (Tối ưu)\n\n```python\ndef median_of_three(arr, low, high):\n    \"\"\"\n    Chọn median của 3 phần tử làm pivot\n    \"\"\"\n    mid = (low + high) // 2\n    \n    # Sắp xếp 3 phần tử\n    if arr[low] > arr[mid]:\n        arr[low], arr[mid] = arr[mid], arr[low]\n    if arr[low] > arr[high]:\n        arr[low], arr[high] = arr[high], arr[low]\n    if arr[mid] > arr[high]:\n        arr[mid], arr[high] = arr[high], arr[mid]\n    \n    # Đặt median (arr[mid]) vào vị trí high-1\n    arr[mid], arr[high - 1] = arr[high - 1], arr[mid]\n    return arr[high - 1]\n```\n\n#### 4.3. Three-Way Partitioning (Dutch National Flag)\n\nXử lý tốt khi có nhiều phần tử trùng lặp.\n\n```python\ndef three_way_partition(arr, low, high):\n    \"\"\"\n    Chia mảng thành 3 phần: < pivot, = pivot, > pivot\n    \"\"\"\n    if high <= low:\n        return low, high\n    \n    pivot = arr[low]\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n\n**Mối quan hệ:**\n- Quicksort yêu cầu xem xét Best/Average case để đánh giá hiệu suất thực tế của nó, thường là O(n log n).\n- Quicksort yêu cầu xem xét Worst Case để hiểu giới hạn hiệu suất của nó, đặc biệt khi pivot được chọn không tối ưu.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n        # Gộp 2 nửa\n        merge_inplace(arr, left, mid, right)\n\ndef merge_inplace(arr, left, mid, right):\n    \"\"\"\n    Gộp 2 phần đã sắp xếp trong mảng\n    \"\"\"\n    # Tạo mảng tạm\n    left_arr = arr[left:mid + 1]\n    right_arr = arr[mid + 1:right + 1]\n    \n    i = j = 0\n    k = left\n    \n    # Gộp vào mảng gốc\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n    \n    # Copy phần tử còn lại\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    \n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nmerge_sort_inplace(arr, 0, len(arr) - 1)\nprint(\"Mảng sau khi sắp xếp:\", arr)\n```\n\n#### 2.3. Cài đặt với iteration (không đệ quy)\n\n```python\ndef merge_sort_iterative(arr):\n    \"\"\"\n    Merge Sort sử dụng vòng lặp thay vì đệ quy\n    \"\"\"\n    n = len(arr)\n    current_size = 1\n    \n    # Bắt đầu với kích thước 1, tăng gấp đôi mỗi lần\n    while current_size < n:\n        left = 0\n        \n        while left < n - 1:\n            # Tìm điểm giữa và điểm cuối\n            mid = min(left + current_size - 1, n - 1)\n            right = min(left + 2 * current_size - 1, n - 1)\n            \n            # Gộp các phần con\n            merge_inplace(arr, left, mid, right)\n            \n            # Di chuyển đến phần con tiếp theo\n            left += 2 * current_size\n        \n        # Tăng kích thước gấp đôi\n        current_size *= 2\n    \n    return arr\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Mảng sau khi sắp xếp:\", merge_sort_iterative(arr))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Phân tích bằng Master Theorem:**\n- Công thức đệ quy: T(n) = 2T(n/2) + O(n)\n- Trong đó:\n  - 2T(n/2): Chi phí sắp xếp 2 nửa\n  - O(n): Chi phí gộp\n\n**Độ cao cây đệ quy:** log₂(n)\n**Chi phí mỗi tầng:** O(n)\n**Tổng chi phí:** O(n log n)\n\n**Kết quả:**\n- **Best case:** O(n log n)\n- **Average case:** O(n log n)\n- **Worst case:** O(n log n)\n\n**Đặc điểm độ phức tạp:**\n- Luôn là O(n log n), không phụ thuộc vào dữ liệu đầu vào\n- Tốt hơn các thuật toán O(n²)\n- Là thuật toán optimal cho comparison-based sorting trong worst case\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:** O(n)\n- Cần thêm bộ nhớ để lưu các mảng tạm trong quá trình merge\n- Với đệ quy: O(n) cho mảng tạm + O(log n) cho stack\n- Tổng: O(n)\n\n**Cải thiện bộ nhớ:**\n\n**Các khái niệm quan trọng:**\n- Average case là trường hợp đầu vào trung bình cho một thuật toán, thường được sử dụng để đánh giá hiệu suất thực tế. Đối với Mergesort, average case vẫn là O(n log n).\n- Best case (trường hợp tốt nhất) là kịch bản đầu vào mà một thuật toán hoặc phép toán có hiệu suất tốt nhất hoặc tối ưu nhất, dẫn đến thời gian thực thi tối thiểu. Ví dụ, đối với BST, best case là khi phần tử cần thao tác nằm ở gốc (O(1)); đối với Quick Sort và Mergesort, best case là O(n log n), với Quick Sort xảy ra khi pivot chia mảng thành hai phần gần bằng nhau. Average case (trường hợp trung bình) là kịch bản mà một thuật toán hoặc phép toán có hiệu suất điển hình nhất hoặc trung bình, thường là trường hợp phổ biến nhất trên một tập hợp lớn các đầu vào ngẫu nhiên. Đối với Hash Table, average case là khi các khóa được phân phối đều (O(1)); đối với BST, average case là khi cây cân bằng (O(log n)); đối với Quick Sort và Mergesort, average case là O(n log n). Worst case (trường hợp xấu nhất) là kịch bản đầu vào mà một thuật toán hoặc phép toán có hiệu suất kém nhất, dẫn đến thời gian thực thi tối đa. Đối với BST, worst case là khi cây thoái hóa thành danh sách liên kết (O(n)); đối với Quick Sort, worst case là khi pivot luôn là phần tử nhỏ nhất hoặc lớn nhất (O(n²)); đối với Mergesort, worst case vẫn là O(n log n).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n    \n    current.next = l1 if l1 else l2\n    \n    return dummy.next\n\n# Helper function\ndef print_list(head):\n    values = []\n    while head:\n        values.append(head.val)\n        head = head.next\n    print(values)\n\n# Test\nhead = ListNode(4, ListNode(2, ListNode(1, ListNode(3))))\nprint(\"Trước khi sắp xếp:\")\nprint_list(head)\nsorted_head = merge_sort_linked_list(head)\nprint(\"Sau khi sắp xếp:\")\nprint_list(sorted_head)\n```\n\n---\n\n### 8. Parallel Merge Sort\n\n```python\nfrom concurrent.futures import ThreadPoolExecutor\nimport threading\n\ndef parallel_merge_sort(arr, depth=0, max_depth=3):\n    \"\"\"\n    Merge sort song song sử dụng threads\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Sử dụng parallel khi depth nhỏ\n    if depth < max_depth:\n        with ThreadPoolExecutor(max_workers=2) as executor:\n            future_left = executor.submit(parallel_merge_sort, left, depth + 1, max_depth)\n            future_right = executor.submit(parallel_merge_sort, right, depth + 1, max_depth)\n            \n            left = future_left.result()\n            right = future_right.result()\n    else:\n        # Sequential cho các phần nhỏ\n        left = merge_sort(left)\n        right = merge_sort(right)\n    \n    return merge(left, right)\n\n# Test\nimport time\narr = list(range(10000, 0, -1))\n\nstart = time.time()\nsorted_arr = merge_sort(arr.copy())\nsequential_time = time.time() - start\n\nstart = time.time()\nsorted_arr = parallel_merge_sort(arr.copy())\nparallel_time = time.time() - start\n\nprint(f\"Sequential: {sequential_time:.4f}s\")\nprint(f\"Parallel: {parallel_time:.4f}s\")\nprint(f\"Speedup: {sequential_time/parallel_time:.2f}x\")\n```\n\n---\n\n## Quicksort\n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\nQuick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật **Chia để trị (Divide and Conquer)**. Thuật toán chọn một phần tử làm \"pivot\" (chốt), phân hoạch mảng sao cho các phần tử nhỏ hơn pivot ở bên trái và các phần tử lớn hơn ở bên phải, sau đó đệ quy sắp xếp hai phần.\n\n**Đặc điểm nổi bật:**\n- Được phát minh bởi Tony Hoare năm 1960\n- Là thuật toán sắp xếp phổ biến nhất trong thực tế\n- Average case O(n log n), nhưng worst case O(n²)\n- In-place sorting (không cần bộ nhớ phụ nhiều)\n\n#### 1.2. Ý tưởng chính\n\n**Nguyên lý:**\n1. **Chọn Pivot:** Chọn một phần tử làm pivot (có thể là đầu, cuối, giữa, hoặc random)\n2. **Partition:** Sắp xếp lại mảng sao cho:\n   - Tất cả phần tử < pivot ở bên trái\n   - Tất cả phần tử > pivot ở bên phải\n   - Pivot ở đúng vị trí cuối cùng\n3. **Đệ quy:** Áp dụng quick sort cho phần trái và phần phải\n\n**Ví dụ trực quan:**\n```\nMảng: [10, 7, 8, 9, 1, 5]\nPivot: 5 (phần tử cuối)\n\nSau partition:\n[1] [5] [7, 8, 9, 10]\n ^   ^   ^\n Trái  Pivot  Phải\n\nĐệ quy sắp xếp [7, 8, 9, 10]:\nPivot: 10\n\n**Các khái niệm quan trọng:**\n- Average case là trường hợp đầu vào trung bình cho một thuật toán, thường được sử dụng để đánh giá hiệu suất thực tế. Đối với Mergesort, average case vẫn là O(n log n).\n- Best case (trường hợp tốt nhất) là kịch bản đầu vào mà một thuật toán hoặc phép toán có hiệu suất tốt nhất hoặc tối ưu nhất, dẫn đến thời gian thực thi tối thiểu. Ví dụ, đối với BST, best case là khi phần tử cần thao tác nằm ở gốc (O(1)); đối với Quick Sort và Mergesort, best case là O(n log n), với Quick Sort xảy ra khi pivot chia mảng thành hai phần gần bằng nhau. Average case (trường hợp trung bình) là kịch bản mà một thuật toán hoặc phép toán có hiệu suất điển hình nhất hoặc trung bình, thường là trường hợp phổ biến nhất trên một tập hợp lớn các đầu vào ngẫu nhiên. Đối với Hash Table, average case là khi các khóa được phân phối đều (O(1)); đối với BST, average case là khi cây cân bằng (O(log n)); đối với Quick Sort và Mergesort, average case là O(n log n). Worst case (trường hợp xấu nhất) là kịch bản đầu vào mà một thuật toán hoặc phép toán có hiệu suất kém nhất, dẫn đến thời gian thực thi tối đa. Đối với BST, worst case là khi cây thoái hóa thành danh sách liên kết (O(n)); đối với Quick Sort, worst case là khi pivot luôn là phần tử nhỏ nhất hoặc lớn nhất (O(n²)); đối với Mergesort, worst case vẫn là O(n log n)."
        },
        "output_without_context": {
            "question": "Trong phân tích hiệu suất của thuật toán Quicksort, số lần so sánh trong trường hợp tốt nhất là bao nhiêu?",
            "answer": "O(n log n)"
        }
    },
    {
        "topic_description": "Khám phá các thuộc tính quan trọng của Quicksort, bao gồm độ sâu đệ quy, không gian phụ và tính không ổn định của thuật toán. Học sinh nên hiểu các ảnh hưởng của các thuộc tính này đến hiệu suất và ứng dụng thực tế của Quicksort. Nội dung này có thể kiểm tra bằng cách so sánh các thuộc tính với Mergesort từ tuần 3.",
        "output_with_context": {
            "question": "Quicksort có đặc điểm nào sau đây liên quan đến tính không ổn định của thuật toán?",
            "answer": "Quicksort không giữ thứ tự tương đối của các phần tử có giá trị bằng nhau.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n    \n    current.next = l1 if l1 else l2\n    \n    return dummy.next\n\n# Helper function\ndef print_list(head):\n    values = []\n    while head:\n        values.append(head.val)\n        head = head.next\n    print(values)\n\n# Test\nhead = ListNode(4, ListNode(2, ListNode(1, ListNode(3))))\nprint(\"Trước khi sắp xếp:\")\nprint_list(head)\nsorted_head = merge_sort_linked_list(head)\nprint(\"Sau khi sắp xếp:\")\nprint_list(sorted_head)\n```\n\n---\n\n### 8. Parallel Merge Sort\n\n```python\nfrom concurrent.futures import ThreadPoolExecutor\nimport threading\n\ndef parallel_merge_sort(arr, depth=0, max_depth=3):\n    \"\"\"\n    Merge sort song song sử dụng threads\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Sử dụng parallel khi depth nhỏ\n    if depth < max_depth:\n        with ThreadPoolExecutor(max_workers=2) as executor:\n            future_left = executor.submit(parallel_merge_sort, left, depth + 1, max_depth)\n            future_right = executor.submit(parallel_merge_sort, right, depth + 1, max_depth)\n            \n            left = future_left.result()\n            right = future_right.result()\n    else:\n        # Sequential cho các phần nhỏ\n        left = merge_sort(left)\n        right = merge_sort(right)\n    \n    return merge(left, right)\n\n# Test\nimport time\narr = list(range(10000, 0, -1))\n\nstart = time.time()\nsorted_arr = merge_sort(arr.copy())\nsequential_time = time.time() - start\n\nstart = time.time()\nsorted_arr = parallel_merge_sort(arr.copy())\nparallel_time = time.time() - start\n\nprint(f\"Sequential: {sequential_time:.4f}s\")\nprint(f\"Parallel: {parallel_time:.4f}s\")\nprint(f\"Speedup: {sequential_time/parallel_time:.2f}x\")\n```\n\n---\n\n## Quicksort\n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\nQuick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật **Chia để trị (Divide and Conquer)**. Thuật toán chọn một phần tử làm \"pivot\" (chốt), phân hoạch mảng sao cho các phần tử nhỏ hơn pivot ở bên trái và các phần tử lớn hơn ở bên phải, sau đó đệ quy sắp xếp hai phần.\n\n**Đặc điểm nổi bật:**\n- Được phát minh bởi Tony Hoare năm 1960\n- Là thuật toán sắp xếp phổ biến nhất trong thực tế\n- Average case O(n log n), nhưng worst case O(n²)\n- In-place sorting (không cần bộ nhớ phụ nhiều)\n\n#### 1.2. Ý tưởng chính\n\n**Nguyên lý:**\n1. **Chọn Pivot:** Chọn một phần tử làm pivot (có thể là đầu, cuối, giữa, hoặc random)\n2. **Partition:** Sắp xếp lại mảng sao cho:\n   - Tất cả phần tử < pivot ở bên trái\n   - Tất cả phần tử > pivot ở bên phải\n   - Pivot ở đúng vị trí cuối cùng\n3. **Đệ quy:** Áp dụng quick sort cho phần trái và phần phải\n\n**Ví dụ trực quan:**\n```\nMảng: [10, 7, 8, 9, 1, 5]\nPivot: 5 (phần tử cuối)\n\nSau partition:\n[1] [5] [7, 8, 9, 10]\n ^   ^   ^\n Trái  Pivot  Phải\n\nĐệ quy sắp xếp [7, 8, 9, 10]:\nPivot: 10\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n| **In-place** | ✅ | ❌ | ✅ |\n| **Cache-friendly** | ✅ | ❌ | ⚠️ |\n\n#### 6.1. Khi nào dùng Quick Sort?\n\n**Nên dùng:**\n- ✅ Mảng trong RAM (in-memory sorting)\n- ✅ Cần sorting nhanh nhất average case\n- ✅ Bộ nhớ hạn chế\n- ✅ Random access data (array)\n- ✅ Không cần stable sort\n\n**Không nên dùng:**\n- ❌ Cần đảm bảo O(n log n) worst case\n- ❌ Cần stable sorting\n- ❌ Linked list (Merge Sort tốt hơn)\n- ❌ Dữ liệu đã gần sắp xếp (trừ khi dùng random pivot)\n\n---\n\n### 7. Quick Sort trong thư viện chuẩn\n\n#### 7.1. Python's sorted() và sort()\n\nPython sử dụng **Timsort** (hybrid của Merge Sort và Insertion Sort), không phải Quick Sort, vì:\n- Stable sorting\n- Tốt với dữ liệu có pattern\n- Worst case O(n log n) đảm bảo\n\n#### 7.2. C++ std::sort()\n\nC++ sử dụng **Introsort** (Introspective Sort):\n- Bắt đầu với Quick Sort\n- Chuyển sang Heap Sort nếu đệ quy quá sâu (tránh O(n²))\n- Dùng Insertion Sort cho mảng nhỏ\n\n#### 7.3. Java's Arrays.sort()\n\n- **Primitive types:** Dual-Pivot Quick Sort\n- **Object types:** Timsort (stable)\n\n---\n\n## Priority Queue & Binary Heap\n\n### 1. Giới thiệu Priority Queue\n\n#### 1.1. Khái niệm\n\n**Priority Queue (Hàng đợi ưu tiên)** là một cấu trúc dữ liệu trừu tượng trong đó mỗi phần tử có một độ ưu tiên (priority) được gán cho nó. Phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào.\n\n**Khác với Queue thông thường:**\n- Queue thông thường: FIFO (First In First Out)\n- Priority Queue: Phần tử có priority cao nhất ra trước\n\n**Ví dụ thực tế:**\n- **Hệ thống cấp cứu:** Bệnh nhân nguy kịch được ưu tiên khám trước\n- **CPU Scheduling:** Process có priority cao được xử lý trước\n- **Dijkstra Algorithm:** Chọn đỉnh có khoảng cách nhỏ nhất\n- **A* Search:** Chọn node có f(n) nhỏ nhất\n- **Huffman Coding:** Xây dựng cây mã hóa\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Insert/Enqueue:** Thêm phần tử với priority\n**b) Extract-Max/Min:** Lấy và xóa phần tử có priority cao/thấp nhất\n**c) Peek/Top:** Xem phần tử có priority cao/thấp nhất\n**d) Change Priority:** Thay đổi priority của phần tử\n**e) Delete:** Xóa phần tử bất kỳ\n\n#### 1.3. Các cách cài đặt\n\n| Cài đặt | Insert | Extract-Max | Peek |\n|---------|--------|-------------|------|\n| Array (unsorted) | O(1) | O(n) | O(n) |\n| Array (sorted) | O(n) | O(1) | O(1) |\n| Linked List | O(n) | O(1) | O(1) |\n| **Binary Heap** | **O(log n)** | **O(log n)** | **O(1)** |\n| Fibonacci Heap | O(1) | O(log n) | O(1) |\n\n\n**Các khái niệm quan trọng:**\n- Cache-friendly là tính chất của thuật toán cho biết mức độ hiệu quả của thuật toán trong việc sử dụng bộ nhớ cache của CPU. Quicksort thường được coi là cache-friendly do truy cập dữ liệu tuần tự trong mảng.\n\n**Mối quan hệ:**\n- Quicksort có tính chất Cache-friendly, giúp tận dụng hiệu quả bộ nhớ cache của CPU.\n- Binary Heap có tính chất Cache-friendly khi được biểu diễn bằng mảng, do truy cập liên tiếp các phần tử.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n- Ví dụ: Mảng đã sắp xếp với pivot là phần tử đầu/cuối\n- Độ cao cây đệ quy: n\n- Tổng: O(n²)\n\n**Minh họa Worst Case:**\n```\nMảng: [1, 2, 3, 4, 5] (pivot = cuối)\n\nLần 1: [1,2,3,4] | 5 | []       - n operations\nLần 2: [1,2,3] | 4 | []         - (n-1) operations\nLần 3: [1,2] | 3 | []           - (n-2) operations\n...\nTổng: n + (n-1) + (n-2) + ... + 1 = n(n+1)/2 = O(n²)\n```\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:**\n- **Best/Average case:** O(log n) - Chiều cao cây đệ quy\n- **Worst case:** O(n) - Cây đệ quy thoái hóa\n\n**In-place:** ✅ (không cần mảng phụ, chỉ dùng stack cho đệ quy)\n\n#### 3.3. Đặc điểm\n\n**Ưu điểm:**\n- ✅ Rất nhanh trong thực tế (cache-friendly)\n- ✅ In-place (O(log n) space)\n- ✅ Dễ song song hóa\n- ✅ Có thể tối ưu cho nhiều trường hợp\n\n**Nhược điểm:**\n- ❌ Unstable (không giữ thứ tự tương đối)\n- ❌ Worst case O(n²) (có thể tránh với random pivot)\n- ❌ Không tốt với dữ liệu đã sắp xếp (nếu không tối ưu)\n\n---\n\n### 4. Tối ưu hóa Quick Sort\n\n#### 4.1. Random Pivot (Tránh worst case)\n\n```python\nimport random\n\ndef randomized_partition(arr, low, high):\n    \"\"\"\n    Chọn pivot ngẫu nhiên\n    \"\"\"\n    # Chọn random index và đổi về cuối\n    random_index = random.randint(low, high)\n    arr[random_index], arr[high] = arr[high], arr[random_index]\n    return partition(arr, low, high)\n\ndef randomized_quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Randomized Quick Sort - Tránh worst case O(n²)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = randomized_partition(arr, low, high)\n        randomized_quick_sort(arr, low, pivot_index - 1)\n        randomized_quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n```\n\n#### 4.2. Median-of-Three (Tối ưu)\n\n```python\ndef median_of_three(arr, low, high):\n    \"\"\"\n    Chọn median của 3 phần tử làm pivot\n    \"\"\"\n    mid = (low + high) // 2\n    \n    # Sắp xếp 3 phần tử\n    if arr[low] > arr[mid]:\n        arr[low], arr[mid] = arr[mid], arr[low]\n    if arr[low] > arr[high]:\n        arr[low], arr[high] = arr[high], arr[low]\n    if arr[mid] > arr[high]:\n        arr[mid], arr[high] = arr[high], arr[mid]\n    \n    # Đặt median (arr[mid]) vào vị trí high-1\n    arr[mid], arr[high - 1] = arr[high - 1], arr[mid]\n    return arr[high - 1]\n```\n\n#### 4.3. Three-Way Partitioning (Dutch National Flag)\n\nXử lý tốt khi có nhiều phần tử trùng lặp.\n\n```python\ndef three_way_partition(arr, low, high):\n    \"\"\"\n    Chia mảng thành 3 phần: < pivot, = pivot, > pivot\n    \"\"\"\n    if high <= low:\n        return low, high\n    \n    pivot = arr[low]\n\n**Các khái niệm quan trọng:**\n- Randomized Quick Sort là một phiên bản của Quicksort sử dụng kỹ thuật Random Pivot để chọn pivot ngẫu nhiên. Điều này giúp giảm đáng kể khả năng gặp phải trường hợp xấu nhất O(n²) và đảm bảo hiệu suất trung bình O(n log n) với xác suất cao.\n\n**Mối quan hệ:**\n- Randomized Quick Sort sử dụng kỹ thuật Random Pivot để cải thiện hiệu suất và tránh trường hợp xấu nhất.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n    lt = low       # arr[low..lt-1] < pivot\n    i = low + 1    # arr[lt..i-1] == pivot\n    gt = high      # arr[gt+1..high] > pivot\n    \n    while i <= gt:\n        if arr[i] < pivot:\n            arr[lt], arr[i] = arr[i], arr[lt]\n            lt += 1\n            i += 1\n        elif arr[i] > pivot:\n            arr[i], arr[gt] = arr[gt], arr[i]\n            gt -= 1\n        else:\n            i += 1\n    \n    return lt, gt\n\ndef quick_sort_3way(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort với 3-way partitioning\n    Tối ưu cho mảng có nhiều phần tử trùng\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        lt, gt = three_way_partition(arr, low, high)\n        quick_sort_3way(arr, low, lt - 1)\n        quick_sort_3way(arr, gt + 1, high)\n    \n    return arr\n\n# Test với mảng có nhiều phần tử trùng\narr = [4, 9, 4, 4, 1, 9, 4, 4, 9, 4, 4, 1, 4]\nprint(\"Mảng có nhiều phần tử trùng:\", arr)\nprint(\"Sau 3-way quick sort:\", quick_sort_3way(arr.copy()))\n```\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Quick Select - Tìm phần tử thứ k\n\n```python\ndef quick_select(arr, k):\n    \"\"\"\n    Tìm phần tử thứ k nhỏ nhất (0-indexed)\n    Average: O(n), Worst: O(n²)\n    \"\"\"\n    def select(arr, low, high, k):\n        if low == high:\n            return arr[low]\n        \n        pivot_index = partition(arr, low, high)\n        \n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return select(arr, low, pivot_index - 1, k)\n        else:\n            return select(arr, pivot_index + 1, high, k)\n    \n    return select(arr, 0, len(arr) - 1, k)\n\n# Test\narr = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(f\"Phần tử thứ {k+1} nhỏ nhất:\", quick_select(arr.copy(), k))\n\n# Tìm median\ndef find_median(arr):\n    n = len(arr)\n    if n % 2 == 1:\n        return quick_select(arr, n // 2)\n    else:\n        return (quick_select(arr.copy(), n // 2 - 1) + \n                quick_select(arr.copy(), n // 2)) / 2\n\nprint(\"Median:\", find_median([3, 2, 1, 5, 6, 4]))\n```\n\n#### 5.2. Kth Largest Element\n\n```python\ndef find_kth_largest(arr, k):\n    \"\"\"\n    Tìm phần tử lớn thứ k\n    \"\"\"\n    # Phần tử lớn thứ k = phần tử thứ (n-k) từ trái\n    return quick_select(arr, len(arr) - k)\n\n# Test\narr = [3, 2, 3, 1, 2, 4, 5, 5, 6]\nprint(f\"Phần tử lớn thứ 4:\", find_kth_largest(arr, 4))\n```\n\n---\n\n### 6. So sánh với các thuật toán khác\n\n| Đặc điểm | Quick Sort | Merge Sort | Heap Sort |\n|----------|------------|------------|-----------|\n| **Average Time** | O(n log n) | O(n log n) | O(n log n) |\n| **Worst Time** | O(n²) | O(n log n) | O(n log n) |\n| **Space** | O(log n) | O(n) | O(1) |\n| **Stable** | ❌ | ✅ | ❌ |\n\n**Các khái niệm quan trọng:**\n- quick_sort_3way là một phiên bản của Quicksort sử dụng kỹ thuật 3-way partitioning. Thuật toán này tối ưu cho các mảng có nhiều phần tử trùng lặp bằng cách nhóm tất cả các phần tử bằng pivot vào giữa, sau đó chỉ đệ quy sắp xếp hai phần còn lại (nhỏ hơn pivot và lớn hơn pivot). Điều này giúp giảm số lượng phần tử cần xử lý đệ quy, cải thiện hiệu suất trong các trường hợp cụ thể. Độ phức tạp thời gian trung bình là O(n log n), worst case là O(n²).\n\n**Mối quan hệ:**\n- quick_sort_3way có độ phức tạp thời gian xấu nhất O(n²).\n- quick_sort_3way là một biến thể của Quicksort, được tối ưu hóa cho các mảng có nhiều phần tử trùng lặp.\n- quick_sort_3way có độ phức tạp thời gian trung bình O(n log n)."
        },
        "output_without_context": {
            "question": "Quicksort có thuộc tính nào sau đây liên quan đến độ sâu đệ quy và không gian phụ?",
            "answer": "Quicksort có độ sâu đệ quy trung bình là O(log n) và không gian phụ là O(n) trong trường hợp tồi tệ."
        }
    },
    {
        "topic_description": "Đi sâu vào những cải tiến thực tiễn cho Quicksort, chẳng hạn như sắp xếp chèn cho các mảng con nhỏ và việc sử dụng median. Học sinh cần hiểu rõ về các chiến lược này và ảnh hưởng của chúng đến hiệu suất. Nội dung có thể được kiểm tra thông qua áp dụng các cải tiến vào tình huống cụ thể, liên kết với kiến thức từ tuần 2.",
        "output_with_context": {
            "question": "Kỹ thuật nào trong Quicksort giúp chọn pivot tốt hơn bằng cách sử dụng giá trị trung vị của ba phần tử trong mảng?",
            "answer": "Median-of-Three",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n    \n    current.next = l1 if l1 else l2\n    \n    return dummy.next\n\n# Helper function\ndef print_list(head):\n    values = []\n    while head:\n        values.append(head.val)\n        head = head.next\n    print(values)\n\n# Test\nhead = ListNode(4, ListNode(2, ListNode(1, ListNode(3))))\nprint(\"Trước khi sắp xếp:\")\nprint_list(head)\nsorted_head = merge_sort_linked_list(head)\nprint(\"Sau khi sắp xếp:\")\nprint_list(sorted_head)\n```\n\n---\n\n### 8. Parallel Merge Sort\n\n```python\nfrom concurrent.futures import ThreadPoolExecutor\nimport threading\n\ndef parallel_merge_sort(arr, depth=0, max_depth=3):\n    \"\"\"\n    Merge sort song song sử dụng threads\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Sử dụng parallel khi depth nhỏ\n    if depth < max_depth:\n        with ThreadPoolExecutor(max_workers=2) as executor:\n            future_left = executor.submit(parallel_merge_sort, left, depth + 1, max_depth)\n            future_right = executor.submit(parallel_merge_sort, right, depth + 1, max_depth)\n            \n            left = future_left.result()\n            right = future_right.result()\n    else:\n        # Sequential cho các phần nhỏ\n        left = merge_sort(left)\n        right = merge_sort(right)\n    \n    return merge(left, right)\n\n# Test\nimport time\narr = list(range(10000, 0, -1))\n\nstart = time.time()\nsorted_arr = merge_sort(arr.copy())\nsequential_time = time.time() - start\n\nstart = time.time()\nsorted_arr = parallel_merge_sort(arr.copy())\nparallel_time = time.time() - start\n\nprint(f\"Sequential: {sequential_time:.4f}s\")\nprint(f\"Parallel: {parallel_time:.4f}s\")\nprint(f\"Speedup: {sequential_time/parallel_time:.2f}x\")\n```\n\n---\n\n## Quicksort\n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\nQuick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật **Chia để trị (Divide and Conquer)**. Thuật toán chọn một phần tử làm \"pivot\" (chốt), phân hoạch mảng sao cho các phần tử nhỏ hơn pivot ở bên trái và các phần tử lớn hơn ở bên phải, sau đó đệ quy sắp xếp hai phần.\n\n**Đặc điểm nổi bật:**\n- Được phát minh bởi Tony Hoare năm 1960\n- Là thuật toán sắp xếp phổ biến nhất trong thực tế\n- Average case O(n log n), nhưng worst case O(n²)\n- In-place sorting (không cần bộ nhớ phụ nhiều)\n\n#### 1.2. Ý tưởng chính\n\n**Nguyên lý:**\n1. **Chọn Pivot:** Chọn một phần tử làm pivot (có thể là đầu, cuối, giữa, hoặc random)\n2. **Partition:** Sắp xếp lại mảng sao cho:\n   - Tất cả phần tử < pivot ở bên trái\n   - Tất cả phần tử > pivot ở bên phải\n   - Pivot ở đúng vị trí cuối cùng\n3. **Đệ quy:** Áp dụng quick sort cho phần trái và phần phải\n\n**Ví dụ trực quan:**\n```\nMảng: [10, 7, 8, 9, 1, 5]\nPivot: 5 (phần tử cuối)\n\nSau partition:\n[1] [5] [7, 8, 9, 10]\n ^   ^   ^\n Trái  Pivot  Phải\n\nĐệ quy sắp xếp [7, 8, 9, 10]:\nPivot: 10\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n- Ví dụ: Mảng đã sắp xếp với pivot là phần tử đầu/cuối\n- Độ cao cây đệ quy: n\n- Tổng: O(n²)\n\n**Minh họa Worst Case:**\n```\nMảng: [1, 2, 3, 4, 5] (pivot = cuối)\n\nLần 1: [1,2,3,4] | 5 | []       - n operations\nLần 2: [1,2,3] | 4 | []         - (n-1) operations\nLần 3: [1,2] | 3 | []           - (n-2) operations\n...\nTổng: n + (n-1) + (n-2) + ... + 1 = n(n+1)/2 = O(n²)\n```\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:**\n- **Best/Average case:** O(log n) - Chiều cao cây đệ quy\n- **Worst case:** O(n) - Cây đệ quy thoái hóa\n\n**In-place:** ✅ (không cần mảng phụ, chỉ dùng stack cho đệ quy)\n\n#### 3.3. Đặc điểm\n\n**Ưu điểm:**\n- ✅ Rất nhanh trong thực tế (cache-friendly)\n- ✅ In-place (O(log n) space)\n- ✅ Dễ song song hóa\n- ✅ Có thể tối ưu cho nhiều trường hợp\n\n**Nhược điểm:**\n- ❌ Unstable (không giữ thứ tự tương đối)\n- ❌ Worst case O(n²) (có thể tránh với random pivot)\n- ❌ Không tốt với dữ liệu đã sắp xếp (nếu không tối ưu)\n\n---\n\n### 4. Tối ưu hóa Quick Sort\n\n#### 4.1. Random Pivot (Tránh worst case)\n\n```python\nimport random\n\ndef randomized_partition(arr, low, high):\n    \"\"\"\n    Chọn pivot ngẫu nhiên\n    \"\"\"\n    # Chọn random index và đổi về cuối\n    random_index = random.randint(low, high)\n    arr[random_index], arr[high] = arr[high], arr[random_index]\n    return partition(arr, low, high)\n\ndef randomized_quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Randomized Quick Sort - Tránh worst case O(n²)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = randomized_partition(arr, low, high)\n        randomized_quick_sort(arr, low, pivot_index - 1)\n        randomized_quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n```\n\n#### 4.2. Median-of-Three (Tối ưu)\n\n```python\ndef median_of_three(arr, low, high):\n    \"\"\"\n    Chọn median của 3 phần tử làm pivot\n    \"\"\"\n    mid = (low + high) // 2\n    \n    # Sắp xếp 3 phần tử\n    if arr[low] > arr[mid]:\n        arr[low], arr[mid] = arr[mid], arr[low]\n    if arr[low] > arr[high]:\n        arr[low], arr[high] = arr[high], arr[low]\n    if arr[mid] > arr[high]:\n        arr[mid], arr[high] = arr[high], arr[mid]\n    \n    # Đặt median (arr[mid]) vào vị trí high-1\n    arr[mid], arr[high - 1] = arr[high - 1], arr[mid]\n    return arr[high - 1]\n```\n\n#### 4.3. Three-Way Partitioning (Dutch National Flag)\n\nXử lý tốt khi có nhiều phần tử trùng lặp.\n\n```python\ndef three_way_partition(arr, low, high):\n    \"\"\"\n    Chia mảng thành 3 phần: < pivot, = pivot, > pivot\n    \"\"\"\n    if high <= low:\n        return low, high\n    \n    pivot = arr[low]\n\n**Các khái niệm quan trọng:**\n- Median-of-Three là một kỹ thuật tối ưu hóa Quicksort bằng cách chọn pivot là giá trị trung vị của ba phần tử (thường là phần tử đầu, giữa và cuối của mảng con). Kỹ thuật này giúp chọn một pivot tốt hơn, giảm khả năng xảy ra trường hợp xấu nhất và cải thiện hiệu suất trung bình.\n- Random Pivot là một kỹ thuật tối ưu hóa Quicksort bằng cách chọn phần tử pivot một cách ngẫu nhiên. Kỹ thuật này giúp tránh trường hợp xấu nhất O(n²) của Quicksort, chuyển đổi nó thành trường hợp trung bình O(n log n) với xác suất cao.\n- Randomized Quick Sort là một phiên bản của Quicksort sử dụng kỹ thuật Random Pivot để chọn pivot ngẫu nhiên. Điều này giúp giảm đáng kể khả năng gặp phải trường hợp xấu nhất O(n²) và đảm bảo hiệu suất trung bình O(n log n) với xác suất cao.\n\n**Mối quan hệ:**\n- Median-of-Three tối ưu hóa Quicksort bằng cách chọn pivot tốt hơn, giảm khả năng xảy ra trường hợp xấu nhất.\n- Randomized Quick Sort sử dụng kỹ thuật Random Pivot để cải thiện hiệu suất và tránh trường hợp xấu nhất.\n- Random Pivot tối ưu hóa Quicksort bằng cách chọn pivot ngẫu nhiên để tránh trường hợp xấu nhất O(n²).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\nfor size in [100, 500, 1000]:\n    compare_sorting_algorithms(size)\n```\n\n#### 5.3. Ứng dụng thực tế\n\n**1. Sắp xếp trong Database:**\n- Sử dụng Insertion Sort cho dữ liệu nhỏ\n- Kết hợp với các thuật toán nâng cao\n\n**2. Sắp xếp trong thư viện:**\n```python\n# Python's sorted() và list.sort() sử dụng Timsort\n# (kết hợp Merge Sort và Insertion Sort)\n\n# Sắp xếp cơ bản\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6]\nsorted_numbers = sorted(numbers)\n\n# Sắp xếp với key function\nstudents = [\n    {'name': 'An', 'score': 85},\n    {'name': 'Bình', 'score': 92},\n    {'name': 'Chi', 'score': 78}\n]\nsorted_students = sorted(students, key=lambda x: x['score'], reverse=True)\n```\n\n**3. Sắp xếp custom objects:**\n```python\nclass Student:\n    def __init__(self, name, grade):\n        self.name = name\n        self.grade = grade\n    \n    def __lt__(self, other):\n        return self.grade < other.grade\n    \n    def __repr__(self):\n        return f\"Student({self.name}, {self.grade})\"\n\nstudents = [Student(\"An\", 85), Student(\"Bình\", 92), Student(\"Chi\", 78)]\nsorted_students = insertion_sort(students)\nprint(sorted_students)\n```\n\n---\n\n### 6. Tối ưu hóa và Thủ thuật\n\n#### 6.1. Early termination (Dừng sớm)\n\n```python\ndef optimized_bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:  # Dừng nếu không có hoán đổi\n            break\n    return arr\n```\n\n#### 6.2. Giảm số lần hoán đổi\n\n```python\ndef optimized_insertion_sort(arr):\n    \"\"\"Sử dụng shifting thay vì swapping\"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]  # Shift thay vì swap\n            j -= 1\n        arr[j + 1] = key\n    return arr\n```\n\n#### 6.3. Hybrid approach\n\n```python\ndef hybrid_sort(arr, threshold=10):\n    \"\"\"Sử dụng Insertion Sort cho mảng nhỏ\"\"\"\n    if len(arr) <= threshold:\n        return insertion_sort(arr)\n    else:\n        # Sử dụng thuật toán khác cho mảng lớn\n        return sorted(arr)  # Placeholder\n```\n\n---\n\n\n**Các khái niệm quan trọng:**\n- optimized_insertion_sort là phiên bản tối ưu hóa của Insertion Sort, sử dụng kỹ thuật dịch chuyển (shifting) thay vì hoán đổi (swapping) trực tiếp. Thay vì hoán đổi từng cặp phần tử, nó dịch chuyển các phần tử lớn hơn 'key' sang phải để tạo chỗ trống, sau đó chèn 'key' vào vị trí đúng. Điều này giảm số lần ghi vào bộ nhớ.\n\n**Mối quan hệ:**\n- optimized_insertion_sort áp dụng kỹ thuật shifting (dịch chuyển) thay vì swapping để giảm số lần hoán đổi.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n[7, 8, 9] [10] []\n\nTiếp tục...\nKết quả: [1, 5, 7, 8, 9, 10]\n```\n\n---\n\n### 2. Thuật toán Quick Sort\n\n#### 2.1. Cài đặt cơ bản (Lomuto Partition)\n\n```python\ndef quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Lomuto partition scheme\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Partition và lấy vị trí pivot\n        pivot_index = partition(arr, low, high)\n        \n        # Đệ quy sắp xếp 2 phần\n        quick_sort(arr, low, pivot_index - 1)\n        quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef partition(arr, low, high):\n    \"\"\"\n    Lomuto partition: Chọn phần tử cuối làm pivot\n    \"\"\"\n    pivot = arr[high]\n    i = low - 1  # Index của phần tử nhỏ hơn\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Đặt pivot vào vị trí đúng\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", quick_sort(arr.copy()))\n```\n\n#### 2.2. Hoare Partition Scheme (Hiệu quả hơn)\n\n```python\ndef quick_sort_hoare(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Hoare partition scheme\n    Hiệu quả hơn Lomuto (ít swap hơn 3 lần)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = hoare_partition(arr, low, high)\n        quick_sort_hoare(arr, low, pivot_index)\n        quick_sort_hoare(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef hoare_partition(arr, low, high):\n    \"\"\"\n    Hoare partition: Pivot ở giữa, 2 con trỏ từ 2 đầu\n    \"\"\"\n    pivot = arr[low]\n    i = low - 1\n    j = high + 1\n    \n    while True:\n        # Tìm phần tử >= pivot từ trái\n        i += 1\n        while arr[i] < pivot:\n            i += 1\n        \n        # Tìm phần tử <= pivot từ phải\n        j -= 1\n        while arr[j] > pivot:\n            j -= 1\n        \n        # Nếu 2 con trỏ gặp nhau\n        if i >= j:\n            return j\n        \n        # Swap\n        arr[i], arr[j] = arr[j], arr[i]\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Hoare Partition:\", quick_sort_hoare(arr.copy()))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Best Case: O(n log n)**\n- Xảy ra khi pivot luôn chia mảng thành 2 phần bằng nhau\n- Độ cao cây đệ quy: log n\n- Mỗi tầng: O(n) cho partition\n- Tổng: O(n log n)\n\n**Average Case: O(n log n)**\n- Với pivot ngẫu nhiên, expected time là O(n log n)\n- Ngay cả khi không chia đều (tỉ lệ 9:1), vẫn là O(n log n)\n\n**Worst Case: O(n²)**\n- Xảy ra khi pivot luôn là phần tử nhỏ nhất hoặc lớn nhất\n\n**Các khái niệm quan trọng:**\n- Lomuto Partition và Hoare Partition là hai kỹ thuật phân hoạch được sử dụng trong thuật toán Quicksort. Lomuto Partition chọn phần tử cuối cùng của mảng làm pivot, duyệt qua mảng để di chuyển các phần tử nhỏ hơn hoặc bằng pivot về phía bên trái, sau đó đặt pivot vào vị trí đúng của nó, nhưng có thể dẫn đến nhiều phép swap hơn. Ngược lại, Hoare Partition thường hiệu quả hơn (ít swap hơn), chọn phần tử đầu tiên hoặc giữa làm pivot, và sử dụng hai con trỏ di chuyển từ hai đầu mảng vào giữa để tìm và hoán đổi các phần tử không đúng vị trí so với pivot, trả về chỉ số của phần tử cuối cùng trong phần bên trái của pivot.\n\n**Mối quan hệ:**\n- Quicksort có thể sử dụng Hoare Partition để phân hoạch mảng trong quá trình sắp xếp, đây là một phương pháp thường hiệu quả hơn Lomuto Partition.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n    lt = low       # arr[low..lt-1] < pivot\n    i = low + 1    # arr[lt..i-1] == pivot\n    gt = high      # arr[gt+1..high] > pivot\n    \n    while i <= gt:\n        if arr[i] < pivot:\n            arr[lt], arr[i] = arr[i], arr[lt]\n            lt += 1\n            i += 1\n        elif arr[i] > pivot:\n            arr[i], arr[gt] = arr[gt], arr[i]\n            gt -= 1\n        else:\n            i += 1\n    \n    return lt, gt\n\ndef quick_sort_3way(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort với 3-way partitioning\n    Tối ưu cho mảng có nhiều phần tử trùng\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        lt, gt = three_way_partition(arr, low, high)\n        quick_sort_3way(arr, low, lt - 1)\n        quick_sort_3way(arr, gt + 1, high)\n    \n    return arr\n\n# Test với mảng có nhiều phần tử trùng\narr = [4, 9, 4, 4, 1, 9, 4, 4, 9, 4, 4, 1, 4]\nprint(\"Mảng có nhiều phần tử trùng:\", arr)\nprint(\"Sau 3-way quick sort:\", quick_sort_3way(arr.copy()))\n```\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Quick Select - Tìm phần tử thứ k\n\n```python\ndef quick_select(arr, k):\n    \"\"\"\n    Tìm phần tử thứ k nhỏ nhất (0-indexed)\n    Average: O(n), Worst: O(n²)\n    \"\"\"\n    def select(arr, low, high, k):\n        if low == high:\n            return arr[low]\n        \n        pivot_index = partition(arr, low, high)\n        \n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return select(arr, low, pivot_index - 1, k)\n        else:\n            return select(arr, pivot_index + 1, high, k)\n    \n    return select(arr, 0, len(arr) - 1, k)\n\n# Test\narr = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(f\"Phần tử thứ {k+1} nhỏ nhất:\", quick_select(arr.copy(), k))\n\n# Tìm median\ndef find_median(arr):\n    n = len(arr)\n    if n % 2 == 1:\n        return quick_select(arr, n // 2)\n    else:\n        return (quick_select(arr.copy(), n // 2 - 1) + \n                quick_select(arr.copy(), n // 2)) / 2\n\nprint(\"Median:\", find_median([3, 2, 1, 5, 6, 4]))\n```\n\n#### 5.2. Kth Largest Element\n\n```python\ndef find_kth_largest(arr, k):\n    \"\"\"\n    Tìm phần tử lớn thứ k\n    \"\"\"\n    # Phần tử lớn thứ k = phần tử thứ (n-k) từ trái\n    return quick_select(arr, len(arr) - k)\n\n# Test\narr = [3, 2, 3, 1, 2, 4, 5, 5, 6]\nprint(f\"Phần tử lớn thứ 4:\", find_kth_largest(arr, 4))\n```\n\n---\n\n### 6. So sánh với các thuật toán khác\n\n| Đặc điểm | Quick Sort | Merge Sort | Heap Sort |\n|----------|------------|------------|-----------|\n| **Average Time** | O(n log n) | O(n log n) | O(n log n) |\n| **Worst Time** | O(n²) | O(n log n) | O(n log n) |\n| **Space** | O(log n) | O(n) | O(1) |\n| **Stable** | ❌ | ✅ | ❌ |\n\n**Các khái niệm quan trọng:**\n- Quick Select là một thuật toán tìm phần tử thứ k nhỏ nhất (hoặc lớn nhất) trong một mảng không sắp xếp. Nó dựa trên ý tưởng phân hoạch của Quicksort nhưng chỉ đệ quy trên một phía của pivot, nơi chứa phần tử thứ k. Độ phức tạp thời gian trung bình là O(n), nhưng trong trường hợp xấu nhất có thể lên tới O(n²).\n\n**Mối quan hệ:**\n- Quick Select có độ phức tạp thời gian xấu nhất O(n²).\n- Quick Select giải quyết bài toán Tìm phần tử thứ k nhỏ nhất.\n- Quick Select sử dụng hàm partition để phân chia mảng và xác định vị trí của pivot."
        },
        "output_without_context": {
            "question": "Khi áp dụng cải tiến Quicksort bằng cách sử dụng sắp xếp chèn cho các mảng con nhỏ, điều gì sẽ xảy ra với hiệu suất của thuật toán?",
            "answer": "Hiệu suất của thuật toán sẽ được cải thiện."
        }
    },
    {
        "topic_description": "Giới thiệu về vấn đề cờ Hà Lan trong sắp xếp ba màu và cách thực hiện phân vùng 3 chiều để tối ưu hóa Quicksort. Học sinh cần biết cách xử lý tình huống đặc biệt này và cách áp dụng nó vào thuật toán. Nội dung liên quan đến các khái niệm từ tuần 1 và 2 về tối ưu hóa thuật toán, kiểm tra sự hiểu biết sâu hơn.",
        "output_with_context": {
            "question": "Trong thuật toán Quick Sort, phương pháp phân hoạch ba chiều (Three-Way Partitioning) được sử dụng để xử lý tình huống nào một cách hiệu quả nhất?",
            "answer": "Khi có nhiều phần tử trùng lặp trong mảng.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n- Ví dụ: Mảng đã sắp xếp với pivot là phần tử đầu/cuối\n- Độ cao cây đệ quy: n\n- Tổng: O(n²)\n\n**Minh họa Worst Case:**\n```\nMảng: [1, 2, 3, 4, 5] (pivot = cuối)\n\nLần 1: [1,2,3,4] | 5 | []       - n operations\nLần 2: [1,2,3] | 4 | []         - (n-1) operations\nLần 3: [1,2] | 3 | []           - (n-2) operations\n...\nTổng: n + (n-1) + (n-2) + ... + 1 = n(n+1)/2 = O(n²)\n```\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:**\n- **Best/Average case:** O(log n) - Chiều cao cây đệ quy\n- **Worst case:** O(n) - Cây đệ quy thoái hóa\n\n**In-place:** ✅ (không cần mảng phụ, chỉ dùng stack cho đệ quy)\n\n#### 3.3. Đặc điểm\n\n**Ưu điểm:**\n- ✅ Rất nhanh trong thực tế (cache-friendly)\n- ✅ In-place (O(log n) space)\n- ✅ Dễ song song hóa\n- ✅ Có thể tối ưu cho nhiều trường hợp\n\n**Nhược điểm:**\n- ❌ Unstable (không giữ thứ tự tương đối)\n- ❌ Worst case O(n²) (có thể tránh với random pivot)\n- ❌ Không tốt với dữ liệu đã sắp xếp (nếu không tối ưu)\n\n---\n\n### 4. Tối ưu hóa Quick Sort\n\n#### 4.1. Random Pivot (Tránh worst case)\n\n```python\nimport random\n\ndef randomized_partition(arr, low, high):\n    \"\"\"\n    Chọn pivot ngẫu nhiên\n    \"\"\"\n    # Chọn random index và đổi về cuối\n    random_index = random.randint(low, high)\n    arr[random_index], arr[high] = arr[high], arr[random_index]\n    return partition(arr, low, high)\n\ndef randomized_quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Randomized Quick Sort - Tránh worst case O(n²)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = randomized_partition(arr, low, high)\n        randomized_quick_sort(arr, low, pivot_index - 1)\n        randomized_quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n```\n\n#### 4.2. Median-of-Three (Tối ưu)\n\n```python\ndef median_of_three(arr, low, high):\n    \"\"\"\n    Chọn median của 3 phần tử làm pivot\n    \"\"\"\n    mid = (low + high) // 2\n    \n    # Sắp xếp 3 phần tử\n    if arr[low] > arr[mid]:\n        arr[low], arr[mid] = arr[mid], arr[low]\n    if arr[low] > arr[high]:\n        arr[low], arr[high] = arr[high], arr[low]\n    if arr[mid] > arr[high]:\n        arr[mid], arr[high] = arr[high], arr[mid]\n    \n    # Đặt median (arr[mid]) vào vị trí high-1\n    arr[mid], arr[high - 1] = arr[high - 1], arr[mid]\n    return arr[high - 1]\n```\n\n#### 4.3. Three-Way Partitioning (Dutch National Flag)\n\nXử lý tốt khi có nhiều phần tử trùng lặp.\n\n```python\ndef three_way_partition(arr, low, high):\n    \"\"\"\n    Chia mảng thành 3 phần: < pivot, = pivot, > pivot\n    \"\"\"\n    if high <= low:\n        return low, high\n    \n    pivot = arr[low]\n\n**Các khái niệm quan trọng:**\n- Three-Way Partitioning, còn được gọi là Dutch National Flag algorithm, là một kỹ thuật phân hoạch được sử dụng trong Quicksort để xử lý hiệu quả các mảng có nhiều phần tử trùng lặp. Kỹ thuật này chia mảng thành ba phần: các phần tử nhỏ hơn pivot, các phần tử bằng pivot, và các phần tử lớn hơn pivot.\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n\n**Mối quan hệ:**\n- quick_sort_3way là một biến thể của Quicksort, được tối ưu hóa cho các mảng có nhiều phần tử trùng lặp.\n- Three-Way Partitioning tối ưu hóa Quicksort khi có nhiều phần tử trùng lặp, bằng cách chia mảng thành ba phần.\n- Quicksort sử dụng three_way_partition để phân hoạch mảng thành ba phần, đặc biệt hiệu quả khi có nhiều phần tử trùng lặp.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n    lt = low       # arr[low..lt-1] < pivot\n    i = low + 1    # arr[lt..i-1] == pivot\n    gt = high      # arr[gt+1..high] > pivot\n    \n    while i <= gt:\n        if arr[i] < pivot:\n            arr[lt], arr[i] = arr[i], arr[lt]\n            lt += 1\n            i += 1\n        elif arr[i] > pivot:\n            arr[i], arr[gt] = arr[gt], arr[i]\n            gt -= 1\n        else:\n            i += 1\n    \n    return lt, gt\n\ndef quick_sort_3way(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort với 3-way partitioning\n    Tối ưu cho mảng có nhiều phần tử trùng\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        lt, gt = three_way_partition(arr, low, high)\n        quick_sort_3way(arr, low, lt - 1)\n        quick_sort_3way(arr, gt + 1, high)\n    \n    return arr\n\n# Test với mảng có nhiều phần tử trùng\narr = [4, 9, 4, 4, 1, 9, 4, 4, 9, 4, 4, 1, 4]\nprint(\"Mảng có nhiều phần tử trùng:\", arr)\nprint(\"Sau 3-way quick sort:\", quick_sort_3way(arr.copy()))\n```\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Quick Select - Tìm phần tử thứ k\n\n```python\ndef quick_select(arr, k):\n    \"\"\"\n    Tìm phần tử thứ k nhỏ nhất (0-indexed)\n    Average: O(n), Worst: O(n²)\n    \"\"\"\n    def select(arr, low, high, k):\n        if low == high:\n            return arr[low]\n        \n        pivot_index = partition(arr, low, high)\n        \n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return select(arr, low, pivot_index - 1, k)\n        else:\n            return select(arr, pivot_index + 1, high, k)\n    \n    return select(arr, 0, len(arr) - 1, k)\n\n# Test\narr = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(f\"Phần tử thứ {k+1} nhỏ nhất:\", quick_select(arr.copy(), k))\n\n# Tìm median\ndef find_median(arr):\n    n = len(arr)\n    if n % 2 == 1:\n        return quick_select(arr, n // 2)\n    else:\n        return (quick_select(arr.copy(), n // 2 - 1) + \n                quick_select(arr.copy(), n // 2)) / 2\n\nprint(\"Median:\", find_median([3, 2, 1, 5, 6, 4]))\n```\n\n#### 5.2. Kth Largest Element\n\n```python\ndef find_kth_largest(arr, k):\n    \"\"\"\n    Tìm phần tử lớn thứ k\n    \"\"\"\n    # Phần tử lớn thứ k = phần tử thứ (n-k) từ trái\n    return quick_select(arr, len(arr) - k)\n\n# Test\narr = [3, 2, 3, 1, 2, 4, 5, 5, 6]\nprint(f\"Phần tử lớn thứ 4:\", find_kth_largest(arr, 4))\n```\n\n---\n\n### 6. So sánh với các thuật toán khác\n\n| Đặc điểm | Quick Sort | Merge Sort | Heap Sort |\n|----------|------------|------------|-----------|\n| **Average Time** | O(n log n) | O(n log n) | O(n log n) |\n| **Worst Time** | O(n²) | O(n log n) | O(n log n) |\n| **Space** | O(log n) | O(n) | O(1) |\n| **Stable** | ❌ | ✅ | ❌ |\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n- quick_sort_3way là một phiên bản của Quicksort sử dụng kỹ thuật 3-way partitioning. Thuật toán này tối ưu cho các mảng có nhiều phần tử trùng lặp bằng cách nhóm tất cả các phần tử bằng pivot vào giữa, sau đó chỉ đệ quy sắp xếp hai phần còn lại (nhỏ hơn pivot và lớn hơn pivot). Điều này giúp giảm số lượng phần tử cần xử lý đệ quy, cải thiện hiệu suất trong các trường hợp cụ thể. Độ phức tạp thời gian trung bình là O(n log n), worst case là O(n²).\n- three_way_partition là một biến thể của thuật toán phân hoạch trong Quicksort, được thiết kế để xử lý hiệu quả các mảng có nhiều phần tử trùng lặp. Nó phân chia mảng thành ba vùng: các phần tử nhỏ hơn pivot, các phần tử bằng pivot, và các phần tử lớn hơn pivot. Các con trỏ `lt`, `i`, `gt` được sử dụng để quản lý các vùng này. Cụ thể, `arr[low..lt-1]` chứa các phần tử nhỏ hơn pivot, `arr[lt..i-1]` chứa các phần tử bằng pivot, và `arr[gt+1..high]` chứa các phần tử lớn hơn pivot.\n\n**Mối quan hệ:**\n- quick_sort_3way là một biến thể của Quicksort, được tối ưu hóa cho các mảng có nhiều phần tử trùng lặp.\n- Three-Way Partitioning tối ưu hóa Quicksort khi có nhiều phần tử trùng lặp, bằng cách chia mảng thành ba phần.\n- Quicksort sử dụng three_way_partition để phân hoạch mảng thành ba phần, đặc biệt hiệu quả khi có nhiều phần tử trùng lặp.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n[7, 8, 9] [10] []\n\nTiếp tục...\nKết quả: [1, 5, 7, 8, 9, 10]\n```\n\n---\n\n### 2. Thuật toán Quick Sort\n\n#### 2.1. Cài đặt cơ bản (Lomuto Partition)\n\n```python\ndef quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Lomuto partition scheme\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Partition và lấy vị trí pivot\n        pivot_index = partition(arr, low, high)\n        \n        # Đệ quy sắp xếp 2 phần\n        quick_sort(arr, low, pivot_index - 1)\n        quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef partition(arr, low, high):\n    \"\"\"\n    Lomuto partition: Chọn phần tử cuối làm pivot\n    \"\"\"\n    pivot = arr[high]\n    i = low - 1  # Index của phần tử nhỏ hơn\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Đặt pivot vào vị trí đúng\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", quick_sort(arr.copy()))\n```\n\n#### 2.2. Hoare Partition Scheme (Hiệu quả hơn)\n\n```python\ndef quick_sort_hoare(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Hoare partition scheme\n    Hiệu quả hơn Lomuto (ít swap hơn 3 lần)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = hoare_partition(arr, low, high)\n        quick_sort_hoare(arr, low, pivot_index)\n        quick_sort_hoare(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef hoare_partition(arr, low, high):\n    \"\"\"\n    Hoare partition: Pivot ở giữa, 2 con trỏ từ 2 đầu\n    \"\"\"\n    pivot = arr[low]\n    i = low - 1\n    j = high + 1\n    \n    while True:\n        # Tìm phần tử >= pivot từ trái\n        i += 1\n        while arr[i] < pivot:\n            i += 1\n        \n        # Tìm phần tử <= pivot từ phải\n        j -= 1\n        while arr[j] > pivot:\n            j -= 1\n        \n        # Nếu 2 con trỏ gặp nhau\n        if i >= j:\n            return j\n        \n        # Swap\n        arr[i], arr[j] = arr[j], arr[i]\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Hoare Partition:\", quick_sort_hoare(arr.copy()))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Best Case: O(n log n)**\n- Xảy ra khi pivot luôn chia mảng thành 2 phần bằng nhau\n- Độ cao cây đệ quy: log n\n- Mỗi tầng: O(n) cho partition\n- Tổng: O(n log n)\n\n**Average Case: O(n log n)**\n- Với pivot ngẫu nhiên, expected time là O(n log n)\n- Ngay cả khi không chia đều (tỉ lệ 9:1), vẫn là O(n log n)\n\n**Worst Case: O(n²)**\n- Xảy ra khi pivot luôn là phần tử nhỏ nhất hoặc lớn nhất\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n\n**Mối quan hệ:**\n- quick_sort_3way là một biến thể của Quicksort, được tối ưu hóa cho các mảng có nhiều phần tử trùng lặp.\n- Three-Way Partitioning tối ưu hóa Quicksort khi có nhiều phần tử trùng lặp, bằng cách chia mảng thành ba phần."
        },
        "output_without_context": {
            "question": "Trong vấn đề cờ Hà Lan, phương pháp phân vùng 3 chiều được sử dụng để sắp xếp ba màu khác nhau. Hãy đánh giá hiệu quả của phương pháp này so với thuật toán Quicksort truyền thống trong việc tối ưu hóa thời gian sắp xếp.",
            "answer": "Phương pháp phân vùng 3 chiều tối ưu hóa thuật toán Quicksort bằng cách giảm số lần so sánh và hoán đổi cần thiết."
        }
    },
    {
        "topic_description": "Khám phá các biến thể của Quicksort sử dụng hai và ba phần tử chốt để cải thiện hiệu suất. Học sinh cần hiểu cách mà những biến thể này thực hiện phân vùng và áp dụng chúng trong các trường hợp thực tế. Nội dung này có thể kiểm tra sự hiểu biết về các phương pháp tối ưu trong sắp xếp, liên kết với Mergesort từ tuần 3.",
        "output_with_context": {
            "question": "Trong thuật toán Quicksort ba chốt, phương pháp nào được sử dụng để phân chia mảng thành ba phần: phần tử nhỏ hơn pivot, phần tử bằng pivot và phần tử lớn hơn pivot?",
            "answer": "Three-Way Partitioning",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n    lt = low       # arr[low..lt-1] < pivot\n    i = low + 1    # arr[lt..i-1] == pivot\n    gt = high      # arr[gt+1..high] > pivot\n    \n    while i <= gt:\n        if arr[i] < pivot:\n            arr[lt], arr[i] = arr[i], arr[lt]\n            lt += 1\n            i += 1\n        elif arr[i] > pivot:\n            arr[i], arr[gt] = arr[gt], arr[i]\n            gt -= 1\n        else:\n            i += 1\n    \n    return lt, gt\n\ndef quick_sort_3way(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort với 3-way partitioning\n    Tối ưu cho mảng có nhiều phần tử trùng\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        lt, gt = three_way_partition(arr, low, high)\n        quick_sort_3way(arr, low, lt - 1)\n        quick_sort_3way(arr, gt + 1, high)\n    \n    return arr\n\n# Test với mảng có nhiều phần tử trùng\narr = [4, 9, 4, 4, 1, 9, 4, 4, 9, 4, 4, 1, 4]\nprint(\"Mảng có nhiều phần tử trùng:\", arr)\nprint(\"Sau 3-way quick sort:\", quick_sort_3way(arr.copy()))\n```\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Quick Select - Tìm phần tử thứ k\n\n```python\ndef quick_select(arr, k):\n    \"\"\"\n    Tìm phần tử thứ k nhỏ nhất (0-indexed)\n    Average: O(n), Worst: O(n²)\n    \"\"\"\n    def select(arr, low, high, k):\n        if low == high:\n            return arr[low]\n        \n        pivot_index = partition(arr, low, high)\n        \n        if k == pivot_index:\n            return arr[k]\n        elif k < pivot_index:\n            return select(arr, low, pivot_index - 1, k)\n        else:\n            return select(arr, pivot_index + 1, high, k)\n    \n    return select(arr, 0, len(arr) - 1, k)\n\n# Test\narr = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(f\"Phần tử thứ {k+1} nhỏ nhất:\", quick_select(arr.copy(), k))\n\n# Tìm median\ndef find_median(arr):\n    n = len(arr)\n    if n % 2 == 1:\n        return quick_select(arr, n // 2)\n    else:\n        return (quick_select(arr.copy(), n // 2 - 1) + \n                quick_select(arr.copy(), n // 2)) / 2\n\nprint(\"Median:\", find_median([3, 2, 1, 5, 6, 4]))\n```\n\n#### 5.2. Kth Largest Element\n\n```python\ndef find_kth_largest(arr, k):\n    \"\"\"\n    Tìm phần tử lớn thứ k\n    \"\"\"\n    # Phần tử lớn thứ k = phần tử thứ (n-k) từ trái\n    return quick_select(arr, len(arr) - k)\n\n# Test\narr = [3, 2, 3, 1, 2, 4, 5, 5, 6]\nprint(f\"Phần tử lớn thứ 4:\", find_kth_largest(arr, 4))\n```\n\n---\n\n### 6. So sánh với các thuật toán khác\n\n| Đặc điểm | Quick Sort | Merge Sort | Heap Sort |\n|----------|------------|------------|-----------|\n| **Average Time** | O(n log n) | O(n log n) | O(n log n) |\n| **Worst Time** | O(n²) | O(n log n) | O(n log n) |\n| **Space** | O(log n) | O(n) | O(1) |\n| **Stable** | ❌ | ✅ | ❌ |\n\n**Các khái niệm quan trọng:**\n- quick_sort_3way là một phiên bản của Quicksort sử dụng kỹ thuật 3-way partitioning. Thuật toán này tối ưu cho các mảng có nhiều phần tử trùng lặp bằng cách nhóm tất cả các phần tử bằng pivot vào giữa, sau đó chỉ đệ quy sắp xếp hai phần còn lại (nhỏ hơn pivot và lớn hơn pivot). Điều này giúp giảm số lượng phần tử cần xử lý đệ quy, cải thiện hiệu suất trong các trường hợp cụ thể. Độ phức tạp thời gian trung bình là O(n log n), worst case là O(n²).\n\n**Mối quan hệ:**\n- quick_sort_3way là một biến thể của Quicksort, được tối ưu hóa cho các mảng có nhiều phần tử trùng lặp.\n- quick_sort_3way có độ phức tạp thời gian xấu nhất O(n²).\n- quick_sort_3way có độ phức tạp thời gian trung bình O(n log n).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n- Ví dụ: Mảng đã sắp xếp với pivot là phần tử đầu/cuối\n- Độ cao cây đệ quy: n\n- Tổng: O(n²)\n\n**Minh họa Worst Case:**\n```\nMảng: [1, 2, 3, 4, 5] (pivot = cuối)\n\nLần 1: [1,2,3,4] | 5 | []       - n operations\nLần 2: [1,2,3] | 4 | []         - (n-1) operations\nLần 3: [1,2] | 3 | []           - (n-2) operations\n...\nTổng: n + (n-1) + (n-2) + ... + 1 = n(n+1)/2 = O(n²)\n```\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:**\n- **Best/Average case:** O(log n) - Chiều cao cây đệ quy\n- **Worst case:** O(n) - Cây đệ quy thoái hóa\n\n**In-place:** ✅ (không cần mảng phụ, chỉ dùng stack cho đệ quy)\n\n#### 3.3. Đặc điểm\n\n**Ưu điểm:**\n- ✅ Rất nhanh trong thực tế (cache-friendly)\n- ✅ In-place (O(log n) space)\n- ✅ Dễ song song hóa\n- ✅ Có thể tối ưu cho nhiều trường hợp\n\n**Nhược điểm:**\n- ❌ Unstable (không giữ thứ tự tương đối)\n- ❌ Worst case O(n²) (có thể tránh với random pivot)\n- ❌ Không tốt với dữ liệu đã sắp xếp (nếu không tối ưu)\n\n---\n\n### 4. Tối ưu hóa Quick Sort\n\n#### 4.1. Random Pivot (Tránh worst case)\n\n```python\nimport random\n\ndef randomized_partition(arr, low, high):\n    \"\"\"\n    Chọn pivot ngẫu nhiên\n    \"\"\"\n    # Chọn random index và đổi về cuối\n    random_index = random.randint(low, high)\n    arr[random_index], arr[high] = arr[high], arr[random_index]\n    return partition(arr, low, high)\n\ndef randomized_quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Randomized Quick Sort - Tránh worst case O(n²)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = randomized_partition(arr, low, high)\n        randomized_quick_sort(arr, low, pivot_index - 1)\n        randomized_quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n```\n\n#### 4.2. Median-of-Three (Tối ưu)\n\n```python\ndef median_of_three(arr, low, high):\n    \"\"\"\n    Chọn median của 3 phần tử làm pivot\n    \"\"\"\n    mid = (low + high) // 2\n    \n    # Sắp xếp 3 phần tử\n    if arr[low] > arr[mid]:\n        arr[low], arr[mid] = arr[mid], arr[low]\n    if arr[low] > arr[high]:\n        arr[low], arr[high] = arr[high], arr[low]\n    if arr[mid] > arr[high]:\n        arr[mid], arr[high] = arr[high], arr[mid]\n    \n    # Đặt median (arr[mid]) vào vị trí high-1\n    arr[mid], arr[high - 1] = arr[high - 1], arr[mid]\n    return arr[high - 1]\n```\n\n#### 4.3. Three-Way Partitioning (Dutch National Flag)\n\nXử lý tốt khi có nhiều phần tử trùng lặp.\n\n```python\ndef three_way_partition(arr, low, high):\n    \"\"\"\n    Chia mảng thành 3 phần: < pivot, = pivot, > pivot\n    \"\"\"\n    if high <= low:\n        return low, high\n    \n    pivot = arr[low]\n\n**Các khái niệm quan trọng:**\n- Three-Way Partitioning, còn được gọi là Dutch National Flag algorithm, là một kỹ thuật phân hoạch được sử dụng trong Quicksort để xử lý hiệu quả các mảng có nhiều phần tử trùng lặp. Kỹ thuật này chia mảng thành ba phần: các phần tử nhỏ hơn pivot, các phần tử bằng pivot, và các phần tử lớn hơn pivot.\n- Random Pivot là một kỹ thuật tối ưu hóa Quicksort bằng cách chọn phần tử pivot một cách ngẫu nhiên. Kỹ thuật này giúp tránh trường hợp xấu nhất O(n²) của Quicksort, chuyển đổi nó thành trường hợp trung bình O(n log n) với xác suất cao.\n- Randomized Quick Sort là một phiên bản của Quicksort sử dụng kỹ thuật Random Pivot để chọn pivot ngẫu nhiên. Điều này giúp giảm đáng kể khả năng gặp phải trường hợp xấu nhất O(n²) và đảm bảo hiệu suất trung bình O(n log n) với xác suất cao.\n\n**Mối quan hệ:**\n- Three-Way Partitioning tối ưu hóa Quicksort khi có nhiều phần tử trùng lặp, bằng cách chia mảng thành ba phần.\n- Randomized Quick Sort sử dụng kỹ thuật Random Pivot để cải thiện hiệu suất và tránh trường hợp xấu nhất.\n- Random Pivot tối ưu hóa Quicksort bằng cách chọn pivot ngẫu nhiên để tránh trường hợp xấu nhất O(n²).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n    \n    current.next = l1 if l1 else l2\n    \n    return dummy.next\n\n# Helper function\ndef print_list(head):\n    values = []\n    while head:\n        values.append(head.val)\n        head = head.next\n    print(values)\n\n# Test\nhead = ListNode(4, ListNode(2, ListNode(1, ListNode(3))))\nprint(\"Trước khi sắp xếp:\")\nprint_list(head)\nsorted_head = merge_sort_linked_list(head)\nprint(\"Sau khi sắp xếp:\")\nprint_list(sorted_head)\n```\n\n---\n\n### 8. Parallel Merge Sort\n\n```python\nfrom concurrent.futures import ThreadPoolExecutor\nimport threading\n\ndef parallel_merge_sort(arr, depth=0, max_depth=3):\n    \"\"\"\n    Merge sort song song sử dụng threads\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Sử dụng parallel khi depth nhỏ\n    if depth < max_depth:\n        with ThreadPoolExecutor(max_workers=2) as executor:\n            future_left = executor.submit(parallel_merge_sort, left, depth + 1, max_depth)\n            future_right = executor.submit(parallel_merge_sort, right, depth + 1, max_depth)\n            \n            left = future_left.result()\n            right = future_right.result()\n    else:\n        # Sequential cho các phần nhỏ\n        left = merge_sort(left)\n        right = merge_sort(right)\n    \n    return merge(left, right)\n\n# Test\nimport time\narr = list(range(10000, 0, -1))\n\nstart = time.time()\nsorted_arr = merge_sort(arr.copy())\nsequential_time = time.time() - start\n\nstart = time.time()\nsorted_arr = parallel_merge_sort(arr.copy())\nparallel_time = time.time() - start\n\nprint(f\"Sequential: {sequential_time:.4f}s\")\nprint(f\"Parallel: {parallel_time:.4f}s\")\nprint(f\"Speedup: {sequential_time/parallel_time:.2f}x\")\n```\n\n---\n\n## Quicksort\n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\nQuick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật **Chia để trị (Divide and Conquer)**. Thuật toán chọn một phần tử làm \"pivot\" (chốt), phân hoạch mảng sao cho các phần tử nhỏ hơn pivot ở bên trái và các phần tử lớn hơn ở bên phải, sau đó đệ quy sắp xếp hai phần.\n\n**Đặc điểm nổi bật:**\n- Được phát minh bởi Tony Hoare năm 1960\n- Là thuật toán sắp xếp phổ biến nhất trong thực tế\n- Average case O(n log n), nhưng worst case O(n²)\n- In-place sorting (không cần bộ nhớ phụ nhiều)\n\n#### 1.2. Ý tưởng chính\n\n**Nguyên lý:**\n1. **Chọn Pivot:** Chọn một phần tử làm pivot (có thể là đầu, cuối, giữa, hoặc random)\n2. **Partition:** Sắp xếp lại mảng sao cho:\n   - Tất cả phần tử < pivot ở bên trái\n   - Tất cả phần tử > pivot ở bên phải\n   - Pivot ở đúng vị trí cuối cùng\n3. **Đệ quy:** Áp dụng quick sort cho phần trái và phần phải\n\n**Ví dụ trực quan:**\n```\nMảng: [10, 7, 8, 9, 1, 5]\nPivot: 5 (phần tử cuối)\n\nSau partition:\n[1] [5] [7, 8, 9, 10]\n ^   ^   ^\n Trái  Pivot  Phải\n\nĐệ quy sắp xếp [7, 8, 9, 10]:\nPivot: 10\n\n**Các khái niệm quan trọng:**\n- Quick Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật Chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chọn một phần tử làm \"pivot\" và phân hoạch mảng thành các phần tử nhỏ hơn pivot ở một bên và các phần tử lớn hơn pivot ở bên còn lại. Sau đó, thuật toán đệ quy sắp xếp hai (hoặc ba, trong 3-way Quicksort) phần này. Quick Sort có độ phức tạp thời gian trung bình và tốt nhất là O(n log n), nhưng trong trường hợp xấu nhất là O(n²). Độ phức tạp không gian là O(log n) do đệ quy. Nó là một thuật toán sắp xếp tại chỗ (in-place), thường nhanh hơn trong thực tế so với Mergesort, cache-friendly và dễ song song hóa. Tuy nhiên, Quick Sort không đảm bảo tính ổn định (unstable) và có thể không hiệu quả với dữ liệu đã gần sắp xếp trừ khi sử dụng pivot ngẫu nhiên. Quick Sort có hai scheme phân hoạch chính là Lomuto và Hoare, trong đó Hoare thường hiệu quả hơn.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n```python\ndef merge_sort_optimized(arr):\n    \"\"\"\n    Sử dụng một mảng phụ duy nhất cho toàn bộ quá trình\n    \"\"\"\n    n = len(arr)\n    temp = [0] * n\n    \n    def sort_helper(left, right):\n        if left < right:\n            mid = (left + right) // 2\n            sort_helper(left, mid)\n            sort_helper(mid + 1, right)\n            merge_with_temp(left, mid, right)\n    \n    def merge_with_temp(left, mid, right):\n        # Copy vào mảng tạm\n        for i in range(left, right + 1):\n            temp[i] = arr[i]\n        \n        i, j = left, mid + 1\n        k = left\n        \n        while i <= mid and j <= right:\n            if temp[i] <= temp[j]:\n                arr[k] = temp[i]\n                i += 1\n            else:\n                arr[k] = temp[j]\n                j += 1\n            k += 1\n        \n        while i <= mid:\n            arr[k] = temp[i]\n            i += 1\n            k += 1\n    \n    sort_helper(0, n - 1)\n    return arr\n```\n\n#### 3.3. Đặc điểm\n\n**Ưu điểm:**\n- ✅ **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- ✅ **Predictable:** Luôn O(n log n) cho mọi trường hợp\n- ✅ **Parallelizable:** Có thể song song hóa dễ dàng\n- ✅ **External sorting:** Thích hợp cho sắp xếp dữ liệu lớn không fit trong RAM\n\n**Nhược điểm:**\n- ❌ **Space:** Cần O(n) bộ nhớ phụ\n- ❌ **Not in-place:** (Phiên bản chuẩn)\n- ❌ **Overhead:** Chi phí đệ quy và copy dữ liệu\n\n---\n\n### 4. Các biến thể và tối ưu hóa\n\n#### 4.1. Natural Merge Sort\n\nTận dụng các phần đã sắp xếp tự nhiên trong mảng.\n\n```python\ndef natural_merge_sort(arr):\n    \"\"\"\n    Tận dụng các dãy con đã được sắp xếp sẵn\n    \"\"\"\n    n = len(arr)\n    \n    def get_runs():\n        \"\"\"Tìm các dãy con đã sắp xếp\"\"\"\n        runs = []\n        i = 0\n        \n        while i < n:\n            start = i\n            # Tìm dãy tăng dần\n            while i < n - 1 and arr[i] <= arr[i + 1]:\n                i += 1\n            runs.append((start, i))\n            i += 1\n        \n        return runs\n    \n    while True:\n        runs = get_runs()\n        if len(runs) <= 1:\n            break\n        \n        # Gộp các runs liên tiếp\n        new_runs = []\n        for i in range(0, len(runs), 2):\n            if i + 1 < len(runs):\n                left_start, left_end = runs[i]\n                right_start, right_end = runs[i + 1]\n                merge_inplace(arr, left_start, left_end, right_end)\n                new_runs.append((left_start, right_end))\n            else:\n                new_runs.append(runs[i])\n    \n    return arr\n```\n\n#### 4.2. Bottom-up Merge Sort\n\n```python\ndef bottom_up_merge_sort(arr):\n    \"\"\"\n    Merge sort không dùng đệ quy, gộp từ dưới lên\n    \"\"\"\n    n = len(arr)\n    width = 1\n    \n    while width < n:\n        left = 0\n        while left < n:\n            mid = min(left + width - 1, n - 1)\n            right = min(left + 2 * width - 1, n - 1)\n            \n            if mid < right:\n                merge_inplace(arr, left, mid, right)\n            \n            left += 2 * width\n        \n        width *= 2\n    \n    return arr\n```\n\n#### 4.3. Hybrid Merge Sort (Tim Sort inspired)\n\nKết hợp với Insertion Sort cho các mảng con nhỏ.\n\n\n**Các khái niệm quan trọng:**\n- merge_sort_optimized là một phiên bản của Mergesort sử dụng một mảng phụ duy nhất (temp) cho toàn bộ quá trình sắp xếp. Nó chia mảng thành các nửa, sắp xếp đệ quy từng nửa, sau đó gộp chúng lại bằng cách sử dụng mảng tạm để tránh việc cấp phát bộ nhớ liên tục. Độ phức tạp thời gian là O(n log n) và độ phức tạp không gian là O(n).\n\n**Mối quan hệ:**\n- merge_sort_optimized là một biến thể của Mergesort.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n[7, 8, 9] [10] []\n\nTiếp tục...\nKết quả: [1, 5, 7, 8, 9, 10]\n```\n\n---\n\n### 2. Thuật toán Quick Sort\n\n#### 2.1. Cài đặt cơ bản (Lomuto Partition)\n\n```python\ndef quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Lomuto partition scheme\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Partition và lấy vị trí pivot\n        pivot_index = partition(arr, low, high)\n        \n        # Đệ quy sắp xếp 2 phần\n        quick_sort(arr, low, pivot_index - 1)\n        quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef partition(arr, low, high):\n    \"\"\"\n    Lomuto partition: Chọn phần tử cuối làm pivot\n    \"\"\"\n    pivot = arr[high]\n    i = low - 1  # Index của phần tử nhỏ hơn\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Đặt pivot vào vị trí đúng\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", quick_sort(arr.copy()))\n```\n\n#### 2.2. Hoare Partition Scheme (Hiệu quả hơn)\n\n```python\ndef quick_sort_hoare(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Hoare partition scheme\n    Hiệu quả hơn Lomuto (ít swap hơn 3 lần)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = hoare_partition(arr, low, high)\n        quick_sort_hoare(arr, low, pivot_index)\n        quick_sort_hoare(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef hoare_partition(arr, low, high):\n    \"\"\"\n    Hoare partition: Pivot ở giữa, 2 con trỏ từ 2 đầu\n    \"\"\"\n    pivot = arr[low]\n    i = low - 1\n    j = high + 1\n    \n    while True:\n        # Tìm phần tử >= pivot từ trái\n        i += 1\n        while arr[i] < pivot:\n            i += 1\n        \n        # Tìm phần tử <= pivot từ phải\n        j -= 1\n        while arr[j] > pivot:\n            j -= 1\n        \n        # Nếu 2 con trỏ gặp nhau\n        if i >= j:\n            return j\n        \n        # Swap\n        arr[i], arr[j] = arr[j], arr[i]\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Hoare Partition:\", quick_sort_hoare(arr.copy()))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Best Case: O(n log n)**\n- Xảy ra khi pivot luôn chia mảng thành 2 phần bằng nhau\n- Độ cao cây đệ quy: log n\n- Mỗi tầng: O(n) cho partition\n- Tổng: O(n log n)\n\n**Average Case: O(n log n)**\n- Với pivot ngẫu nhiên, expected time là O(n log n)\n- Ngay cả khi không chia đều (tỉ lệ 9:1), vẫn là O(n log n)\n\n**Worst Case: O(n²)**\n- Xảy ra khi pivot luôn là phần tử nhỏ nhất hoặc lớn nhất\n\n**Các khái niệm quan trọng:**\n- Lomuto Partition và Hoare Partition là hai kỹ thuật phân hoạch được sử dụng trong thuật toán Quicksort. Lomuto Partition chọn phần tử cuối cùng của mảng làm pivot, duyệt qua mảng để di chuyển các phần tử nhỏ hơn hoặc bằng pivot về phía bên trái, sau đó đặt pivot vào vị trí đúng của nó, nhưng có thể dẫn đến nhiều phép swap hơn. Ngược lại, Hoare Partition thường hiệu quả hơn (ít swap hơn), chọn phần tử đầu tiên hoặc giữa làm pivot, và sử dụng hai con trỏ di chuyển từ hai đầu mảng vào giữa để tìm và hoán đổi các phần tử không đúng vị trí so với pivot, trả về chỉ số của phần tử cuối cùng trong phần bên trái của pivot.\n\n**Mối quan hệ:**\n- Quicksort có thể sử dụng Lomuto Partition để phân hoạch mảng trong quá trình sắp xếp."
        },
        "output_without_context": {
            "question": "Trong thuật toán Quicksort sử dụng ba chốt, chốt nào được sử dụng để phân vùng mảng thành ba phần: nhỏ hơn, bằng và lớn hơn?",
            "answer": "Chốt giữa."
        }
    },
    {
        "topic_description": "Tìm hiểu cách thức hoạt động của phương thức Arrays.sort() trong Java 7 và sự khác biệt giữa việc sử dụng quicksort hai chốt và Timsort. Học sinh nên biết khi nào sử dụng các phương thức nào để đạt hiệu suất tối ưu trong thực tiễn. Nội dung liên quan đến việc hiểu rõ các ứng dụng từ kiến thức học được ở tuần 2 và tuần 3.",
        "output_with_context": {
            "question": "Trong Java 7, phương thức nào được sử dụng để sắp xếp mảng và có sự khác biệt giữa quicksort hai chốt và Timsort?",
            "answer": "Arrays.sort()",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\nfor size in [100, 500, 1000]:\n    compare_sorting_algorithms(size)\n```\n\n#### 5.3. Ứng dụng thực tế\n\n**1. Sắp xếp trong Database:**\n- Sử dụng Insertion Sort cho dữ liệu nhỏ\n- Kết hợp với các thuật toán nâng cao\n\n**2. Sắp xếp trong thư viện:**\n```python\n# Python's sorted() và list.sort() sử dụng Timsort\n# (kết hợp Merge Sort và Insertion Sort)\n\n# Sắp xếp cơ bản\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6]\nsorted_numbers = sorted(numbers)\n\n# Sắp xếp với key function\nstudents = [\n    {'name': 'An', 'score': 85},\n    {'name': 'Bình', 'score': 92},\n    {'name': 'Chi', 'score': 78}\n]\nsorted_students = sorted(students, key=lambda x: x['score'], reverse=True)\n```\n\n**3. Sắp xếp custom objects:**\n```python\nclass Student:\n    def __init__(self, name, grade):\n        self.name = name\n        self.grade = grade\n    \n    def __lt__(self, other):\n        return self.grade < other.grade\n    \n    def __repr__(self):\n        return f\"Student({self.name}, {self.grade})\"\n\nstudents = [Student(\"An\", 85), Student(\"Bình\", 92), Student(\"Chi\", 78)]\nsorted_students = insertion_sort(students)\nprint(sorted_students)\n```\n\n---\n\n### 6. Tối ưu hóa và Thủ thuật\n\n#### 6.1. Early termination (Dừng sớm)\n\n```python\ndef optimized_bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:  # Dừng nếu không có hoán đổi\n            break\n    return arr\n```\n\n#### 6.2. Giảm số lần hoán đổi\n\n```python\ndef optimized_insertion_sort(arr):\n    \"\"\"Sử dụng shifting thay vì swapping\"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]  # Shift thay vì swap\n            j -= 1\n        arr[j + 1] = key\n    return arr\n```\n\n#### 6.3. Hybrid approach\n\n```python\ndef hybrid_sort(arr, threshold=10):\n    \"\"\"Sử dụng Insertion Sort cho mảng nhỏ\"\"\"\n    if len(arr) <= threshold:\n        return insertion_sort(arr)\n    else:\n        # Sử dụng thuật toán khác cho mảng lớn\n        return sorted(arr)  # Placeholder\n```\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Timsort là một thuật toán sắp xếp lai (hybrid sorting algorithm) được sử dụng trong Python và Java (đặc biệt cho các kiểu đối tượng). Nó kết hợp các ưu điểm của Merge Sort và Insertion Sort để đạt được hiệu suất tốt trên nhiều loại dữ liệu thực tế, đặc biệt là với dữ liệu có pattern hoặc đã sắp xếp một phần. Timsort là một thuật toán stable sorting, đảm bảo độ phức tạp thời gian worst case O(n log n), average case O(n log n), và best case O(n). Độ phức tạp không gian của nó là O(n) trong trường hợp xấu nhất, O(n/2) trong trường hợp trung bình, và O(1) trong trường hợp tốt nhất (khi mảng đã sắp xếp).\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n- hybrid_sort là một thuật toán sắp xếp minh họa cách tiếp cận lai (hybrid approach). Nó sử dụng Insertion Sort cho các mảng có kích thước nhỏ hơn hoặc bằng một ngưỡng (threshold) nhất định, và một thuật toán khác (ở đây là `sorted()` của Python) cho các mảng lớn hơn. Kỹ thuật này tận dụng hiệu quả của Insertion Sort trên dữ liệu nhỏ và hiệu quả của các thuật toán phức tạp hơn trên dữ liệu lớn.\n- optimized_bubble_sort là phiên bản tối ưu hóa của Bubble Sort, sử dụng kỹ thuật dừng sớm (early termination). Nếu trong một lần duyệt không có bất kỳ hoán đổi nào xảy ra, điều đó có nghĩa là mảng đã được sắp xếp và thuật toán có thể dừng lại. Điều này cải thiện độ phức tạp thời gian của Best case từ O(n²) xuống O(n).\n\n**Mối quan hệ:**\n- hybrid_sort sử dụng hàm sorted() của Python (dựa trên Timsort) cho các mảng có kích thước lớn hơn ngưỡng.\n- Merge Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong một mảng theo thứ tự mong muốn.\n- Hàm sorted() của Python sử dụng thuật toán Timsort để sắp xếp các iterable.\n- Phương thức list.sort() của Python sử dụng thuật toán Timsort để sắp xếp danh sách.\n- Timsort sử dụng Insertion Sort làm một trong các thành phần chính của nó, đặc biệt cho các đoạn dữ liệu nhỏ hoặc gần như đã sắp xếp.\n- optimized_bubble_sort áp dụng kỹ thuật Early termination để dừng sớm nếu mảng đã được sắp xếp.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n[7, 8, 9] [10] []\n\nTiếp tục...\nKết quả: [1, 5, 7, 8, 9, 10]\n```\n\n---\n\n### 2. Thuật toán Quick Sort\n\n#### 2.1. Cài đặt cơ bản (Lomuto Partition)\n\n```python\ndef quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Lomuto partition scheme\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Partition và lấy vị trí pivot\n        pivot_index = partition(arr, low, high)\n        \n        # Đệ quy sắp xếp 2 phần\n        quick_sort(arr, low, pivot_index - 1)\n        quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef partition(arr, low, high):\n    \"\"\"\n    Lomuto partition: Chọn phần tử cuối làm pivot\n    \"\"\"\n    pivot = arr[high]\n    i = low - 1  # Index của phần tử nhỏ hơn\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Đặt pivot vào vị trí đúng\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", quick_sort(arr.copy()))\n```\n\n#### 2.2. Hoare Partition Scheme (Hiệu quả hơn)\n\n```python\ndef quick_sort_hoare(arr, low=0, high=None):\n    \"\"\"\n    Quick Sort sử dụng Hoare partition scheme\n    Hiệu quả hơn Lomuto (ít swap hơn 3 lần)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = hoare_partition(arr, low, high)\n        quick_sort_hoare(arr, low, pivot_index)\n        quick_sort_hoare(arr, pivot_index + 1, high)\n    \n    return arr\n\ndef hoare_partition(arr, low, high):\n    \"\"\"\n    Hoare partition: Pivot ở giữa, 2 con trỏ từ 2 đầu\n    \"\"\"\n    pivot = arr[low]\n    i = low - 1\n    j = high + 1\n    \n    while True:\n        # Tìm phần tử >= pivot từ trái\n        i += 1\n        while arr[i] < pivot:\n            i += 1\n        \n        # Tìm phần tử <= pivot từ phải\n        j -= 1\n        while arr[j] > pivot:\n            j -= 1\n        \n        # Nếu 2 con trỏ gặp nhau\n        if i >= j:\n            return j\n        \n        # Swap\n        arr[i], arr[j] = arr[j], arr[i]\n\n# Test\narr = [10, 7, 8, 9, 1, 5]\nprint(\"Hoare Partition:\", quick_sort_hoare(arr.copy()))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Best Case: O(n log n)**\n- Xảy ra khi pivot luôn chia mảng thành 2 phần bằng nhau\n- Độ cao cây đệ quy: log n\n- Mỗi tầng: O(n) cho partition\n- Tổng: O(n log n)\n\n**Average Case: O(n log n)**\n- Với pivot ngẫu nhiên, expected time là O(n log n)\n- Ngay cả khi không chia đều (tỉ lệ 9:1), vẫn là O(n log n)\n\n**Worst Case: O(n²)**\n- Xảy ra khi pivot luôn là phần tử nhỏ nhất hoặc lớn nhất\n\n**Các khái niệm quan trọng:**\n- Lomuto Partition và Hoare Partition là hai kỹ thuật phân hoạch được sử dụng trong thuật toán Quicksort. Lomuto Partition chọn phần tử cuối cùng của mảng làm pivot, duyệt qua mảng để di chuyển các phần tử nhỏ hơn hoặc bằng pivot về phía bên trái, sau đó đặt pivot vào vị trí đúng của nó, nhưng có thể dẫn đến nhiều phép swap hơn. Ngược lại, Hoare Partition thường hiệu quả hơn (ít swap hơn), chọn phần tử đầu tiên hoặc giữa làm pivot, và sử dụng hai con trỏ di chuyển từ hai đầu mảng vào giữa để tìm và hoán đổi các phần tử không đúng vị trí so với pivot, trả về chỉ số của phần tử cuối cùng trong phần bên trái của pivot.\n\n**Mối quan hệ:**\n- Quicksort có thể sử dụng Hoare Partition để phân hoạch mảng trong quá trình sắp xếp, đây là một phương pháp thường hiệu quả hơn Lomuto Partition.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n| **In-place** | ✅ | ❌ | ✅ |\n| **Cache-friendly** | ✅ | ❌ | ⚠️ |\n\n#### 6.1. Khi nào dùng Quick Sort?\n\n**Nên dùng:**\n- ✅ Mảng trong RAM (in-memory sorting)\n- ✅ Cần sorting nhanh nhất average case\n- ✅ Bộ nhớ hạn chế\n- ✅ Random access data (array)\n- ✅ Không cần stable sort\n\n**Không nên dùng:**\n- ❌ Cần đảm bảo O(n log n) worst case\n- ❌ Cần stable sorting\n- ❌ Linked list (Merge Sort tốt hơn)\n- ❌ Dữ liệu đã gần sắp xếp (trừ khi dùng random pivot)\n\n---\n\n### 7. Quick Sort trong thư viện chuẩn\n\n#### 7.1. Python's sorted() và sort()\n\nPython sử dụng **Timsort** (hybrid của Merge Sort và Insertion Sort), không phải Quick Sort, vì:\n- Stable sorting\n- Tốt với dữ liệu có pattern\n- Worst case O(n log n) đảm bảo\n\n#### 7.2. C++ std::sort()\n\nC++ sử dụng **Introsort** (Introspective Sort):\n- Bắt đầu với Quick Sort\n- Chuyển sang Heap Sort nếu đệ quy quá sâu (tránh O(n²))\n- Dùng Insertion Sort cho mảng nhỏ\n\n#### 7.3. Java's Arrays.sort()\n\n- **Primitive types:** Dual-Pivot Quick Sort\n- **Object types:** Timsort (stable)\n\n---\n\n## Priority Queue & Binary Heap\n\n### 1. Giới thiệu Priority Queue\n\n#### 1.1. Khái niệm\n\n**Priority Queue (Hàng đợi ưu tiên)** là một cấu trúc dữ liệu trừu tượng trong đó mỗi phần tử có một độ ưu tiên (priority) được gán cho nó. Phần tử có độ ưu tiên cao nhất được xử lý trước, bất kể thứ tự chèn vào.\n\n**Khác với Queue thông thường:**\n- Queue thông thường: FIFO (First In First Out)\n- Priority Queue: Phần tử có priority cao nhất ra trước\n\n**Ví dụ thực tế:**\n- **Hệ thống cấp cứu:** Bệnh nhân nguy kịch được ưu tiên khám trước\n- **CPU Scheduling:** Process có priority cao được xử lý trước\n- **Dijkstra Algorithm:** Chọn đỉnh có khoảng cách nhỏ nhất\n- **A* Search:** Chọn node có f(n) nhỏ nhất\n- **Huffman Coding:** Xây dựng cây mã hóa\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Insert/Enqueue:** Thêm phần tử với priority\n**b) Extract-Max/Min:** Lấy và xóa phần tử có priority cao/thấp nhất\n**c) Peek/Top:** Xem phần tử có priority cao/thấp nhất\n**d) Change Priority:** Thay đổi priority của phần tử\n**e) Delete:** Xóa phần tử bất kỳ\n\n#### 1.3. Các cách cài đặt\n\n| Cài đặt | Insert | Extract-Max | Peek |\n|---------|--------|-------------|------|\n| Array (unsorted) | O(1) | O(n) | O(n) |\n| Array (sorted) | O(n) | O(1) | O(1) |\n| Linked List | O(n) | O(1) | O(1) |\n| **Binary Heap** | **O(log n)** | **O(log n)** | **O(1)** |\n| Fibonacci Heap | O(1) | O(log n) | O(1) |\n\n\n**Các khái niệm quan trọng:**\n- Timsort là một thuật toán sắp xếp lai (hybrid sorting algorithm) được sử dụng trong Python và Java (đặc biệt cho các kiểu đối tượng). Nó kết hợp các ưu điểm của Merge Sort và Insertion Sort để đạt được hiệu suất tốt trên nhiều loại dữ liệu thực tế, đặc biệt là với dữ liệu có pattern hoặc đã sắp xếp một phần. Timsort là một thuật toán stable sorting, đảm bảo độ phức tạp thời gian worst case O(n log n), average case O(n log n), và best case O(n). Độ phức tạp không gian của nó là O(n) trong trường hợp xấu nhất, O(n/2) trong trường hợp trung bình, và O(1) trong trường hợp tốt nhất (khi mảng đã sắp xếp).\n\n**Mối quan hệ:**\n- Hàm sorted() của Python sử dụng thuật toán Timsort để sắp xếp các iterable.\n- Phương thức list.sort() của Python sử dụng thuật toán Timsort để sắp xếp danh sách.\n- Timsort sử dụng Insertion Sort làm một trong các thành phần chính của nó, đặc biệt cho các đoạn dữ liệu nhỏ hoặc gần như đã sắp xếp."
        },
        "output_without_context": {
            "question": "Phương thức nào được sử dụng để sắp xếp mảng trong Java 7?",
            "answer": "Arrays.sort()"
        }
    }
]