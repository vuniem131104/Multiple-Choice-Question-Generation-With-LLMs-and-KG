[
    {
        "topic_description": "Mergesort là một thuật toán sắp xếp cố điển, hoạt động theo nguyên tắc chia để trị. Chủ đề này kiểm tra hiểu biết của sinh viên về cách hoạt động và quy trình của Mergesort, bao gồm việc chia mảng và quá trình hợp nhất. Câu hỏi có thể liên quan đến định nghĩa và quy trình cụ thể của thuật toán này.",
        "output_with_context": {
            "question": "Mergesort là thuật toán sắp xếp nào trong các thuật toán sau đây?",
            "answer": "Chia để trị.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n```python\ndef hybrid_merge_sort(arr, threshold=10):\n    \"\"\"\n    Sử dụng Insertion Sort cho mảng nhỏ\n    \"\"\"\n    def insertion_sort_range(arr, left, right):\n        for i in range(left + 1, right + 1):\n            key = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key\n    \n    def merge_sort_helper(left, right):\n        if right - left + 1 <= threshold:\n            insertion_sort_range(arr, left, right)\n        elif left < right:\n            mid = (left + right) // 2\n            merge_sort_helper(left, mid)\n            merge_sort_helper(mid + 1, right)\n            merge_inplace(arr, left, mid, right)\n    \n    merge_sort_helper(0, len(arr) - 1)\n    return arr\n```\n\n#### 4.4. 3-way Merge Sort\n\nChia mảng thành 3 phần thay vì 2.\n\n```python\ndef three_way_merge_sort(arr):\n    \"\"\"\n    Chia mảng thành 3 phần\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    n = len(arr)\n    third = n // 3\n    \n    # Chia thành 3 phần\n    left = merge_sort(arr[:third])\n    middle = merge_sort(arr[third:2*third])\n    right = merge_sort(arr[2*third:])\n    \n    # Gộp 3 phần\n    return merge_three(left, middle, right)\n\ndef merge_three(left, middle, right):\n    \"\"\"\n    Gộp 3 mảng đã sắp xếp\n    \"\"\"\n    result = []\n    i = j = k = 0\n    \n    while i < len(left) and j < len(middle) and k < len(right):\n        if left[i] <= middle[j] and left[i] <= right[k]:\n            result.append(left[i])\n            i += 1\n        elif middle[j] <= left[i] and middle[j] <= right[k]:\n            result.append(middle[j])\n            j += 1\n        else:\n            result.append(right[k])\n            k += 1\n    \n    # Gộp 2 mảng còn lại\n    while i < len(left) and j < len(middle):\n        if left[i] <= middle[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(middle[j])\n            j += 1\n    \n    while i < len(left) and k < len(right):\n        if left[i] <= right[k]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[k])\n            k += 1\n    \n    while j < len(middle) and k < len(right):\n        if middle[j] <= right[k]:\n            result.append(middle[j])\n            j += 1\n        else:\n            result.append(right[k])\n            k += 1\n    \n    # Thêm phần tử còn lại\n    result.extend(left[i:])\n    result.extend(middle[j:])\n    result.extend(right[k:])\n    \n    return result\n```\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. External Sorting (Sắp xếp file lớn)\n\n```python\nimport os\nimport heapq\n\ndef external_merge_sort(input_file, output_file, chunk_size=1000):\n    \"\"\"\n    Sắp xếp file lớn không fit trong RAM\n    \"\"\"\n    # Bước 1: Chia file thành các chunk nhỏ và sắp xếp\n    temp_files = []\n    with open(input_file, 'r') as f:\n        chunk = []\n        for line in f:\n            chunk.append(int(line.strip()))\n            \n            if len(chunk) >= chunk_size:\n                chunk.sort()\n                temp_file = f\"temp_{len(temp_files)}.txt\"\n                with open(temp_file, 'w') as tf:\n                    tf.writelines(f\"{x}\n\" for x in chunk)\n                temp_files.append(temp_file)\n                chunk = []\n        \n        # Xử lý chunk cuối\n        if chunk:\n            chunk.sort()\n            temp_file = f\"temp_{len(temp_files)}.txt\"\n            with open(temp_file, 'w') as tf:\n                tf.writelines(f\"{x}\n\" for x in chunk)\n            temp_files.append(temp_file)\n    \n\n**Các khái niệm quan trọng:**\n- Merge Sort (hoặc Mergesort) là một thuật toán sắp xếp hiệu quả dựa trên kỹ thuật chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chia mảng thành hai nửa, sắp xếp đệ quy từng nửa, sau đó trộn (gộp) hai nửa đã sắp xếp lại với nhau. Merge Sort là một thuật toán sắp xếp ổn định (stable) và có độ phức tạp thời gian O(n log n) trong mọi trường hợp (best, average, worst case). Độ phức tạp không gian của nó là O(n) do cần không gian phụ (mảng tạm) để thực hiện quá trình trộn. Merge Sort có thể được cài đặt bằng đệ quy hoặc lặp, thích hợp cho việc sắp xếp dữ liệu lớn không vừa trong RAM (external sorting), có thể song song hóa, và hiệu quả khi sắp xếp các cấu trúc dữ liệu như linked list. Ngoài ra, Mergesort có thể được sửa đổi để đếm số lần đảo ngược trong một mảng, với một hàm phụ trợ `merge_count` có độ phức tạp O(k) để đếm đảo ngược khi trộn hai mảng con.\n\n**Mối quan hệ:**\n- Mergesort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các nửa, sắp xếp đệ quy, và sau đó gộp lại.\n- Mergesort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các mảng con, sắp xếp đệ quy chúng, và sau đó gộp các kết quả lại.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n```python\ndef merge_sort_optimized(arr):\n    \"\"\"\n    Sử dụng một mảng phụ duy nhất cho toàn bộ quá trình\n    \"\"\"\n    n = len(arr)\n    temp = [0] * n\n    \n    def sort_helper(left, right):\n        if left < right:\n            mid = (left + right) // 2\n            sort_helper(left, mid)\n            sort_helper(mid + 1, right)\n            merge_with_temp(left, mid, right)\n    \n    def merge_with_temp(left, mid, right):\n        # Copy vào mảng tạm\n        for i in range(left, right + 1):\n            temp[i] = arr[i]\n        \n        i, j = left, mid + 1\n        k = left\n        \n        while i <= mid and j <= right:\n            if temp[i] <= temp[j]:\n                arr[k] = temp[i]\n                i += 1\n            else:\n                arr[k] = temp[j]\n                j += 1\n            k += 1\n        \n        while i <= mid:\n            arr[k] = temp[i]\n            i += 1\n            k += 1\n    \n    sort_helper(0, n - 1)\n    return arr\n```\n\n#### 3.3. Đặc điểm\n\n**Ưu điểm:**\n- ✅ **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- ✅ **Predictable:** Luôn O(n log n) cho mọi trường hợp\n- ✅ **Parallelizable:** Có thể song song hóa dễ dàng\n- ✅ **External sorting:** Thích hợp cho sắp xếp dữ liệu lớn không fit trong RAM\n\n**Nhược điểm:**\n- ❌ **Space:** Cần O(n) bộ nhớ phụ\n- ❌ **Not in-place:** (Phiên bản chuẩn)\n- ❌ **Overhead:** Chi phí đệ quy và copy dữ liệu\n\n---\n\n### 4. Các biến thể và tối ưu hóa\n\n#### 4.1. Natural Merge Sort\n\nTận dụng các phần đã sắp xếp tự nhiên trong mảng.\n\n```python\ndef natural_merge_sort(arr):\n    \"\"\"\n    Tận dụng các dãy con đã được sắp xếp sẵn\n    \"\"\"\n    n = len(arr)\n    \n    def get_runs():\n        \"\"\"Tìm các dãy con đã sắp xếp\"\"\"\n        runs = []\n        i = 0\n        \n        while i < n:\n            start = i\n            # Tìm dãy tăng dần\n            while i < n - 1 and arr[i] <= arr[i + 1]:\n                i += 1\n            runs.append((start, i))\n            i += 1\n        \n        return runs\n    \n    while True:\n        runs = get_runs()\n        if len(runs) <= 1:\n            break\n        \n        # Gộp các runs liên tiếp\n        new_runs = []\n        for i in range(0, len(runs), 2):\n            if i + 1 < len(runs):\n                left_start, left_end = runs[i]\n                right_start, right_end = runs[i + 1]\n                merge_inplace(arr, left_start, left_end, right_end)\n                new_runs.append((left_start, right_end))\n            else:\n                new_runs.append(runs[i])\n    \n    return arr\n```\n\n#### 4.2. Bottom-up Merge Sort\n\n```python\ndef bottom_up_merge_sort(arr):\n    \"\"\"\n    Merge sort không dùng đệ quy, gộp từ dưới lên\n    \"\"\"\n    n = len(arr)\n    width = 1\n    \n    while width < n:\n        left = 0\n        while left < n:\n            mid = min(left + width - 1, n - 1)\n            right = min(left + 2 * width - 1, n - 1)\n            \n            if mid < right:\n                merge_inplace(arr, left, mid, right)\n            \n            left += 2 * width\n        \n        width *= 2\n    \n    return arr\n```\n\n#### 4.3. Hybrid Merge Sort (Tim Sort inspired)\n\nKết hợp với Insertion Sort cho các mảng con nhỏ.\n\n\n**Các khái niệm quan trọng:**\n- Merge Sort (hoặc Mergesort) là một thuật toán sắp xếp hiệu quả dựa trên kỹ thuật chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chia mảng thành hai nửa, sắp xếp đệ quy từng nửa, sau đó trộn (gộp) hai nửa đã sắp xếp lại với nhau. Merge Sort là một thuật toán sắp xếp ổn định (stable) và có độ phức tạp thời gian O(n log n) trong mọi trường hợp (best, average, worst case). Độ phức tạp không gian của nó là O(n) do cần không gian phụ (mảng tạm) để thực hiện quá trình trộn. Merge Sort có thể được cài đặt bằng đệ quy hoặc lặp, thích hợp cho việc sắp xếp dữ liệu lớn không vừa trong RAM (external sorting), có thể song song hóa, và hiệu quả khi sắp xếp các cấu trúc dữ liệu như linked list. Ngoài ra, Mergesort có thể được sửa đổi để đếm số lần đảo ngược trong một mảng, với một hàm phụ trợ `merge_count` có độ phức tạp O(k) để đếm đảo ngược khi trộn hai mảng con.\n\n**Mối quan hệ:**\n- Mergesort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các mảng con, sắp xếp chúng đệ quy, và sau đó gộp các mảng con đã sắp xếp lại.\n- Mergesort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các nửa, sắp xếp đệ quy, và sau đó gộp lại.\n- Mergesort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các mảng con, sắp xếp đệ quy chúng, và sau đó gộp các kết quả lại.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n    Segment(15, 18)\n]\nresult = merge_intervals(segments)\nprint(\"Các đoạn sau khi gộp:\", result)\n```\n\n#### 5.4. K-way Merge\n\n```python\nimport heapq\n\ndef k_way_merge(lists):\n    \"\"\"\n    Gộp k danh sách đã sắp xếp thành 1 danh sách\n    Ứng dụng: Merge output từ nhiều sorted files\n    \"\"\"\n    heap = []\n    result = []\n    \n    # Thêm phần tử đầu tiên của mỗi list vào heap\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    \n    # Extract min và thêm phần tử tiếp theo\n    while heap:\n        value, list_idx, element_idx = heapq.heappop(heap)\n        result.append(value)\n        \n        # Thêm phần tử tiếp theo từ cùng list\n        if element_idx + 1 < len(lists[list_idx]):\n            next_value = lists[list_idx][element_idx + 1]\n            heapq.heappush(heap, (next_value, list_idx, element_idx + 1))\n    \n    return result\n\n# Test\nlists = [\n    [1, 4, 7],\n    [2, 5, 8],\n    [3, 6, 9]\n]\nprint(\"K-way merge:\", k_way_merge(lists))\n```\n\n---\n\n### 6. So sánh với các thuật toán khác\n\n| Thuật toán | Best | Average | Worst | Space | Stable | In-place |\n|------------|------|---------|-------|-------|--------|----------|\n| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ | ❌ |\n| Quick Sort | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ | ✅ |\n| Heap Sort | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ | ✅ |\n| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) | ✅ | ✅ |\n\n#### 6.1. Khi nào sử dụng Merge Sort?\n\n**Nên sử dụng khi:**\n- ✅ Cần thuật toán stable\n- ✅ Cần độ phức tạp guaranteed O(n log n)\n- ✅ Sắp xếp linked list (không cần bộ nhớ phụ)\n- ✅ External sorting (dữ liệu không fit trong RAM)\n- ✅ Parallel/distributed sorting\n- ✅ Counting inversions\n- ✅ Dữ liệu đến dần dần (online)\n\n**Không nên sử dụng khi:**\n- ❌ Bộ nhớ bị hạn chế nghiêm ngặt\n- ❌ Cần in-place sorting\n- ❌ Mảng nhỏ (overhead đệ quy cao)\n\n---\n\n### 7. Merge Sort cho Linked List\n\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge_sort_linked_list(head):\n    \"\"\"\n    Merge sort cho linked list - O(1) space!\n    \"\"\"\n    if not head or not head.next:\n        return head\n    \n    # Tìm điểm giữa\n    slow = fast = head\n    prev = None\n    \n    while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Chia list thành 2 phần\n    prev.next = None\n    \n    # Sắp xếp đệ quy\n    left = merge_sort_linked_list(head)\n    right = merge_sort_linked_list(slow)\n    \n    # Merge\n    return merge_linked_lists(left, right)\n\ndef merge_linked_lists(l1, l2):\n    \"\"\"\n    Gộp 2 linked lists đã sắp xếp\n    \"\"\"\n    dummy = ListNode(0)\n    current = dummy\n    \n    while l1 and l2:\n        if l1.val <= l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n\n**Các khái niệm quan trọng:**\n- Merge Sort (hoặc Mergesort) là một thuật toán sắp xếp hiệu quả dựa trên kỹ thuật chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chia mảng thành hai nửa, sắp xếp đệ quy từng nửa, sau đó trộn (gộp) hai nửa đã sắp xếp lại với nhau. Merge Sort là một thuật toán sắp xếp ổn định (stable) và có độ phức tạp thời gian O(n log n) trong mọi trường hợp (best, average, worst case). Độ phức tạp không gian của nó là O(n) do cần không gian phụ (mảng tạm) để thực hiện quá trình trộn. Merge Sort có thể được cài đặt bằng đệ quy hoặc lặp, thích hợp cho việc sắp xếp dữ liệu lớn không vừa trong RAM (external sorting), có thể song song hóa, và hiệu quả khi sắp xếp các cấu trúc dữ liệu như linked list. Ngoài ra, Mergesort có thể được sửa đổi để đếm số lần đảo ngược trong một mảng, với một hàm phụ trợ `merge_count` có độ phức tạp O(k) để đếm đảo ngược khi trộn hai mảng con.\n\n**Mối quan hệ:**\n- Mergesort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các nửa, sắp xếp đệ quy, và sau đó gộp lại.\n- Mergesort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các mảng con, sắp xếp đệ quy chúng, và sau đó gộp các kết quả lại.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n        # Gộp 2 nửa\n        merge_inplace(arr, left, mid, right)\n\ndef merge_inplace(arr, left, mid, right):\n    \"\"\"\n    Gộp 2 phần đã sắp xếp trong mảng\n    \"\"\"\n    # Tạo mảng tạm\n    left_arr = arr[left:mid + 1]\n    right_arr = arr[mid + 1:right + 1]\n    \n    i = j = 0\n    k = left\n    \n    # Gộp vào mảng gốc\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n    \n    # Copy phần tử còn lại\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    \n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nmerge_sort_inplace(arr, 0, len(arr) - 1)\nprint(\"Mảng sau khi sắp xếp:\", arr)\n```\n\n#### 2.3. Cài đặt với iteration (không đệ quy)\n\n```python\ndef merge_sort_iterative(arr):\n    \"\"\"\n    Merge Sort sử dụng vòng lặp thay vì đệ quy\n    \"\"\"\n    n = len(arr)\n    current_size = 1\n    \n    # Bắt đầu với kích thước 1, tăng gấp đôi mỗi lần\n    while current_size < n:\n        left = 0\n        \n        while left < n - 1:\n            # Tìm điểm giữa và điểm cuối\n            mid = min(left + current_size - 1, n - 1)\n            right = min(left + 2 * current_size - 1, n - 1)\n            \n            # Gộp các phần con\n            merge_inplace(arr, left, mid, right)\n            \n            # Di chuyển đến phần con tiếp theo\n            left += 2 * current_size\n        \n        # Tăng kích thước gấp đôi\n        current_size *= 2\n    \n    return arr\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Mảng sau khi sắp xếp:\", merge_sort_iterative(arr))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Phân tích bằng Master Theorem:**\n- Công thức đệ quy: T(n) = 2T(n/2) + O(n)\n- Trong đó:\n  - 2T(n/2): Chi phí sắp xếp 2 nửa\n  - O(n): Chi phí gộp\n\n**Độ cao cây đệ quy:** log₂(n)\n**Chi phí mỗi tầng:** O(n)\n**Tổng chi phí:** O(n log n)\n\n**Kết quả:**\n- **Best case:** O(n log n)\n- **Average case:** O(n log n)\n- **Worst case:** O(n log n)\n\n**Đặc điểm độ phức tạp:**\n- Luôn là O(n log n), không phụ thuộc vào dữ liệu đầu vào\n- Tốt hơn các thuật toán O(n²)\n- Là thuật toán optimal cho comparison-based sorting trong worst case\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:** O(n)\n- Cần thêm bộ nhớ để lưu các mảng tạm trong quá trình merge\n- Với đệ quy: O(n) cho mảng tạm + O(log n) cho stack\n- Tổng: O(n)\n\n**Cải thiện bộ nhớ:**\n\n**Các khái niệm quan trọng:**\n- Merge Sort (hoặc Mergesort) là một thuật toán sắp xếp hiệu quả dựa trên kỹ thuật chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chia mảng thành hai nửa, sắp xếp đệ quy từng nửa, sau đó trộn (gộp) hai nửa đã sắp xếp lại với nhau. Merge Sort là một thuật toán sắp xếp ổn định (stable) và có độ phức tạp thời gian O(n log n) trong mọi trường hợp (best, average, worst case). Độ phức tạp không gian của nó là O(n) do cần không gian phụ (mảng tạm) để thực hiện quá trình trộn. Merge Sort có thể được cài đặt bằng đệ quy hoặc lặp, thích hợp cho việc sắp xếp dữ liệu lớn không vừa trong RAM (external sorting), có thể song song hóa, và hiệu quả khi sắp xếp các cấu trúc dữ liệu như linked list. Ngoài ra, Mergesort có thể được sửa đổi để đếm số lần đảo ngược trong một mảng, với một hàm phụ trợ `merge_count` có độ phức tạp O(k) để đếm đảo ngược khi trộn hai mảng con.\n\n**Mối quan hệ:**\n- Mergesort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các mảng con, sắp xếp chúng đệ quy, và sau đó gộp các mảng con đã sắp xếp lại.\n- Mergesort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các nửa, sắp xếp đệ quy, và sau đó gộp lại.\n- Mergesort áp dụng kỹ thuật Divide and Conquer bằng cách chia mảng thành các mảng con, sắp xếp đệ quy chúng, và sau đó gộp các kết quả lại."
        },
        "output_without_context": {
            "question": "Mergesort là một thuật toán sắp xếp hoạt động theo nguyên tắc nào?",
            "answer": "Chia để trị."
        }
    },
    {
        "topic_description": "Chủ đề này kiểm tra khả năng áp dụng thuật toán Mergesort thông qua mã nguồn Java. Học sinh sẽ phải hiểu cấu trúc lệnh trong Java để triển khai Mergesort, bao gồm cách gọi đệ quy và sử dụng phương thức merge. Các câu hỏi có thể về cách viết mã và cách mà mã hoạt động.",
        "output_with_context": {
            "question": "Trong thuật toán Mergesort, phương thức nào được sử dụng để gộp hai mảng đã sắp xếp thành một mảng duy nhất cũng đã được sắp xếp?",
            "answer": "merge",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n    # Bước 2: Merge các file tạm sử dụng heap\n    with open(output_file, 'w') as outf:\n        # Mở tất cả file tạm\n        files = [open(f, 'r') for f in temp_files]\n        \n        # Heap chứa (giá trị, index file)\n        heap = []\n        for i, f in enumerate(files):\n            line = f.readline()\n            if line:\n                heapq.heappush(heap, (int(line.strip()), i))\n        \n        # Merge\n        while heap:\n            value, file_idx = heapq.heappop(heap)\n            outf.write(f\"{value}\n\")\n            \n            # Đọc phần tử tiếp theo từ file\n            line = files[file_idx].readline()\n            if line:\n                heapq.heappush(heap, (int(line.strip()), file_idx))\n        \n        # Đóng các file\n        for f in files:\n            f.close()\n    \n    # Xóa file tạm\n    for temp_file in temp_files:\n        os.remove(temp_file)\n```\n\n#### 5.2. Đếm số lần đảo ngược (Inversion Count)\n\n```python\ndef count_inversions(arr):\n    \"\"\"\n    Đếm số cặp (i, j) mà i < j nhưng arr[i] > arr[j]\n    Sử dụng merge sort: O(n log n)\n    \"\"\"\n    def merge_count(arr, temp, left, mid, right):\n        i = left    # Index cho mảng trái\n        j = mid + 1 # Index cho mảng phải\n        k = left    # Index cho mảng kết quả\n        inv_count = 0\n        \n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                i += 1\n            else:\n                temp[k] = arr[j]\n                # Tất cả phần tử từ i đến mid đều lớn hơn arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy phần tử còn lại\n        while i <= mid:\n            temp[k] = arr[i]\n            i += 1\n            k += 1\n        \n        while j <= right:\n            temp[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy từ temp về arr\n        for i in range(left, right + 1):\n            arr[i] = temp[i]\n        \n        return inv_count\n    \n    def merge_sort_count(arr, temp, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            inv_count += merge_sort_count(arr, temp, left, mid)\n            inv_count += merge_sort_count(arr, temp, mid + 1, right)\n            inv_count += merge_count(arr, temp, left, mid, right)\n        \n        return inv_count\n    \n    n = len(arr)\n    temp = [0] * n\n    return merge_sort_count(arr, temp, 0, n - 1)\n\n# Test\narr = [8, 4, 2, 1]\nprint(f\"Số lần đảo ngược: {count_inversions(arr.copy())}\")  # 6\n```\n\n#### 5.3. Tìm điểm giao nhau của các đoạn thẳng\n\n```python\nclass Segment:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n    \n    def __repr__(self):\n        return f\"[{self.start}, {self.end}]\"\n\ndef merge_intervals(intervals):\n    \"\"\"\n    Gộp các đoạn giao nhau\n    \"\"\"\n    if not intervals:\n        return []\n    \n    # Sắp xếp theo điểm bắt đầu\n    intervals.sort(key=lambda x: x.start)\n    \n    merged = [intervals[0]]\n    \n    for current in intervals[1:]:\n        last = merged[-1]\n        \n        if current.start <= last.end:\n            # Gộp đoạn\n            last.end = max(last.end, current.end)\n        else:\n            merged.append(current)\n    \n    return merged\n\n# Test\nsegments = [\n    Segment(1, 3),\n    Segment(2, 6),\n    Segment(8, 10),\n\n**Các khái niệm quan trọng:**\n- Merge Sort (hoặc Mergesort) là một thuật toán sắp xếp hiệu quả dựa trên kỹ thuật chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chia mảng thành hai nửa, sắp xếp đệ quy từng nửa, sau đó trộn (gộp) hai nửa đã sắp xếp lại với nhau. Merge Sort là một thuật toán sắp xếp ổn định (stable) và có độ phức tạp thời gian O(n log n) trong mọi trường hợp (best, average, worst case). Độ phức tạp không gian của nó là O(n) do cần không gian phụ (mảng tạm) để thực hiện quá trình trộn. Merge Sort có thể được cài đặt bằng đệ quy hoặc lặp, thích hợp cho việc sắp xếp dữ liệu lớn không vừa trong RAM (external sorting), có thể song song hóa, và hiệu quả khi sắp xếp các cấu trúc dữ liệu như linked list. Ngoài ra, Mergesort có thể được sửa đổi để đếm số lần đảo ngược trong một mảng, với một hàm phụ trợ `merge_count` có độ phức tạp O(k) để đếm đảo ngược khi trộn hai mảng con.\n- Sắp xếp là quá trình sắp xếp các phần tử của một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một phép toán cơ bản trong khoa học máy tính. Mergesort là một thuật toán sắp xếp.\n\n**Mối quan hệ:**\n- merge_sort_count sử dụng hàm merge_count để đếm số lần đảo ngược giữa hai nửa mảng và trộn chúng.\n- Mergesort giải quyết bài toán Sắp xếp các phần tử trong một mảng.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n        # Gộp 2 nửa\n        merge_inplace(arr, left, mid, right)\n\ndef merge_inplace(arr, left, mid, right):\n    \"\"\"\n    Gộp 2 phần đã sắp xếp trong mảng\n    \"\"\"\n    # Tạo mảng tạm\n    left_arr = arr[left:mid + 1]\n    right_arr = arr[mid + 1:right + 1]\n    \n    i = j = 0\n    k = left\n    \n    # Gộp vào mảng gốc\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n    \n    # Copy phần tử còn lại\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    \n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nmerge_sort_inplace(arr, 0, len(arr) - 1)\nprint(\"Mảng sau khi sắp xếp:\", arr)\n```\n\n#### 2.3. Cài đặt với iteration (không đệ quy)\n\n```python\ndef merge_sort_iterative(arr):\n    \"\"\"\n    Merge Sort sử dụng vòng lặp thay vì đệ quy\n    \"\"\"\n    n = len(arr)\n    current_size = 1\n    \n    # Bắt đầu với kích thước 1, tăng gấp đôi mỗi lần\n    while current_size < n:\n        left = 0\n        \n        while left < n - 1:\n            # Tìm điểm giữa và điểm cuối\n            mid = min(left + current_size - 1, n - 1)\n            right = min(left + 2 * current_size - 1, n - 1)\n            \n            # Gộp các phần con\n            merge_inplace(arr, left, mid, right)\n            \n            # Di chuyển đến phần con tiếp theo\n            left += 2 * current_size\n        \n        # Tăng kích thước gấp đôi\n        current_size *= 2\n    \n    return arr\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Mảng sau khi sắp xếp:\", merge_sort_iterative(arr))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Phân tích bằng Master Theorem:**\n- Công thức đệ quy: T(n) = 2T(n/2) + O(n)\n- Trong đó:\n  - 2T(n/2): Chi phí sắp xếp 2 nửa\n  - O(n): Chi phí gộp\n\n**Độ cao cây đệ quy:** log₂(n)\n**Chi phí mỗi tầng:** O(n)\n**Tổng chi phí:** O(n log n)\n\n**Kết quả:**\n- **Best case:** O(n log n)\n- **Average case:** O(n log n)\n- **Worst case:** O(n log n)\n\n**Đặc điểm độ phức tạp:**\n- Luôn là O(n log n), không phụ thuộc vào dữ liệu đầu vào\n- Tốt hơn các thuật toán O(n²)\n- Là thuật toán optimal cho comparison-based sorting trong worst case\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:** O(n)\n- Cần thêm bộ nhớ để lưu các mảng tạm trong quá trình merge\n- Với đệ quy: O(n) cho mảng tạm + O(log n) cho stack\n- Tổng: O(n)\n\n**Cải thiện bộ nhớ:**\n\n**Các khái niệm quan trọng:**\n- Comparison-based sorting là một loại bài toán sắp xếp mà các thuật toán chỉ có thể truy cập các phần tử thông qua phép so sánh giữa chúng. Mergesort là một thuật toán sắp xếp dựa trên so sánh và được coi là tối ưu trong worst case với độ phức tạp O(n log n).\n- Average case là trường hợp đầu vào trung bình cho một thuật toán, thường được sử dụng để đánh giá hiệu suất thực tế. Đối với Mergesort, average case vẫn là O(n log n).\n- merge_sort_iterative là một cài đặt của thuật toán Mergesort sử dụng vòng lặp (iteration) thay vì đệ quy. Nó bắt đầu với việc gộp các mảng con có kích thước 1, sau đó tăng gấp đôi kích thước mảng con cần gộp trong mỗi lần lặp cho đến khi toàn bộ mảng được sắp xếp. Kỹ thuật này giúp tránh chi phí stack call của đệ quy nhưng vẫn giữ được độ phức tạp thời gian O(n log n).\n\n**Mối quan hệ:**\n- merge_sort_iterative có độ phức tạp không gian O(n) do việc tạo mảng tạm trong merge_inplace.\n- merge_sort_iterative có độ phức tạp thời gian O(n log n).\n- Mergesort giải quyết bài toán Comparison-based sorting một cách hiệu quả.\n- merge_sort_iterative sử dụng hàm merge_inplace để thực hiện các bước gộp trong quá trình lặp.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n---\n\n## Mergesort\n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\nMerge Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật **Chia để trị (Divide and Conquer)**. Thuật toán chia mảng thành các phần nhỏ hơn, sắp xếp chúng, sau đó gộp (merge) các phần đã sắp xếp lại với nhau.\n\n**Nguyên lý Divide and Conquer:**\n1. **Divide (Chia):** Chia bài toán thành các bài toán con nhỏ hơn\n2. **Conquer (Chinh phục):** Giải quyết các bài toán con (đệ quy)\n3. **Combine (Kết hợp):** Gộp các lời giải của bài toán con\n\n#### 1.2. Ý tưởng chính\n\n```\nMảng: [38, 27, 43, 3, 9, 82, 10]\n\nBước 1 - Chia:\n[38, 27, 43, 3] | [9, 82, 10]\n\nBước 2 - Chia tiếp:\n[38, 27] | [43, 3] | [9, 82] | [10]\n\nBước 3 - Chia đến mức cơ sở:\n[38] | [27] | [43] | [3] | [9] | [82] | [10]\n\nBước 4 - Gộp:\n[27, 38] | [3, 43] | [9, 82] | [10]\n\nBước 5 - Gộp tiếp:\n[3, 27, 38, 43] | [9, 10, 82]\n\nBước 6 - Gộp cuối:\n[3, 9, 10, 27, 38, 43, 82]\n```\n\n---\n\n### 2. Thuật toán Merge Sort\n\n#### 2.1. Cài đặt cơ bản\n\n```python\ndef merge_sort(arr):\n    \"\"\"\n    Sắp xếp mảng sử dụng Merge Sort\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    # Chia mảng thành 2 nửa\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Đệ quy sắp xếp 2 nửa\n    left = merge_sort(left)\n    right = merge_sort(right)\n    \n    # Gộp 2 nửa đã sắp xếp\n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    Gộp 2 mảng đã sắp xếp thành 1 mảng sắp xếp\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # So sánh từng phần tử và thêm phần tử nhỏ hơn vào result\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # Thêm các phần tử còn lại (nếu có)\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", merge_sort(arr))\n```\n\n#### 2.2. Cài đặt In-place (tối ưu bộ nhớ)\n\n```python\ndef merge_sort_inplace(arr, left, right):\n    \"\"\"\n    Merge Sort in-place để tiết kiệm bộ nhớ\n    \"\"\"\n    if left < right:\n        mid = (left + right) // 2\n        \n        # Sắp xếp 2 nửa\n        merge_sort_inplace(arr, left, mid)\n        merge_sort_inplace(arr, mid + 1, right)\n        \n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n- Merge là một phép toán cốt lõi trong thuật toán Mergesort, có nhiệm vụ kết hợp hai danh sách (hoặc mảng) con đã được sắp xếp thành một danh sách (hoặc mảng) duy nhất cũng đã được sắp xếp. Quá trình này hoạt động bằng cách so sánh từng phần tử từ hai danh sách con và thêm phần tử nhỏ hơn vào danh sách kết quả cho đến khi một trong hai danh sách con cạn kiệt, sau đó thêm các phần tử còn lại của danh sách kia vào. Phép toán merge có độ phức tạp thời gian là O(n), trong đó n là tổng số phần tử của hai danh sách con.\n\n**Mối quan hệ:**\n- Phép toán merge trong Merge Sort có độ phức tạp thời gian O(n), với n là tổng số phần tử của hai mảng con cần gộp.\n- Phép toán merge có độ phức tạp thời gian O(n) với n là tổng số phần tử của hai danh sách con."
        },
        "output_without_context": {
            "question": "Trong thuật toán Mergesort, phương thức nào được sử dụng để kết hợp hai mảng đã được sắp xếp thành một mảng duy nhất?",
            "answer": "Phương thức merge"
        }
    },
    {
        "topic_description": "Chủ đề này yêu cầu học sinh so sánh Mergesort với các thuật toán sắp xếp khác như sắp xếp chèn và sắp xếp chọn. Sinh viên sẽ phải phân tích và đánh giá độ phức tạp của Mergesort trong bối cảnh hiệu suất và không gian bộ nhớ so với các thuật toán khác. Câu hỏi sẽ kiểm tra khả năng phân tích của học sinh và nhận thức về các ưu điểm và nhược điểm của từng thuật toán.",
        "output_with_context": {
            "question": "So với các thuật toán sắp xếp khác như sắp xếp chèn và sắp xếp chọn, Mergesort có độ phức tạp thời gian là bao nhiêu trong trường hợp xấu nhất?",
            "answer": "O(n log n)",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n        # Gộp 2 nửa\n        merge_inplace(arr, left, mid, right)\n\ndef merge_inplace(arr, left, mid, right):\n    \"\"\"\n    Gộp 2 phần đã sắp xếp trong mảng\n    \"\"\"\n    # Tạo mảng tạm\n    left_arr = arr[left:mid + 1]\n    right_arr = arr[mid + 1:right + 1]\n    \n    i = j = 0\n    k = left\n    \n    # Gộp vào mảng gốc\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n    \n    # Copy phần tử còn lại\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    \n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nmerge_sort_inplace(arr, 0, len(arr) - 1)\nprint(\"Mảng sau khi sắp xếp:\", arr)\n```\n\n#### 2.3. Cài đặt với iteration (không đệ quy)\n\n```python\ndef merge_sort_iterative(arr):\n    \"\"\"\n    Merge Sort sử dụng vòng lặp thay vì đệ quy\n    \"\"\"\n    n = len(arr)\n    current_size = 1\n    \n    # Bắt đầu với kích thước 1, tăng gấp đôi mỗi lần\n    while current_size < n:\n        left = 0\n        \n        while left < n - 1:\n            # Tìm điểm giữa và điểm cuối\n            mid = min(left + current_size - 1, n - 1)\n            right = min(left + 2 * current_size - 1, n - 1)\n            \n            # Gộp các phần con\n            merge_inplace(arr, left, mid, right)\n            \n            # Di chuyển đến phần con tiếp theo\n            left += 2 * current_size\n        \n        # Tăng kích thước gấp đôi\n        current_size *= 2\n    \n    return arr\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Mảng sau khi sắp xếp:\", merge_sort_iterative(arr))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Phân tích bằng Master Theorem:**\n- Công thức đệ quy: T(n) = 2T(n/2) + O(n)\n- Trong đó:\n  - 2T(n/2): Chi phí sắp xếp 2 nửa\n  - O(n): Chi phí gộp\n\n**Độ cao cây đệ quy:** log₂(n)\n**Chi phí mỗi tầng:** O(n)\n**Tổng chi phí:** O(n log n)\n\n**Kết quả:**\n- **Best case:** O(n log n)\n- **Average case:** O(n log n)\n- **Worst case:** O(n log n)\n\n**Đặc điểm độ phức tạp:**\n- Luôn là O(n log n), không phụ thuộc vào dữ liệu đầu vào\n- Tốt hơn các thuật toán O(n²)\n- Là thuật toán optimal cho comparison-based sorting trong worst case\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:** O(n)\n- Cần thêm bộ nhớ để lưu các mảng tạm trong quá trình merge\n- Với đệ quy: O(n) cho mảng tạm + O(log n) cho stack\n- Tổng: O(n)\n\n**Cải thiện bộ nhớ:**\n\n**Các khái niệm quan trọng:**\n- Space Complexity là một tính chất của thuật toán, đo lường lượng bộ nhớ mà thuật toán sử dụng trong quá trình thực thi. Đối với Mergesort, độ phức tạp không gian là O(n) do cần mảng tạm để gộp.\n- Comparison-based sorting là một loại bài toán sắp xếp mà các thuật toán chỉ có thể truy cập các phần tử thông qua phép so sánh giữa chúng. Mergesort là một thuật toán sắp xếp dựa trên so sánh và được coi là tối ưu trong worst case với độ phức tạp O(n log n).\n\n**Mối quan hệ:**\n- Mergesort giải quyết bài toán Comparison-based sorting một cách hiệu quả.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n---\n\n## Mergesort\n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\nMerge Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật **Chia để trị (Divide and Conquer)**. Thuật toán chia mảng thành các phần nhỏ hơn, sắp xếp chúng, sau đó gộp (merge) các phần đã sắp xếp lại với nhau.\n\n**Nguyên lý Divide and Conquer:**\n1. **Divide (Chia):** Chia bài toán thành các bài toán con nhỏ hơn\n2. **Conquer (Chinh phục):** Giải quyết các bài toán con (đệ quy)\n3. **Combine (Kết hợp):** Gộp các lời giải của bài toán con\n\n#### 1.2. Ý tưởng chính\n\n```\nMảng: [38, 27, 43, 3, 9, 82, 10]\n\nBước 1 - Chia:\n[38, 27, 43, 3] | [9, 82, 10]\n\nBước 2 - Chia tiếp:\n[38, 27] | [43, 3] | [9, 82] | [10]\n\nBước 3 - Chia đến mức cơ sở:\n[38] | [27] | [43] | [3] | [9] | [82] | [10]\n\nBước 4 - Gộp:\n[27, 38] | [3, 43] | [9, 82] | [10]\n\nBước 5 - Gộp tiếp:\n[3, 27, 38, 43] | [9, 10, 82]\n\nBước 6 - Gộp cuối:\n[3, 9, 10, 27, 38, 43, 82]\n```\n\n---\n\n### 2. Thuật toán Merge Sort\n\n#### 2.1. Cài đặt cơ bản\n\n```python\ndef merge_sort(arr):\n    \"\"\"\n    Sắp xếp mảng sử dụng Merge Sort\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    # Chia mảng thành 2 nửa\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Đệ quy sắp xếp 2 nửa\n    left = merge_sort(left)\n    right = merge_sort(right)\n    \n    # Gộp 2 nửa đã sắp xếp\n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    Gộp 2 mảng đã sắp xếp thành 1 mảng sắp xếp\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # So sánh từng phần tử và thêm phần tử nhỏ hơn vào result\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # Thêm các phần tử còn lại (nếu có)\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", merge_sort(arr))\n```\n\n#### 2.2. Cài đặt In-place (tối ưu bộ nhớ)\n\n```python\ndef merge_sort_inplace(arr, left, right):\n    \"\"\"\n    Merge Sort in-place để tiết kiệm bộ nhớ\n    \"\"\"\n    if left < right:\n        mid = (left + right) // 2\n        \n        # Sắp xếp 2 nửa\n        merge_sort_inplace(arr, left, mid)\n        merge_sort_inplace(arr, mid + 1, right)\n        \n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n- Merge là một phép toán cốt lõi trong thuật toán Mergesort, có nhiệm vụ kết hợp hai danh sách (hoặc mảng) con đã được sắp xếp thành một danh sách (hoặc mảng) duy nhất cũng đã được sắp xếp. Quá trình này hoạt động bằng cách so sánh từng phần tử từ hai danh sách con và thêm phần tử nhỏ hơn vào danh sách kết quả cho đến khi một trong hai danh sách con cạn kiệt, sau đó thêm các phần tử còn lại của danh sách kia vào. Phép toán merge có độ phức tạp thời gian là O(n), trong đó n là tổng số phần tử của hai danh sách con.\n\n**Mối quan hệ:**\n- Phép toán merge trong Merge Sort có độ phức tạp thời gian O(n), với n là tổng số phần tử của hai mảng con cần gộp.\n- Phép toán merge có độ phức tạp thời gian O(n) với n là tổng số phần tử của hai danh sách con.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n**Ưu điểm:**\n- Đơn giản, dễ cài đặt\n- Hiệu quả với mảng nhỏ hoặc gần như đã sắp xếp\n- Stable và adaptive\n- Online - có thể sắp xếp dữ liệu đến dần dần\n- Ít hoán đổi hơn Bubble Sort\n\n**Nhược điểm:**\n- Không hiệu quả với dữ liệu lớn và ngẫu nhiên\n\n#### 4.5. Tối ưu hóa: Binary Insertion Sort\n\n```python\ndef binary_search(arr, item, start, end):\n    \"\"\"Tìm vị trí chèn bằng Binary Search\"\"\"\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] < item:\n            start = mid + 1\n        elif arr[mid] > item:\n            end = mid - 1\n        else:\n            return mid + 1\n    return start\n\ndef binary_insertion_sort(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        key = arr[i]\n        # Tìm vị trí chèn bằng Binary Search\n        pos = binary_search(arr, key, 0, i - 1)\n        \n        # Dịch chuyển các phần tử\n        arr = arr[:pos] + [key] + arr[pos:i] + arr[i+1:]\n    \n    return arr\n```\n\nGiảm số lần so sánh từ O(n²) xuống O(n log n), nhưng số lần dịch chuyển vẫn là O(n²).\n\n---\n\n### 5. So sánh các thuật toán cơ bản\n\n| Thuật toán | Best | Average | Worst | Space | Stable | Adaptive |\n|------------|------|---------|-------|-------|--------|----------|\n| Bubble Sort | O(n) | O(n²) | O(n²) | O(1) | ✅ | ✅ |\n| Selection Sort | O(n²) | O(n²) | O(n²) | O(1) | ❌ | ❌ |\n| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) | ✅ | ✅ |\n\n#### 5.1. Khi nào sử dụng?\n\n**Bubble Sort:**\n- Mảng nhỏ và gần như đã sắp xếp\n- Mục đích giáo dục\n- Khi cần thuật toán đơn giản nhất\n\n**Selection Sort:**\n- Khi chi phí hoán đổi cao (ít hoán đổi nhất)\n- Mảng nhỏ\n- Khi bộ nhớ phụ bị hạn chế\n\n**Insertion Sort:**\n- Mảng nhỏ (< 50 phần tử)\n- Mảng gần như đã sắp xếp\n- Dữ liệu đến theo thời gian thực (online)\n- Kết hợp với Merge Sort hoặc Quick Sort cho mảng con nhỏ\n\n#### 5.2. Code so sánh hiệu năng\n\n```python\nimport time\nimport random\n\ndef compare_sorting_algorithms(size=1000):\n    # Tạo mảng ngẫu nhiên\n    arr = [random.randint(1, 1000) for _ in range(size)]\n    \n    algorithms = {\n        'Bubble Sort': bubble_sort,\n        'Selection Sort': selection_sort,\n        'Insertion Sort': insertion_sort\n    }\n    \n    results = {}\n    \n    for name, func in algorithms.items():\n        test_arr = arr.copy()\n        start_time = time.time()\n        func(test_arr)\n        end_time = time.time()\n        results[name] = end_time - start_time\n    \n    # In kết quả\n    print(f\"\nThời gian thực thi với mảng {size} phần tử:\")\n    for name, exec_time in sorted(results.items(), key=lambda x: x[1]):\n        print(f\"{name:20s}: {exec_time:.6f} giây\")\n\n# Test với các kích thước khác nhau\n\n**Các khái niệm quan trọng:**\n- So sánh là một phép toán cơ bản trong các thuật toán sắp xếp dựa trên so sánh, dùng để xác định mối quan hệ thứ tự giữa hai phần tử. Số lần so sánh là một yếu tố quan trọng ảnh hưởng đến độ phức tạp thời gian của thuật toán."
        },
        "output_without_context": {
            "question": "So với thuật toán sắp xếp chèn và sắp xếp chọn, Mergesort có độ phức tạp thời gian trung bình là bao nhiêu?",
            "answer": "O(n log n)"
        }
    },
    {
        "topic_description": "Chủ đề này tập trung vào quy trình hợp nhất hai mảng con đã sắp xếp trong thuật toán Mergesort. Học sinh sẽ phải hiểu cách thức hợp nhất và kiểm tra khả năng áp dụng những hiểu biết này vào các tình huống cụ thể. Câu hỏi có thể yêu cầu sinh viên mô tả quá trình hoặc viết đoạn mã thực hiện.",
        "output_with_context": {
            "question": "Trong thuật toán Mergesort, quá trình nào được thực hiện để kết hợp hai mảng con đã sắp xếp thành một mảng duy nhất cũng đã được sắp xếp?",
            "answer": "Gộp (Merge)",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n    # Bước 2: Merge các file tạm sử dụng heap\n    with open(output_file, 'w') as outf:\n        # Mở tất cả file tạm\n        files = [open(f, 'r') for f in temp_files]\n        \n        # Heap chứa (giá trị, index file)\n        heap = []\n        for i, f in enumerate(files):\n            line = f.readline()\n            if line:\n                heapq.heappush(heap, (int(line.strip()), i))\n        \n        # Merge\n        while heap:\n            value, file_idx = heapq.heappop(heap)\n            outf.write(f\"{value}\n\")\n            \n            # Đọc phần tử tiếp theo từ file\n            line = files[file_idx].readline()\n            if line:\n                heapq.heappush(heap, (int(line.strip()), file_idx))\n        \n        # Đóng các file\n        for f in files:\n            f.close()\n    \n    # Xóa file tạm\n    for temp_file in temp_files:\n        os.remove(temp_file)\n```\n\n#### 5.2. Đếm số lần đảo ngược (Inversion Count)\n\n```python\ndef count_inversions(arr):\n    \"\"\"\n    Đếm số cặp (i, j) mà i < j nhưng arr[i] > arr[j]\n    Sử dụng merge sort: O(n log n)\n    \"\"\"\n    def merge_count(arr, temp, left, mid, right):\n        i = left    # Index cho mảng trái\n        j = mid + 1 # Index cho mảng phải\n        k = left    # Index cho mảng kết quả\n        inv_count = 0\n        \n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                i += 1\n            else:\n                temp[k] = arr[j]\n                # Tất cả phần tử từ i đến mid đều lớn hơn arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy phần tử còn lại\n        while i <= mid:\n            temp[k] = arr[i]\n            i += 1\n            k += 1\n        \n        while j <= right:\n            temp[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy từ temp về arr\n        for i in range(left, right + 1):\n            arr[i] = temp[i]\n        \n        return inv_count\n    \n    def merge_sort_count(arr, temp, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            inv_count += merge_sort_count(arr, temp, left, mid)\n            inv_count += merge_sort_count(arr, temp, mid + 1, right)\n            inv_count += merge_count(arr, temp, left, mid, right)\n        \n        return inv_count\n    \n    n = len(arr)\n    temp = [0] * n\n    return merge_sort_count(arr, temp, 0, n - 1)\n\n# Test\narr = [8, 4, 2, 1]\nprint(f\"Số lần đảo ngược: {count_inversions(arr.copy())}\")  # 6\n```\n\n#### 5.3. Tìm điểm giao nhau của các đoạn thẳng\n\n```python\nclass Segment:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n    \n    def __repr__(self):\n        return f\"[{self.start}, {self.end}]\"\n\ndef merge_intervals(intervals):\n    \"\"\"\n    Gộp các đoạn giao nhau\n    \"\"\"\n    if not intervals:\n        return []\n    \n    # Sắp xếp theo điểm bắt đầu\n    intervals.sort(key=lambda x: x.start)\n    \n    merged = [intervals[0]]\n    \n    for current in intervals[1:]:\n        last = merged[-1]\n        \n        if current.start <= last.end:\n            # Gộp đoạn\n            last.end = max(last.end, current.end)\n        else:\n            merged.append(current)\n    \n    return merged\n\n# Test\nsegments = [\n    Segment(1, 3),\n    Segment(2, 6),\n    Segment(8, 10),\n\n**Các khái niệm quan trọng:**\n- Merge Sort (hoặc Mergesort) là một thuật toán sắp xếp hiệu quả dựa trên kỹ thuật chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chia mảng thành hai nửa, sắp xếp đệ quy từng nửa, sau đó trộn (gộp) hai nửa đã sắp xếp lại với nhau. Merge Sort là một thuật toán sắp xếp ổn định (stable) và có độ phức tạp thời gian O(n log n) trong mọi trường hợp (best, average, worst case). Độ phức tạp không gian của nó là O(n) do cần không gian phụ (mảng tạm) để thực hiện quá trình trộn. Merge Sort có thể được cài đặt bằng đệ quy hoặc lặp, thích hợp cho việc sắp xếp dữ liệu lớn không vừa trong RAM (external sorting), có thể song song hóa, và hiệu quả khi sắp xếp các cấu trúc dữ liệu như linked list. Ngoài ra, Mergesort có thể được sửa đổi để đếm số lần đảo ngược trong một mảng, với một hàm phụ trợ `merge_count` có độ phức tạp O(k) để đếm đảo ngược khi trộn hai mảng con.\n- Sắp xếp là quá trình sắp xếp các phần tử của một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một phép toán cơ bản trong khoa học máy tính. Mergesort là một thuật toán sắp xếp.\n- Gộp (Merge) là phép toán kết hợp hai hoặc nhiều tập hợp đã được sắp xếp thành một tập hợp duy nhất cũng được sắp xếp. Trong Mergesort, phép gộp là bước quan trọng để kết hợp các mảng con đã sắp xếp. Trong bài toán gộp đoạn thẳng, phép gộp là kết hợp các đoạn thẳng giao nhau thành một đoạn duy nhất.\n\n**Mối quan hệ:**\n- merge_sort_count sử dụng hàm merge_count để đếm số lần đảo ngược giữa hai nửa mảng và trộn chúng.\n- Mergesort giải quyết bài toán Sắp xếp các phần tử trong một mảng.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n        # Gộp 2 nửa\n        merge_inplace(arr, left, mid, right)\n\ndef merge_inplace(arr, left, mid, right):\n    \"\"\"\n    Gộp 2 phần đã sắp xếp trong mảng\n    \"\"\"\n    # Tạo mảng tạm\n    left_arr = arr[left:mid + 1]\n    right_arr = arr[mid + 1:right + 1]\n    \n    i = j = 0\n    k = left\n    \n    # Gộp vào mảng gốc\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n    \n    # Copy phần tử còn lại\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    \n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nmerge_sort_inplace(arr, 0, len(arr) - 1)\nprint(\"Mảng sau khi sắp xếp:\", arr)\n```\n\n#### 2.3. Cài đặt với iteration (không đệ quy)\n\n```python\ndef merge_sort_iterative(arr):\n    \"\"\"\n    Merge Sort sử dụng vòng lặp thay vì đệ quy\n    \"\"\"\n    n = len(arr)\n    current_size = 1\n    \n    # Bắt đầu với kích thước 1, tăng gấp đôi mỗi lần\n    while current_size < n:\n        left = 0\n        \n        while left < n - 1:\n            # Tìm điểm giữa và điểm cuối\n            mid = min(left + current_size - 1, n - 1)\n            right = min(left + 2 * current_size - 1, n - 1)\n            \n            # Gộp các phần con\n            merge_inplace(arr, left, mid, right)\n            \n            # Di chuyển đến phần con tiếp theo\n            left += 2 * current_size\n        \n        # Tăng kích thước gấp đôi\n        current_size *= 2\n    \n    return arr\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Mảng sau khi sắp xếp:\", merge_sort_iterative(arr))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Phân tích bằng Master Theorem:**\n- Công thức đệ quy: T(n) = 2T(n/2) + O(n)\n- Trong đó:\n  - 2T(n/2): Chi phí sắp xếp 2 nửa\n  - O(n): Chi phí gộp\n\n**Độ cao cây đệ quy:** log₂(n)\n**Chi phí mỗi tầng:** O(n)\n**Tổng chi phí:** O(n log n)\n\n**Kết quả:**\n- **Best case:** O(n log n)\n- **Average case:** O(n log n)\n- **Worst case:** O(n log n)\n\n**Đặc điểm độ phức tạp:**\n- Luôn là O(n log n), không phụ thuộc vào dữ liệu đầu vào\n- Tốt hơn các thuật toán O(n²)\n- Là thuật toán optimal cho comparison-based sorting trong worst case\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:** O(n)\n- Cần thêm bộ nhớ để lưu các mảng tạm trong quá trình merge\n- Với đệ quy: O(n) cho mảng tạm + O(log n) cho stack\n- Tổng: O(n)\n\n**Cải thiện bộ nhớ:**\n\n**Các khái niệm quan trọng:**\n- merge_inplace là một hàm phụ trợ được sử dụng trong Mergesort để gộp hai mảng con đã sắp xếp (từ left đến mid và từ mid+1 đến right) vào một mảng gốc duy nhất tại chỗ. Mặc dù tên hàm gợi ý \"in-place\" để giảm thiểu việc sử dụng bộ nhớ phụ, việc triển khai cụ thể thường tạo ra các mảng tạm (left_arr và right_arr) để chứa các phần tử của hai nửa, sau đó so sánh và gộp chúng trở lại mảng ban đầu. Độ phức tạp thời gian của phép gộp này là O(n) với n là tổng số phần tử cần gộp. Độ phức tạp không gian có thể là O(1) nếu thực sự gộp tại chỗ, hoặc O(n) nếu cần mảng tạm như trong các triển khai phổ biến.\n\n**Mối quan hệ:**\n- Hàm merge_inplace có độ phức tạp thời gian O(n) để gộp hai mảng con có tổng n phần tử.\n- Mergesort sử dụng hàm merge_inplace để thực hiện bước gộp hai mảng con đã sắp xếp lại với nhau.\n- merge_sort_iterative sử dụng hàm merge_inplace để thực hiện các bước gộp trong quá trình lặp.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n```python\ndef hybrid_merge_sort(arr, threshold=10):\n    \"\"\"\n    Sử dụng Insertion Sort cho mảng nhỏ\n    \"\"\"\n    def insertion_sort_range(arr, left, right):\n        for i in range(left + 1, right + 1):\n            key = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key\n    \n    def merge_sort_helper(left, right):\n        if right - left + 1 <= threshold:\n            insertion_sort_range(arr, left, right)\n        elif left < right:\n            mid = (left + right) // 2\n            merge_sort_helper(left, mid)\n            merge_sort_helper(mid + 1, right)\n            merge_inplace(arr, left, mid, right)\n    \n    merge_sort_helper(0, len(arr) - 1)\n    return arr\n```\n\n#### 4.4. 3-way Merge Sort\n\nChia mảng thành 3 phần thay vì 2.\n\n```python\ndef three_way_merge_sort(arr):\n    \"\"\"\n    Chia mảng thành 3 phần\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    n = len(arr)\n    third = n // 3\n    \n    # Chia thành 3 phần\n    left = merge_sort(arr[:third])\n    middle = merge_sort(arr[third:2*third])\n    right = merge_sort(arr[2*third:])\n    \n    # Gộp 3 phần\n    return merge_three(left, middle, right)\n\ndef merge_three(left, middle, right):\n    \"\"\"\n    Gộp 3 mảng đã sắp xếp\n    \"\"\"\n    result = []\n    i = j = k = 0\n    \n    while i < len(left) and j < len(middle) and k < len(right):\n        if left[i] <= middle[j] and left[i] <= right[k]:\n            result.append(left[i])\n            i += 1\n        elif middle[j] <= left[i] and middle[j] <= right[k]:\n            result.append(middle[j])\n            j += 1\n        else:\n            result.append(right[k])\n            k += 1\n    \n    # Gộp 2 mảng còn lại\n    while i < len(left) and j < len(middle):\n        if left[i] <= middle[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(middle[j])\n            j += 1\n    \n    while i < len(left) and k < len(right):\n        if left[i] <= right[k]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[k])\n            k += 1\n    \n    while j < len(middle) and k < len(right):\n        if middle[j] <= right[k]:\n            result.append(middle[j])\n            j += 1\n        else:\n            result.append(right[k])\n            k += 1\n    \n    # Thêm phần tử còn lại\n    result.extend(left[i:])\n    result.extend(middle[j:])\n    result.extend(right[k:])\n    \n    return result\n```\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. External Sorting (Sắp xếp file lớn)\n\n```python\nimport os\nimport heapq\n\ndef external_merge_sort(input_file, output_file, chunk_size=1000):\n    \"\"\"\n    Sắp xếp file lớn không fit trong RAM\n    \"\"\"\n    # Bước 1: Chia file thành các chunk nhỏ và sắp xếp\n    temp_files = []\n    with open(input_file, 'r') as f:\n        chunk = []\n        for line in f:\n            chunk.append(int(line.strip()))\n            \n            if len(chunk) >= chunk_size:\n                chunk.sort()\n                temp_file = f\"temp_{len(temp_files)}.txt\"\n                with open(temp_file, 'w') as tf:\n                    tf.writelines(f\"{x}\n\" for x in chunk)\n                temp_files.append(temp_file)\n                chunk = []\n        \n        # Xử lý chunk cuối\n        if chunk:\n            chunk.sort()\n            temp_file = f\"temp_{len(temp_files)}.txt\"\n            with open(temp_file, 'w') as tf:\n                tf.writelines(f\"{x}\n\" for x in chunk)\n            temp_files.append(temp_file)\n    \n\n**Các khái niệm quan trọng:**\n- merge_inplace là một hàm phụ trợ được sử dụng trong Mergesort để gộp hai mảng con đã sắp xếp (từ left đến mid và từ mid+1 đến right) vào một mảng gốc duy nhất tại chỗ. Mặc dù tên hàm gợi ý \"in-place\" để giảm thiểu việc sử dụng bộ nhớ phụ, việc triển khai cụ thể thường tạo ra các mảng tạm (left_arr và right_arr) để chứa các phần tử của hai nửa, sau đó so sánh và gộp chúng trở lại mảng ban đầu. Độ phức tạp thời gian của phép gộp này là O(n) với n là tổng số phần tử cần gộp. Độ phức tạp không gian có thể là O(1) nếu thực sự gộp tại chỗ, hoặc O(n) nếu cần mảng tạm như trong các triển khai phổ biến.\n\n**Mối quan hệ:**\n- Mergesort sử dụng hàm merge_inplace để thực hiện bước gộp hai mảng con đã sắp xếp lại với nhau.\n- merge_sort_iterative sử dụng hàm merge_inplace để thực hiện các bước gộp trong quá trình lặp.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n---\n\n## Mergesort\n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\nMerge Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật **Chia để trị (Divide and Conquer)**. Thuật toán chia mảng thành các phần nhỏ hơn, sắp xếp chúng, sau đó gộp (merge) các phần đã sắp xếp lại với nhau.\n\n**Nguyên lý Divide and Conquer:**\n1. **Divide (Chia):** Chia bài toán thành các bài toán con nhỏ hơn\n2. **Conquer (Chinh phục):** Giải quyết các bài toán con (đệ quy)\n3. **Combine (Kết hợp):** Gộp các lời giải của bài toán con\n\n#### 1.2. Ý tưởng chính\n\n```\nMảng: [38, 27, 43, 3, 9, 82, 10]\n\nBước 1 - Chia:\n[38, 27, 43, 3] | [9, 82, 10]\n\nBước 2 - Chia tiếp:\n[38, 27] | [43, 3] | [9, 82] | [10]\n\nBước 3 - Chia đến mức cơ sở:\n[38] | [27] | [43] | [3] | [9] | [82] | [10]\n\nBước 4 - Gộp:\n[27, 38] | [3, 43] | [9, 82] | [10]\n\nBước 5 - Gộp tiếp:\n[3, 27, 38, 43] | [9, 10, 82]\n\nBước 6 - Gộp cuối:\n[3, 9, 10, 27, 38, 43, 82]\n```\n\n---\n\n### 2. Thuật toán Merge Sort\n\n#### 2.1. Cài đặt cơ bản\n\n```python\ndef merge_sort(arr):\n    \"\"\"\n    Sắp xếp mảng sử dụng Merge Sort\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    # Chia mảng thành 2 nửa\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Đệ quy sắp xếp 2 nửa\n    left = merge_sort(left)\n    right = merge_sort(right)\n    \n    # Gộp 2 nửa đã sắp xếp\n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    Gộp 2 mảng đã sắp xếp thành 1 mảng sắp xếp\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # So sánh từng phần tử và thêm phần tử nhỏ hơn vào result\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # Thêm các phần tử còn lại (nếu có)\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", merge_sort(arr))\n```\n\n#### 2.2. Cài đặt In-place (tối ưu bộ nhớ)\n\n```python\ndef merge_sort_inplace(arr, left, right):\n    \"\"\"\n    Merge Sort in-place để tiết kiệm bộ nhớ\n    \"\"\"\n    if left < right:\n        mid = (left + right) // 2\n        \n        # Sắp xếp 2 nửa\n        merge_sort_inplace(arr, left, mid)\n        merge_sort_inplace(arr, mid + 1, right)\n        \n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n- Merge là một phép toán cốt lõi trong thuật toán Mergesort, có nhiệm vụ kết hợp hai danh sách (hoặc mảng) con đã được sắp xếp thành một danh sách (hoặc mảng) duy nhất cũng đã được sắp xếp. Quá trình này hoạt động bằng cách so sánh từng phần tử từ hai danh sách con và thêm phần tử nhỏ hơn vào danh sách kết quả cho đến khi một trong hai danh sách con cạn kiệt, sau đó thêm các phần tử còn lại của danh sách kia vào. Phép toán merge có độ phức tạp thời gian là O(n), trong đó n là tổng số phần tử của hai danh sách con.\n\n**Mối quan hệ:**\n- Phép toán merge trong Merge Sort có độ phức tạp thời gian O(n), với n là tổng số phần tử của hai mảng con cần gộp."
        },
        "output_without_context": {
            "question": "Quá trình hợp nhất hai mảng con đã sắp xếp trong thuật toán Mergesort bao gồm bước nào sau đây?",
            "answer": "So sánh các phần tử đầu tiên của hai mảng và thêm phần tử nhỏ hơn vào mảng kết quả."
        }
    },
    {
        "topic_description": "Chủ đề này liên quan đến phân tích số lần so sánh cần thiết để thực hiện Mergesort. Học sinh sẽ cần áp dụng định lý đệ quy để tìm ra số lần so sánh và so sánh nó với những thuật toán khác. Các câu hỏi có thể yêu cầu chứng minh hoặc giải thích mối quan hệ giữa số lượng phần tử và số lần so sánh.",
        "output_with_context": {
            "question": "Trong thuật toán Mergesort, công thức đệ quy T(n) = 2T(n/2) + O(n) được sử dụng để phân tích độ phức tạp thời gian. Hãy đánh giá độ phức tạp thời gian của Mergesort trong trường hợp tồi tệ nhất.",
            "answer": "O(n log n)",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n    # Bước 2: Merge các file tạm sử dụng heap\n    with open(output_file, 'w') as outf:\n        # Mở tất cả file tạm\n        files = [open(f, 'r') for f in temp_files]\n        \n        # Heap chứa (giá trị, index file)\n        heap = []\n        for i, f in enumerate(files):\n            line = f.readline()\n            if line:\n                heapq.heappush(heap, (int(line.strip()), i))\n        \n        # Merge\n        while heap:\n            value, file_idx = heapq.heappop(heap)\n            outf.write(f\"{value}\n\")\n            \n            # Đọc phần tử tiếp theo từ file\n            line = files[file_idx].readline()\n            if line:\n                heapq.heappush(heap, (int(line.strip()), file_idx))\n        \n        # Đóng các file\n        for f in files:\n            f.close()\n    \n    # Xóa file tạm\n    for temp_file in temp_files:\n        os.remove(temp_file)\n```\n\n#### 5.2. Đếm số lần đảo ngược (Inversion Count)\n\n```python\ndef count_inversions(arr):\n    \"\"\"\n    Đếm số cặp (i, j) mà i < j nhưng arr[i] > arr[j]\n    Sử dụng merge sort: O(n log n)\n    \"\"\"\n    def merge_count(arr, temp, left, mid, right):\n        i = left    # Index cho mảng trái\n        j = mid + 1 # Index cho mảng phải\n        k = left    # Index cho mảng kết quả\n        inv_count = 0\n        \n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                i += 1\n            else:\n                temp[k] = arr[j]\n                # Tất cả phần tử từ i đến mid đều lớn hơn arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy phần tử còn lại\n        while i <= mid:\n            temp[k] = arr[i]\n            i += 1\n            k += 1\n        \n        while j <= right:\n            temp[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy từ temp về arr\n        for i in range(left, right + 1):\n            arr[i] = temp[i]\n        \n        return inv_count\n    \n    def merge_sort_count(arr, temp, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            \n            inv_count += merge_sort_count(arr, temp, left, mid)\n            inv_count += merge_sort_count(arr, temp, mid + 1, right)\n            inv_count += merge_count(arr, temp, left, mid, right)\n        \n        return inv_count\n    \n    n = len(arr)\n    temp = [0] * n\n    return merge_sort_count(arr, temp, 0, n - 1)\n\n# Test\narr = [8, 4, 2, 1]\nprint(f\"Số lần đảo ngược: {count_inversions(arr.copy())}\")  # 6\n```\n\n#### 5.3. Tìm điểm giao nhau của các đoạn thẳng\n\n```python\nclass Segment:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n    \n    def __repr__(self):\n        return f\"[{self.start}, {self.end}]\"\n\ndef merge_intervals(intervals):\n    \"\"\"\n    Gộp các đoạn giao nhau\n    \"\"\"\n    if not intervals:\n        return []\n    \n    # Sắp xếp theo điểm bắt đầu\n    intervals.sort(key=lambda x: x.start)\n    \n    merged = [intervals[0]]\n    \n    for current in intervals[1:]:\n        last = merged[-1]\n        \n        if current.start <= last.end:\n            # Gộp đoạn\n            last.end = max(last.end, current.end)\n        else:\n            merged.append(current)\n    \n    return merged\n\n# Test\nsegments = [\n    Segment(1, 3),\n    Segment(2, 6),\n    Segment(8, 10),\n\n**Các khái niệm quan trọng:**\n- Merge Sort (hoặc Mergesort) là một thuật toán sắp xếp hiệu quả dựa trên kỹ thuật chia để trị (Divide and Conquer). Thuật toán hoạt động bằng cách chia mảng thành hai nửa, sắp xếp đệ quy từng nửa, sau đó trộn (gộp) hai nửa đã sắp xếp lại với nhau. Merge Sort là một thuật toán sắp xếp ổn định (stable) và có độ phức tạp thời gian O(n log n) trong mọi trường hợp (best, average, worst case). Độ phức tạp không gian của nó là O(n) do cần không gian phụ (mảng tạm) để thực hiện quá trình trộn. Merge Sort có thể được cài đặt bằng đệ quy hoặc lặp, thích hợp cho việc sắp xếp dữ liệu lớn không vừa trong RAM (external sorting), có thể song song hóa, và hiệu quả khi sắp xếp các cấu trúc dữ liệu như linked list. Ngoài ra, Mergesort có thể được sửa đổi để đếm số lần đảo ngược trong một mảng, với một hàm phụ trợ `merge_count` có độ phức tạp O(k) để đếm đảo ngược khi trộn hai mảng con.\n\n**Mối quan hệ:**\n- merge_sort_count sử dụng hàm merge_count để đếm số lần đảo ngược giữa hai nửa mảng và trộn chúng.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n        # Gộp 2 nửa\n        merge_inplace(arr, left, mid, right)\n\ndef merge_inplace(arr, left, mid, right):\n    \"\"\"\n    Gộp 2 phần đã sắp xếp trong mảng\n    \"\"\"\n    # Tạo mảng tạm\n    left_arr = arr[left:mid + 1]\n    right_arr = arr[mid + 1:right + 1]\n    \n    i = j = 0\n    k = left\n    \n    # Gộp vào mảng gốc\n    while i < len(left_arr) and j < len(right_arr):\n        if left_arr[i] <= right_arr[j]:\n            arr[k] = left_arr[i]\n            i += 1\n        else:\n            arr[k] = right_arr[j]\n            j += 1\n        k += 1\n    \n    # Copy phần tử còn lại\n    while i < len(left_arr):\n        arr[k] = left_arr[i]\n        i += 1\n        k += 1\n    \n    while j < len(right_arr):\n        arr[k] = right_arr[j]\n        j += 1\n        k += 1\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nmerge_sort_inplace(arr, 0, len(arr) - 1)\nprint(\"Mảng sau khi sắp xếp:\", arr)\n```\n\n#### 2.3. Cài đặt với iteration (không đệ quy)\n\n```python\ndef merge_sort_iterative(arr):\n    \"\"\"\n    Merge Sort sử dụng vòng lặp thay vì đệ quy\n    \"\"\"\n    n = len(arr)\n    current_size = 1\n    \n    # Bắt đầu với kích thước 1, tăng gấp đôi mỗi lần\n    while current_size < n:\n        left = 0\n        \n        while left < n - 1:\n            # Tìm điểm giữa và điểm cuối\n            mid = min(left + current_size - 1, n - 1)\n            right = min(left + 2 * current_size - 1, n - 1)\n            \n            # Gộp các phần con\n            merge_inplace(arr, left, mid, right)\n            \n            # Di chuyển đến phần con tiếp theo\n            left += 2 * current_size\n        \n        # Tăng kích thước gấp đôi\n        current_size *= 2\n    \n    return arr\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Mảng sau khi sắp xếp:\", merge_sort_iterative(arr))\n```\n\n---\n\n### 3. Phân tích thuật toán\n\n#### 3.1. Độ phức tạp thời gian\n\n**Phân tích bằng Master Theorem:**\n- Công thức đệ quy: T(n) = 2T(n/2) + O(n)\n- Trong đó:\n  - 2T(n/2): Chi phí sắp xếp 2 nửa\n  - O(n): Chi phí gộp\n\n**Độ cao cây đệ quy:** log₂(n)\n**Chi phí mỗi tầng:** O(n)\n**Tổng chi phí:** O(n log n)\n\n**Kết quả:**\n- **Best case:** O(n log n)\n- **Average case:** O(n log n)\n- **Worst case:** O(n log n)\n\n**Đặc điểm độ phức tạp:**\n- Luôn là O(n log n), không phụ thuộc vào dữ liệu đầu vào\n- Tốt hơn các thuật toán O(n²)\n- Là thuật toán optimal cho comparison-based sorting trong worst case\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:** O(n)\n- Cần thêm bộ nhớ để lưu các mảng tạm trong quá trình merge\n- Với đệ quy: O(n) cho mảng tạm + O(log n) cho stack\n- Tổng: O(n)\n\n**Cải thiện bộ nhớ:**\n\n**Các khái niệm quan trọng:**\n- Comparison-based sorting là một loại bài toán sắp xếp mà các thuật toán chỉ có thể truy cập các phần tử thông qua phép so sánh giữa chúng. Mergesort là một thuật toán sắp xếp dựa trên so sánh và được coi là tối ưu trong worst case với độ phức tạp O(n log n).\n- T(n) = 2T(n/2) + O(n) là công thức đệ quy mô tả độ phức tạp thời gian của thuật toán Mergesort. Trong đó, 2T(n/2) biểu thị chi phí để sắp xếp đệ quy hai nửa của mảng (mỗi nửa có kích thước n/2), và O(n) biểu thị chi phí để gộp hai nửa đã sắp xếp lại với nhau.\n\n**Mối quan hệ:**\n- Công thức đệ quy T(n) = 2T(n/2) + O(n) được phân tích bằng Master Theorem để xác định độ phức tạp thời gian.\n- Độ phức tạp thời gian của Mergesort dẫn xuất từ công thức đệ quy T(n) = 2T(n/2) + O(n).\n- Mergesort giải quyết bài toán Comparison-based sorting một cách hiệu quả.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n---\n\n## Mergesort\n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\nMerge Sort là một thuật toán sắp xếp hiệu quả sử dụng kỹ thuật **Chia để trị (Divide and Conquer)**. Thuật toán chia mảng thành các phần nhỏ hơn, sắp xếp chúng, sau đó gộp (merge) các phần đã sắp xếp lại với nhau.\n\n**Nguyên lý Divide and Conquer:**\n1. **Divide (Chia):** Chia bài toán thành các bài toán con nhỏ hơn\n2. **Conquer (Chinh phục):** Giải quyết các bài toán con (đệ quy)\n3. **Combine (Kết hợp):** Gộp các lời giải của bài toán con\n\n#### 1.2. Ý tưởng chính\n\n```\nMảng: [38, 27, 43, 3, 9, 82, 10]\n\nBước 1 - Chia:\n[38, 27, 43, 3] | [9, 82, 10]\n\nBước 2 - Chia tiếp:\n[38, 27] | [43, 3] | [9, 82] | [10]\n\nBước 3 - Chia đến mức cơ sở:\n[38] | [27] | [43] | [3] | [9] | [82] | [10]\n\nBước 4 - Gộp:\n[27, 38] | [3, 43] | [9, 82] | [10]\n\nBước 5 - Gộp tiếp:\n[3, 27, 38, 43] | [9, 10, 82]\n\nBước 6 - Gộp cuối:\n[3, 9, 10, 27, 38, 43, 82]\n```\n\n---\n\n### 2. Thuật toán Merge Sort\n\n#### 2.1. Cài đặt cơ bản\n\n```python\ndef merge_sort(arr):\n    \"\"\"\n    Sắp xếp mảng sử dụng Merge Sort\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    # Chia mảng thành 2 nửa\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    # Đệ quy sắp xếp 2 nửa\n    left = merge_sort(left)\n    right = merge_sort(right)\n    \n    # Gộp 2 nửa đã sắp xếp\n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"\n    Gộp 2 mảng đã sắp xếp thành 1 mảng sắp xếp\n    \"\"\"\n    result = []\n    i = j = 0\n    \n    # So sánh từng phần tử và thêm phần tử nhỏ hơn vào result\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # Thêm các phần tử còn lại (nếu có)\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\n# Test\narr = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", merge_sort(arr))\n```\n\n#### 2.2. Cài đặt In-place (tối ưu bộ nhớ)\n\n```python\ndef merge_sort_inplace(arr, left, right):\n    \"\"\"\n    Merge Sort in-place để tiết kiệm bộ nhớ\n    \"\"\"\n    if left < right:\n        mid = (left + right) // 2\n        \n        # Sắp xếp 2 nửa\n        merge_sort_inplace(arr, left, mid)\n        merge_sort_inplace(arr, mid + 1, right)\n        \n\n**Các khái niệm quan trọng:**\n- Merge là một phép toán cốt lõi trong thuật toán Mergesort, có nhiệm vụ kết hợp hai danh sách (hoặc mảng) con đã được sắp xếp thành một danh sách (hoặc mảng) duy nhất cũng đã được sắp xếp. Quá trình này hoạt động bằng cách so sánh từng phần tử từ hai danh sách con và thêm phần tử nhỏ hơn vào danh sách kết quả cho đến khi một trong hai danh sách con cạn kiệt, sau đó thêm các phần tử còn lại của danh sách kia vào. Phép toán merge có độ phức tạp thời gian là O(n), trong đó n là tổng số phần tử của hai danh sách con.\n\n**Mối quan hệ:**\n- Phép toán merge trong Merge Sort có độ phức tạp thời gian O(n), với n là tổng số phần tử của hai mảng con cần gộp.\n- Phép toán merge có độ phức tạp thời gian O(n) với n là tổng số phần tử của hai danh sách con.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Mergesort\n```python\ndef hybrid_merge_sort(arr, threshold=10):\n    \"\"\"\n    Sử dụng Insertion Sort cho mảng nhỏ\n    \"\"\"\n    def insertion_sort_range(arr, left, right):\n        for i in range(left + 1, right + 1):\n            key = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key\n    \n    def merge_sort_helper(left, right):\n        if right - left + 1 <= threshold:\n            insertion_sort_range(arr, left, right)\n        elif left < right:\n            mid = (left + right) // 2\n            merge_sort_helper(left, mid)\n            merge_sort_helper(mid + 1, right)\n            merge_inplace(arr, left, mid, right)\n    \n    merge_sort_helper(0, len(arr) - 1)\n    return arr\n```\n\n#### 4.4. 3-way Merge Sort\n\nChia mảng thành 3 phần thay vì 2.\n\n```python\ndef three_way_merge_sort(arr):\n    \"\"\"\n    Chia mảng thành 3 phần\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    n = len(arr)\n    third = n // 3\n    \n    # Chia thành 3 phần\n    left = merge_sort(arr[:third])\n    middle = merge_sort(arr[third:2*third])\n    right = merge_sort(arr[2*third:])\n    \n    # Gộp 3 phần\n    return merge_three(left, middle, right)\n\ndef merge_three(left, middle, right):\n    \"\"\"\n    Gộp 3 mảng đã sắp xếp\n    \"\"\"\n    result = []\n    i = j = k = 0\n    \n    while i < len(left) and j < len(middle) and k < len(right):\n        if left[i] <= middle[j] and left[i] <= right[k]:\n            result.append(left[i])\n            i += 1\n        elif middle[j] <= left[i] and middle[j] <= right[k]:\n            result.append(middle[j])\n            j += 1\n        else:\n            result.append(right[k])\n            k += 1\n    \n    # Gộp 2 mảng còn lại\n    while i < len(left) and j < len(middle):\n        if left[i] <= middle[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(middle[j])\n            j += 1\n    \n    while i < len(left) and k < len(right):\n        if left[i] <= right[k]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[k])\n            k += 1\n    \n    while j < len(middle) and k < len(right):\n        if middle[j] <= right[k]:\n            result.append(middle[j])\n            j += 1\n        else:\n            result.append(right[k])\n            k += 1\n    \n    # Thêm phần tử còn lại\n    result.extend(left[i:])\n    result.extend(middle[j:])\n    result.extend(right[k:])\n    \n    return result\n```\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. External Sorting (Sắp xếp file lớn)\n\n```python\nimport os\nimport heapq\n\ndef external_merge_sort(input_file, output_file, chunk_size=1000):\n    \"\"\"\n    Sắp xếp file lớn không fit trong RAM\n    \"\"\"\n    # Bước 1: Chia file thành các chunk nhỏ và sắp xếp\n    temp_files = []\n    with open(input_file, 'r') as f:\n        chunk = []\n        for line in f:\n            chunk.append(int(line.strip()))\n            \n            if len(chunk) >= chunk_size:\n                chunk.sort()\n                temp_file = f\"temp_{len(temp_files)}.txt\"\n                with open(temp_file, 'w') as tf:\n                    tf.writelines(f\"{x}\n\" for x in chunk)\n                temp_files.append(temp_file)\n                chunk = []\n        \n        # Xử lý chunk cuối\n        if chunk:\n            chunk.sort()\n            temp_file = f\"temp_{len(temp_files)}.txt\"\n            with open(temp_file, 'w') as tf:\n                tf.writelines(f\"{x}\n\" for x in chunk)\n            temp_files.append(temp_file)\n    \n\n**Các khái niệm quan trọng:**\n- 3-way Merge Sort là một biến thể của Mergesort, thay vì chia mảng thành 2 phần, nó chia mảng thành 3 phần bằng nhau, sắp xếp đệ quy từng phần, sau đó gộp 3 phần đã sắp xếp lại với nhau. Ý tưởng chính là giảm chiều sâu của cây đệ quy nhưng tăng độ phức tạp của bước gộp. Độ phức tạp thời gian vẫn là O(n log n). Độ phức tạp không gian là O(n) do cần mảng phụ để gộp.\n\n**Mối quan hệ:**\n- 3-way Merge Sort có độ phức tạp thời gian O(n log n) cho việc sắp xếp.\n- merge_three được sử dụng bởi 3-way Merge Sort để gộp ba mảng con đã sắp xếp.\n- 3-way Merge Sort là một biến thể của Mergesort, khác biệt ở cách chia mảng thành 3 phần thay vì 2.\n- 3-way Merge Sort có độ phức tạp không gian O(n) do cần mảng phụ để gộp."
        },
        "output_without_context": {
            "question": "Trong thuật toán Mergesort, số lần so sánh cần thiết để sắp xếp n phần tử có thể được ước lượng bằng công thức nào?",
            "answer": "O(n log n)"
        }
    },
    {
        "topic_description": "Chủ đề này khám phá giới hạn dưới cho các thuật toán sắp xếp dựa trên so sánh, yêu cầu sinh viên tìm hiểu và chứng minh rằng bất kỳ thuật toán sắp xếp nào cũng cần ít nhất lg(N!) lần so sánh trong trường hợp xấu nhất. Câu hỏi sẽ kiểm tra khả năng hiển thị và phân tích lý thuyết của học sinh.",
        "output_with_context": {
            "question": "Tại sao bất kỳ thuật toán sắp xếp nào dựa trên so sánh đều cần ít nhất lg(N!) lần so sánh trong trường hợp xấu nhất?",
            "answer": "Bởi vì số lượng so sánh cần thiết để xác định thứ tự của N phần tử là tối thiểu lg(N!).",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n**Ưu điểm:**\n- Đơn giản, dễ cài đặt\n- Hiệu quả với mảng nhỏ hoặc gần như đã sắp xếp\n- Stable và adaptive\n- Online - có thể sắp xếp dữ liệu đến dần dần\n- Ít hoán đổi hơn Bubble Sort\n\n**Nhược điểm:**\n- Không hiệu quả với dữ liệu lớn và ngẫu nhiên\n\n#### 4.5. Tối ưu hóa: Binary Insertion Sort\n\n```python\ndef binary_search(arr, item, start, end):\n    \"\"\"Tìm vị trí chèn bằng Binary Search\"\"\"\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] < item:\n            start = mid + 1\n        elif arr[mid] > item:\n            end = mid - 1\n        else:\n            return mid + 1\n    return start\n\ndef binary_insertion_sort(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        key = arr[i]\n        # Tìm vị trí chèn bằng Binary Search\n        pos = binary_search(arr, key, 0, i - 1)\n        \n        # Dịch chuyển các phần tử\n        arr = arr[:pos] + [key] + arr[pos:i] + arr[i+1:]\n    \n    return arr\n```\n\nGiảm số lần so sánh từ O(n²) xuống O(n log n), nhưng số lần dịch chuyển vẫn là O(n²).\n\n---\n\n### 5. So sánh các thuật toán cơ bản\n\n| Thuật toán | Best | Average | Worst | Space | Stable | Adaptive |\n|------------|------|---------|-------|-------|--------|----------|\n| Bubble Sort | O(n) | O(n²) | O(n²) | O(1) | ✅ | ✅ |\n| Selection Sort | O(n²) | O(n²) | O(n²) | O(1) | ❌ | ❌ |\n| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) | ✅ | ✅ |\n\n#### 5.1. Khi nào sử dụng?\n\n**Bubble Sort:**\n- Mảng nhỏ và gần như đã sắp xếp\n- Mục đích giáo dục\n- Khi cần thuật toán đơn giản nhất\n\n**Selection Sort:**\n- Khi chi phí hoán đổi cao (ít hoán đổi nhất)\n- Mảng nhỏ\n- Khi bộ nhớ phụ bị hạn chế\n\n**Insertion Sort:**\n- Mảng nhỏ (< 50 phần tử)\n- Mảng gần như đã sắp xếp\n- Dữ liệu đến theo thời gian thực (online)\n- Kết hợp với Merge Sort hoặc Quick Sort cho mảng con nhỏ\n\n#### 5.2. Code so sánh hiệu năng\n\n```python\nimport time\nimport random\n\ndef compare_sorting_algorithms(size=1000):\n    # Tạo mảng ngẫu nhiên\n    arr = [random.randint(1, 1000) for _ in range(size)]\n    \n    algorithms = {\n        'Bubble Sort': bubble_sort,\n        'Selection Sort': selection_sort,\n        'Insertion Sort': insertion_sort\n    }\n    \n    results = {}\n    \n    for name, func in algorithms.items():\n        test_arr = arr.copy()\n        start_time = time.time()\n        func(test_arr)\n        end_time = time.time()\n        results[name] = end_time - start_time\n    \n    # In kết quả\n    print(f\"\nThời gian thực thi với mảng {size} phần tử:\")\n    for name, exec_time in sorted(results.items(), key=lambda x: x[1]):\n        print(f\"{name:20s}: {exec_time:.6f} giây\")\n\n# Test với các kích thước khác nhau\n\n**Các khái niệm quan trọng:**\n- So sánh là một phép toán cơ bản trong các thuật toán sắp xếp dựa trên so sánh, dùng để xác định mối quan hệ thứ tự giữa hai phần tử. Số lần so sánh là một yếu tố quan trọng ảnh hưởng đến độ phức tạp thời gian của thuật toán.\n- Bubble Sort (Sắp xếp nổi bọt) là một thuật toán sắp xếp đơn giản, thuộc loại comparison-based, hoạt động bằng cách lặp đi lặp lại việc đi qua danh sách, so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này đẩy phần tử lớn nhất (hoặc nhỏ nhất) về cuối mảng sau mỗi lần lặp và lặp lại cho đến khi không còn cặp nào cần hoán đổi, tức là mảng đã được sắp xếp. Thuật toán này đơn giản, dễ cài đặt, stable và adaptive. Để tối ưu hóa, nó có thể sử dụng một cờ `swapped` để dừng sớm nếu không có hoán đổi nào xảy ra trong một lượt. Độ phức tạp thời gian: Best case O(n) (với tối ưu hóa dừng sớm), Average case O(n²), Worst case O(n²). Độ phức tạp không gian: O(1) vì nó là thuật toán tại chỗ (in-place).\n\n**Mối quan hệ:**\n- Bubble Sort có độ phức tạp thời gian O(n²) trong trường hợp trung bình (average case) và trường hợp xấu nhất (worst case) khi mảng sắp xếp ngược, do cần nhiều vòng lặp lồng nhau để so sánh và hoán đổi.\n- Bubble Sort có độ phức tạp thời gian Worst case O(n²) và Average case O(n²) do cần duyệt qua mảng nhiều lần. Best case là O(n) khi mảng đã được sắp xếp và thuật toán dừng sớm nhờ cờ `swapped`.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n        [11, 12, 22, 25, 64]\n\nBước 4: Tìm min = 25, không cần hoán đổi\n        [11, 12, 22, 25, 64]\n```\n\n#### 3.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n²)\n- **Average case:** O(n²)\n- **Worst case:** O(n²)\n- Số lần so sánh luôn cố định: n(n-1)/2\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ❌ Unstable (có thể làm stable với cài đặt khác)\n- ✅ In-place\n- ❌ Không adaptive\n- ✅ Số lần hoán đổi ít nhất: O(n)\n\n**Ưu điểm:**\n- Đơn giản, dễ hiểu\n- Số lần hoán đổi ít (tốt khi chi phí hoán đổi cao)\n- Hoạt động tốt với mảng nhỏ\n\n**Nhược điểm:**\n- Không hiệu quả với dữ liệu lớn\n- Không tận dụng được dữ liệu đã sắp xếp\n\n---\n\n### 4. Insertion Sort (Sắp xếp chèn)\n\n#### 4.1. Ý tưởng\n\nInsertion Sort xây dựng mảng đã sắp xếp từng phần tử một. Nó giống như cách chúng ta sắp xếp bài trong tay: lấy một lá bài và chèn nó vào đúng vị trí trong phần đã sắp xếp.\n\n**Nguyên lý:**\n1. Bắt đầu từ phần tử thứ hai\n2. So sánh với các phần tử bên trái\n3. Dịch các phần tử lớn hơn sang phải\n4. Chèn phần tử vào vị trí đúng\n\n#### 4.2. Thuật toán\n\n```python\ndef insertion_sort(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        key = arr[i]\n        j = i - 1\n        \n        # Di chuyển các phần tử lớn hơn key sang phải\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        \n        # Chèn key vào vị trí đúng\n        arr[j + 1] = key\n    \n    return arr\n\n# Test\narr = [12, 11, 13, 5, 6]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", insertion_sort(arr.copy()))\n```\n\n#### 4.3. Minh họa từng bước\n\n```\nMảng: [12, 11, 13, 5, 6]\n\nBước 1: key = 11\n        [11, 12, 13, 5, 6]\n\nBước 2: key = 13, không thay đổi\n        [11, 12, 13, 5, 6]\n\nBước 3: key = 5\n        [5, 11, 12, 13, 6]\n\nBước 4: key = 6\n        [5, 6, 11, 12, 13]\n```\n\n#### 4.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive\n- ✅ Online\n\n\n**Các khái niệm quan trọng:**\n- Số lần so sánh trong Selection Sort luôn cố định là n(n-1)/2, với n là số phần tử trong mảng. Công thức này thể hiện rằng thuật toán luôn thực hiện một số lượng so sánh nhất định bất kể trạng thái ban đầu của mảng.\n\n**Mối quan hệ:**\n- Selection Sort có số lần so sánh luôn cố định là n(n-1)/2, đây là một đặc điểm của thuật toán này.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", bubble_sort(arr.copy()))\n```\n\n#### 2.3. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã được sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1) - In-place\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive (với tối ưu hóa)\n- ❌ Hiệu quả thấp với dữ liệu lớn\n\n#### 2.4. Biến thể: Cocktail Shaker Sort\n\n```python\ndef cocktail_sort(arr):\n    n = len(arr)\n    start = 0\n    end = n - 1\n    swapped = True\n    \n    while swapped:\n        swapped = False\n        \n        # Đi từ trái sang phải\n        for i in range(start, end):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        if not swapped:\n            break\n        \n        swapped = False\n        end -= 1\n        \n        # Đi từ phải sang trái\n        for i in range(end - 1, start - 1, -1):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        start += 1\n    \n    return arr\n```\n\n---\n\n### 3. Selection Sort (Sắp xếp chọn)\n\n#### 3.1. Ý tưởng\n\nSelection Sort chia mảng thành hai phần: phần đã sắp xếp và phần chưa sắp xếp. Trong mỗi bước, thuật toán tìm phần tử nhỏ nhất trong phần chưa sắp xếp và đưa nó vào cuối phần đã sắp xếp.\n\n**Các bước:**\n1. Tìm phần tử nhỏ nhất trong mảng chưa sắp xếp\n2. Hoán đổi nó với phần tử đầu tiên của mảng chưa sắp xếp\n3. Di chuyển ranh giới giữa phần đã sắp xếp và chưa sắp xếp\n4. Lặp lại cho đến khi mảng được sắp xếp\n\n#### 3.2. Thuật toán\n\n```python\ndef selection_sort(arr):\n    n = len(arr)\n    \n    for i in range(n):\n        # Tìm phần tử nhỏ nhất trong phần chưa sắp xếp\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Hoán đổi phần tử nhỏ nhất với phần tử đầu tiên\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    \n    return arr\n\n# Test\narr = [64, 25, 12, 22, 11]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", selection_sort(arr.copy()))\n```\n\n#### 3.3. Minh họa từng bước\n\n```\nMảng: [64, 25, 12, 22, 11]\n\nBước 1: Tìm min = 11, hoán đổi với vị trí 0\n        [11, 25, 12, 22, 64]\n\nBước 2: Tìm min = 12, hoán đổi với vị trí 1\n        [11, 12, 25, 22, 64]\n\nBước 3: Tìm min = 22, hoán đổi với vị trí 2\n\n**Các khái niệm quan trọng:**\n- Bubble Sort (Sắp xếp nổi bọt) là một thuật toán sắp xếp đơn giản, thuộc loại comparison-based, hoạt động bằng cách lặp đi lặp lại việc đi qua danh sách, so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này đẩy phần tử lớn nhất (hoặc nhỏ nhất) về cuối mảng sau mỗi lần lặp và lặp lại cho đến khi không còn cặp nào cần hoán đổi, tức là mảng đã được sắp xếp. Thuật toán này đơn giản, dễ cài đặt, stable và adaptive. Để tối ưu hóa, nó có thể sử dụng một cờ `swapped` để dừng sớm nếu không có hoán đổi nào xảy ra trong một lượt. Độ phức tạp thời gian: Best case O(n) (với tối ưu hóa dừng sớm), Average case O(n²), Worst case O(n²). Độ phức tạp không gian: O(1) vì nó là thuật toán tại chỗ (in-place).\n\n**Mối quan hệ:**\n- Bubble Sort có độ phức tạp thời gian O(n²) trong trường hợp trung bình (average case) và trường hợp xấu nhất (worst case) khi mảng sắp xếp ngược, do cần nhiều vòng lặp lồng nhau để so sánh và hoán đổi.\n- Bubble Sort có độ phức tạp thời gian Worst case O(n²) và Average case O(n²) do cần duyệt qua mảng nhiều lần. Best case là O(n) khi mảng đã được sắp xếp và thuật toán dừng sớm nhờ cờ `swapped`.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n### 1. Giới thiệu về Sắp xếp\n\n#### 1.1. Khái niệm\n\nSắp xếp (Sorting) là quá trình sắp đặt các phần tử trong một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một trong những thao tác cơ bản và quan trọng nhất trong khoa học máy tính.\n\n**Tại sao sắp xếp quan trọng?**\n- Giúp tìm kiếm nhanh hơn (Binary Search)\n- Tối ưu hóa các thuật toán khác\n- Cải thiện hiệu suất của database\n- Trực quan hóa và phân tích dữ liệu\n\n#### 1.2. Phân loại thuật toán sắp xếp\n\n**a) Theo phương pháp:**\n- **Comparison-based:** So sánh các phần tử (Bubble, Selection, Insertion, Merge, Quick)\n- **Non-comparison-based:** Không so sánh trực tiếp (Counting, Radix, Bucket)\n\n**b) Theo tính ổn định (Stability):**\n- **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- **Unstable:** Không đảm bảo thứ tự tương đối\n\n**c) Theo bộ nhớ:**\n- **In-place:** Sử dụng O(1) bộ nhớ phụ\n- **Out-of-place:** Cần thêm bộ nhớ phụ\n\n#### 1.3. Các tiêu chí đánh giá\n\n- **Time Complexity:** Độ phức tạp thời gian (Best, Average, Worst case)\n- **Space Complexity:** Độ phức tạp không gian\n- **Stability:** Tính ổn định\n- **Adaptive:** Hiệu quả với dữ liệu đã gần sắp xếp\n- **Online:** Có thể xử lý dữ liệu đến theo thời gian thực\n\n---\n\n### 2. Bubble Sort (Sắp xếp nổi bọt)\n\n#### 2.1. Ý tưởng\n\nBubble Sort so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này lặp lại cho đến khi mảng được sắp xếp. Phần tử lớn nhất sẽ \"nổi\" lên vị trí cuối cùng sau mỗi lượt.\n\n**Hình ảnh trực quan:**\n- Lượt 1: Phần tử lớn nhất \"nổi\" lên cuối\n- Lượt 2: Phần tử lớn thứ hai nổi lên vị trí kế cuối\n- Tiếp tục cho đến khi mảng được sắp xếp\n\n#### 2.2. Thuật toán\n\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # Duyệt qua tất cả các phần tử\n    for i in range(n):\n        # Cờ để tối ưu hóa\n        swapped = False\n        \n        # Phần tử cuối cùng i phần tử đã được sắp xếp\n        for j in range(0, n - i - 1):\n            # So sánh phần tử liền kề\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # Nếu không có hoán đổi nào, mảng đã sắp xếp\n        if not swapped:\n            break\n    \n    return arr\n\n# Test\narr = [64, 34, 25, 12, 22, 11, 90]\n\n**Các khái niệm quan trọng:**\n- Comparison là phép toán so sánh hai phần tử để xác định mối quan hệ thứ tự giữa chúng (ví dụ: lớn hơn, nhỏ hơn, bằng). Đây là phép toán cơ bản trong các thuật toán sắp xếp comparison-based.\n- Bubble Sort (Sắp xếp nổi bọt) là một thuật toán sắp xếp đơn giản, thuộc loại comparison-based, hoạt động bằng cách lặp đi lặp lại việc đi qua danh sách, so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này đẩy phần tử lớn nhất (hoặc nhỏ nhất) về cuối mảng sau mỗi lần lặp và lặp lại cho đến khi không còn cặp nào cần hoán đổi, tức là mảng đã được sắp xếp. Thuật toán này đơn giản, dễ cài đặt, stable và adaptive. Để tối ưu hóa, nó có thể sử dụng một cờ `swapped` để dừng sớm nếu không có hoán đổi nào xảy ra trong một lượt. Độ phức tạp thời gian: Best case O(n) (với tối ưu hóa dừng sớm), Average case O(n²), Worst case O(n²). Độ phức tạp không gian: O(1) vì nó là thuật toán tại chỗ (in-place).\n\n**Mối quan hệ:**\n- Bubble Sort có độ phức tạp thời gian O(n²) trong trường hợp trung bình (average case) và trường hợp xấu nhất (worst case) khi mảng sắp xếp ngược, do cần nhiều vòng lặp lồng nhau để so sánh và hoán đổi.\n- Bubble Sort có độ phức tạp thời gian O(n) trong trường hợp tốt nhất (best case) khi mảng đã được sắp xếp, do chỉ cần một lần duyệt để kiểm tra.\n- Bubble Sort có độ phức tạp thời gian Worst case O(n²) và Average case O(n²) do cần duyệt qua mảng nhiều lần. Best case là O(n) khi mảng đã được sắp xếp và thuật toán dừng sớm nhờ cờ `swapped`."
        },
        "output_without_context": {
            "question": "Trong lý thuyết sắp xếp dựa trên so sánh, giới hạn dưới cho số lần so sánh cần thiết trong trường hợp xấu nhất để sắp xếp N phần tử là gì?",
            "answer": "lg(N!)"
        }
    },
    {
        "topic_description": "Chủ đề này yêu cầu sinh viên phân tích tính ổn định của Mergesort và cách mà các thuật toán sắp xếp khác so với nó. Sinh viên sẽ phải hiểu rõ giữa sắp xếp ổn định và không ổn định. Câu hỏi sẽ kiểm tra khả năng so sánh và đánh giá của học sinh giữa các phương pháp sắp xếp khác nhau.",
        "output_with_context": {
            "question": "So với Mergesort, thuật toán nào sau đây được coi là không ổn định?",
            "answer": "Quicksort",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n### 1. Giới thiệu về Sắp xếp\n\n#### 1.1. Khái niệm\n\nSắp xếp (Sorting) là quá trình sắp đặt các phần tử trong một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một trong những thao tác cơ bản và quan trọng nhất trong khoa học máy tính.\n\n**Tại sao sắp xếp quan trọng?**\n- Giúp tìm kiếm nhanh hơn (Binary Search)\n- Tối ưu hóa các thuật toán khác\n- Cải thiện hiệu suất của database\n- Trực quan hóa và phân tích dữ liệu\n\n#### 1.2. Phân loại thuật toán sắp xếp\n\n**a) Theo phương pháp:**\n- **Comparison-based:** So sánh các phần tử (Bubble, Selection, Insertion, Merge, Quick)\n- **Non-comparison-based:** Không so sánh trực tiếp (Counting, Radix, Bucket)\n\n**b) Theo tính ổn định (Stability):**\n- **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- **Unstable:** Không đảm bảo thứ tự tương đối\n\n**c) Theo bộ nhớ:**\n- **In-place:** Sử dụng O(1) bộ nhớ phụ\n- **Out-of-place:** Cần thêm bộ nhớ phụ\n\n#### 1.3. Các tiêu chí đánh giá\n\n- **Time Complexity:** Độ phức tạp thời gian (Best, Average, Worst case)\n- **Space Complexity:** Độ phức tạp không gian\n- **Stability:** Tính ổn định\n- **Adaptive:** Hiệu quả với dữ liệu đã gần sắp xếp\n- **Online:** Có thể xử lý dữ liệu đến theo thời gian thực\n\n---\n\n### 2. Bubble Sort (Sắp xếp nổi bọt)\n\n#### 2.1. Ý tưởng\n\nBubble Sort so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này lặp lại cho đến khi mảng được sắp xếp. Phần tử lớn nhất sẽ \"nổi\" lên vị trí cuối cùng sau mỗi lượt.\n\n**Hình ảnh trực quan:**\n- Lượt 1: Phần tử lớn nhất \"nổi\" lên cuối\n- Lượt 2: Phần tử lớn thứ hai nổi lên vị trí kế cuối\n- Tiếp tục cho đến khi mảng được sắp xếp\n\n#### 2.2. Thuật toán\n\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # Duyệt qua tất cả các phần tử\n    for i in range(n):\n        # Cờ để tối ưu hóa\n        swapped = False\n        \n        # Phần tử cuối cùng i phần tử đã được sắp xếp\n        for j in range(0, n - i - 1):\n            # So sánh phần tử liền kề\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # Nếu không có hoán đổi nào, mảng đã sắp xếp\n        if not swapped:\n            break\n    \n    return arr\n\n# Test\narr = [64, 34, 25, 12, 22, 11, 90]\n\n**Các khái niệm quan trọng:**\n- Stability (tính ổn định) là một tính chất quan trọng của thuật toán sắp xếp, cho biết liệu thuật toán có giữ nguyên thứ tự tương đối ban đầu của các phần tử có giá trị bằng nhau sau khi sắp xếp hay không. Một thuật toán được gọi là \"stable\" (ổn định) nếu nó đảm bảo rằng các phần tử có giá trị bằng nhau sẽ duy trì thứ tự tương đối của chúng trong mảng đã sắp xếp so với mảng ban đầu. Ngược lại, một thuật toán \"unstable\" (không ổn định) không đảm bảo giữ được thứ tự tương đối này, nghĩa là thứ tự của các phần tử bằng nhau có thể bị thay đổi. Các thuật toán ổn định bao gồm Merge Sort, Bubble Sort và Insertion Sort. Trong khi đó, Quicksort, Heap Sort và Selection Sort là các thuật toán không ổn định.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Sorting tối ưu hóa Binary Search bằng cách sắp xếp dữ liệu, cho phép Binary Search hoạt động hiệu quả hơn với độ phức tạp O(log n).\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn.\n- Insertion Sort giải quyết bài toán Sorting bằng cách chèn từng phần tử vào đúng vị trí trong phần đã sắp xếp của mảng.\n- Insertion Sort giải quyết bài toán sắp xếp bằng cách chèn từng phần tử vào đúng vị trí trong phần đã sắp xếp của mảng.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n        [11, 12, 22, 25, 64]\n\nBước 4: Tìm min = 25, không cần hoán đổi\n        [11, 12, 22, 25, 64]\n```\n\n#### 3.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n²)\n- **Average case:** O(n²)\n- **Worst case:** O(n²)\n- Số lần so sánh luôn cố định: n(n-1)/2\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ❌ Unstable (có thể làm stable với cài đặt khác)\n- ✅ In-place\n- ❌ Không adaptive\n- ✅ Số lần hoán đổi ít nhất: O(n)\n\n**Ưu điểm:**\n- Đơn giản, dễ hiểu\n- Số lần hoán đổi ít (tốt khi chi phí hoán đổi cao)\n- Hoạt động tốt với mảng nhỏ\n\n**Nhược điểm:**\n- Không hiệu quả với dữ liệu lớn\n- Không tận dụng được dữ liệu đã sắp xếp\n\n---\n\n### 4. Insertion Sort (Sắp xếp chèn)\n\n#### 4.1. Ý tưởng\n\nInsertion Sort xây dựng mảng đã sắp xếp từng phần tử một. Nó giống như cách chúng ta sắp xếp bài trong tay: lấy một lá bài và chèn nó vào đúng vị trí trong phần đã sắp xếp.\n\n**Nguyên lý:**\n1. Bắt đầu từ phần tử thứ hai\n2. So sánh với các phần tử bên trái\n3. Dịch các phần tử lớn hơn sang phải\n4. Chèn phần tử vào vị trí đúng\n\n#### 4.2. Thuật toán\n\n```python\ndef insertion_sort(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        key = arr[i]\n        j = i - 1\n        \n        # Di chuyển các phần tử lớn hơn key sang phải\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        \n        # Chèn key vào vị trí đúng\n        arr[j + 1] = key\n    \n    return arr\n\n# Test\narr = [12, 11, 13, 5, 6]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", insertion_sort(arr.copy()))\n```\n\n#### 4.3. Minh họa từng bước\n\n```\nMảng: [12, 11, 13, 5, 6]\n\nBước 1: key = 11\n        [11, 12, 13, 5, 6]\n\nBước 2: key = 13, không thay đổi\n        [11, 12, 13, 5, 6]\n\nBước 3: key = 5\n        [5, 11, 12, 13, 6]\n\nBước 4: key = 6\n        [5, 6, 11, 12, 13]\n```\n\n#### 4.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive\n- ✅ Online\n\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Sorting tối ưu hóa Binary Search bằng cách sắp xếp dữ liệu, cho phép Binary Search hoạt động hiệu quả hơn với độ phức tạp O(log n).\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn.\n- Insertion Sort giải quyết bài toán Sorting bằng cách chèn từng phần tử vào đúng vị trí trong phần đã sắp xếp của mảng.\n- Insertion Sort giải quyết bài toán sắp xếp bằng cách chèn từng phần tử vào đúng vị trí trong phần đã sắp xếp của mảng."
        },
        "output_without_context": {
            "question": "So với Mergesort, thuật toán sắp xếp nào sau đây được coi là không ổn định?",
            "answer": "Sắp xếp nhanh (Quicksort)"
        }
    }
]