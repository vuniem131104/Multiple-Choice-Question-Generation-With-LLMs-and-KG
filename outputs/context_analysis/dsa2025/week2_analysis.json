[
    {
        "topic_description": "Chủ đề này khám phá khái niệm sắp xếp như một quy trình tổ chức mảng theo thứ tự tăng dần. Học sinh cần hiểu các ví dụ thực tế về sắp xếp như sắp xếp hồ sơ sinh viên và dữ liệu trong thư mục. Các câu hỏi có thể kiểm tra định nghĩa và ứng dụng của sắp xếp trong lập trình.",
        "output_with_context": {
            "question": "Sắp xếp (Sorting) là gì trong khoa học máy tính?",
            "answer": "Sắp xếp là quá trình tổ chức các phần tử trong một tập hợp theo thứ tự nhất định (tăng dần hoặc giảm dần).",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n### 1. Giới thiệu về Sắp xếp\n\n#### 1.1. Khái niệm\n\nSắp xếp (Sorting) là quá trình sắp đặt các phần tử trong một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một trong những thao tác cơ bản và quan trọng nhất trong khoa học máy tính.\n\n**Tại sao sắp xếp quan trọng?**\n- Giúp tìm kiếm nhanh hơn (Binary Search)\n- Tối ưu hóa các thuật toán khác\n- Cải thiện hiệu suất của database\n- Trực quan hóa và phân tích dữ liệu\n\n#### 1.2. Phân loại thuật toán sắp xếp\n\n**a) Theo phương pháp:**\n- **Comparison-based:** So sánh các phần tử (Bubble, Selection, Insertion, Merge, Quick)\n- **Non-comparison-based:** Không so sánh trực tiếp (Counting, Radix, Bucket)\n\n**b) Theo tính ổn định (Stability):**\n- **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- **Unstable:** Không đảm bảo thứ tự tương đối\n\n**c) Theo bộ nhớ:**\n- **In-place:** Sử dụng O(1) bộ nhớ phụ\n- **Out-of-place:** Cần thêm bộ nhớ phụ\n\n#### 1.3. Các tiêu chí đánh giá\n\n- **Time Complexity:** Độ phức tạp thời gian (Best, Average, Worst case)\n- **Space Complexity:** Độ phức tạp không gian\n- **Stability:** Tính ổn định\n- **Adaptive:** Hiệu quả với dữ liệu đã gần sắp xếp\n- **Online:** Có thể xử lý dữ liệu đến theo thời gian thực\n\n---\n\n### 2. Bubble Sort (Sắp xếp nổi bọt)\n\n#### 2.1. Ý tưởng\n\nBubble Sort so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này lặp lại cho đến khi mảng được sắp xếp. Phần tử lớn nhất sẽ \"nổi\" lên vị trí cuối cùng sau mỗi lượt.\n\n**Hình ảnh trực quan:**\n- Lượt 1: Phần tử lớn nhất \"nổi\" lên cuối\n- Lượt 2: Phần tử lớn thứ hai nổi lên vị trí kế cuối\n- Tiếp tục cho đến khi mảng được sắp xếp\n\n#### 2.2. Thuật toán\n\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # Duyệt qua tất cả các phần tử\n    for i in range(n):\n        # Cờ để tối ưu hóa\n        swapped = False\n        \n        # Phần tử cuối cùng i phần tử đã được sắp xếp\n        for j in range(0, n - i - 1):\n            # So sánh phần tử liền kề\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # Nếu không có hoán đổi nào, mảng đã sắp xếp\n        if not swapped:\n            break\n    \n    return arr\n\n# Test\narr = [64, 34, 25, 12, 22, 11, 90]\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Comparison là phép toán so sánh hai phần tử để xác định mối quan hệ thứ tự giữa chúng (ví dụ: lớn hơn, nhỏ hơn, bằng). Đây là phép toán cơ bản trong các thuật toán sắp xếp comparison-based.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n\n**Mối quan hệ:**\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", bubble_sort(arr.copy()))\n```\n\n#### 2.3. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã được sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1) - In-place\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive (với tối ưu hóa)\n- ❌ Hiệu quả thấp với dữ liệu lớn\n\n#### 2.4. Biến thể: Cocktail Shaker Sort\n\n```python\ndef cocktail_sort(arr):\n    n = len(arr)\n    start = 0\n    end = n - 1\n    swapped = True\n    \n    while swapped:\n        swapped = False\n        \n        # Đi từ trái sang phải\n        for i in range(start, end):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        if not swapped:\n            break\n        \n        swapped = False\n        end -= 1\n        \n        # Đi từ phải sang trái\n        for i in range(end - 1, start - 1, -1):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        start += 1\n    \n    return arr\n```\n\n---\n\n### 3. Selection Sort (Sắp xếp chọn)\n\n#### 3.1. Ý tưởng\n\nSelection Sort chia mảng thành hai phần: phần đã sắp xếp và phần chưa sắp xếp. Trong mỗi bước, thuật toán tìm phần tử nhỏ nhất trong phần chưa sắp xếp và đưa nó vào cuối phần đã sắp xếp.\n\n**Các bước:**\n1. Tìm phần tử nhỏ nhất trong mảng chưa sắp xếp\n2. Hoán đổi nó với phần tử đầu tiên của mảng chưa sắp xếp\n3. Di chuyển ranh giới giữa phần đã sắp xếp và chưa sắp xếp\n4. Lặp lại cho đến khi mảng được sắp xếp\n\n#### 3.2. Thuật toán\n\n```python\ndef selection_sort(arr):\n    n = len(arr)\n    \n    for i in range(n):\n        # Tìm phần tử nhỏ nhất trong phần chưa sắp xếp\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Hoán đổi phần tử nhỏ nhất với phần tử đầu tiên\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    \n    return arr\n\n# Test\narr = [64, 25, 12, 22, 11]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", selection_sort(arr.copy()))\n```\n\n#### 3.3. Minh họa từng bước\n\n```\nMảng: [64, 25, 12, 22, 11]\n\nBước 1: Tìm min = 11, hoán đổi với vị trí 0\n        [11, 25, 12, 22, 64]\n\nBước 2: Tìm min = 12, hoán đổi với vị trí 1\n        [11, 12, 25, 22, 64]\n\nBước 3: Tìm min = 22, hoán đổi với vị trí 2\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n        [11, 12, 22, 25, 64]\n\nBước 4: Tìm min = 25, không cần hoán đổi\n        [11, 12, 22, 25, 64]\n```\n\n#### 3.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n²)\n- **Average case:** O(n²)\n- **Worst case:** O(n²)\n- Số lần so sánh luôn cố định: n(n-1)/2\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ❌ Unstable (có thể làm stable với cài đặt khác)\n- ✅ In-place\n- ❌ Không adaptive\n- ✅ Số lần hoán đổi ít nhất: O(n)\n\n**Ưu điểm:**\n- Đơn giản, dễ hiểu\n- Số lần hoán đổi ít (tốt khi chi phí hoán đổi cao)\n- Hoạt động tốt với mảng nhỏ\n\n**Nhược điểm:**\n- Không hiệu quả với dữ liệu lớn\n- Không tận dụng được dữ liệu đã sắp xếp\n\n---\n\n### 4. Insertion Sort (Sắp xếp chèn)\n\n#### 4.1. Ý tưởng\n\nInsertion Sort xây dựng mảng đã sắp xếp từng phần tử một. Nó giống như cách chúng ta sắp xếp bài trong tay: lấy một lá bài và chèn nó vào đúng vị trí trong phần đã sắp xếp.\n\n**Nguyên lý:**\n1. Bắt đầu từ phần tử thứ hai\n2. So sánh với các phần tử bên trái\n3. Dịch các phần tử lớn hơn sang phải\n4. Chèn phần tử vào vị trí đúng\n\n#### 4.2. Thuật toán\n\n```python\ndef insertion_sort(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        key = arr[i]\n        j = i - 1\n        \n        # Di chuyển các phần tử lớn hơn key sang phải\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        \n        # Chèn key vào vị trí đúng\n        arr[j + 1] = key\n    \n    return arr\n\n# Test\narr = [12, 11, 13, 5, 6]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", insertion_sort(arr.copy()))\n```\n\n#### 4.3. Minh họa từng bước\n\n```\nMảng: [12, 11, 13, 5, 6]\n\nBước 1: key = 11\n        [11, 12, 13, 5, 6]\n\nBước 2: key = 13, không thay đổi\n        [11, 12, 13, 5, 6]\n\nBước 3: key = 5\n        [5, 11, 12, 13, 6]\n\nBước 4: key = 6\n        [5, 6, 11, 12, 13]\n```\n\n#### 4.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive\n- ✅ Online\n\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn."
        },
        "output_without_context": {
            "question": "Khái niệm sắp xếp trong lập trình được định nghĩa là gì?",
            "answer": "Quy trình tổ chức mảng theo thứ tự tăng dần."
        }
    },
    {
        "topic_description": "Chủ đề này tập trung vào hiểu biết về thứ tự toàn phần, bao gồm các thuộc tính như phản đối xứng, bắc cầu và toàn bộ. Học sinh sẽ cần xác định các ví dụ cụ thể và áp dụng các thuộc tính này trong bối cảnh khác nhau. Các câu hỏi sẽ kiểm tra khả năng nhận diện và ví dụ của thứ tự toàn phần.",
        "output_with_context": {
            "question": "Thứ tự toàn phần có thuộc tính nào sau đây không?",
            "answer": "Phản đối xứng",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n### 1. Giới thiệu về Sắp xếp\n\n#### 1.1. Khái niệm\n\nSắp xếp (Sorting) là quá trình sắp đặt các phần tử trong một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một trong những thao tác cơ bản và quan trọng nhất trong khoa học máy tính.\n\n**Tại sao sắp xếp quan trọng?**\n- Giúp tìm kiếm nhanh hơn (Binary Search)\n- Tối ưu hóa các thuật toán khác\n- Cải thiện hiệu suất của database\n- Trực quan hóa và phân tích dữ liệu\n\n#### 1.2. Phân loại thuật toán sắp xếp\n\n**a) Theo phương pháp:**\n- **Comparison-based:** So sánh các phần tử (Bubble, Selection, Insertion, Merge, Quick)\n- **Non-comparison-based:** Không so sánh trực tiếp (Counting, Radix, Bucket)\n\n**b) Theo tính ổn định (Stability):**\n- **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- **Unstable:** Không đảm bảo thứ tự tương đối\n\n**c) Theo bộ nhớ:**\n- **In-place:** Sử dụng O(1) bộ nhớ phụ\n- **Out-of-place:** Cần thêm bộ nhớ phụ\n\n#### 1.3. Các tiêu chí đánh giá\n\n- **Time Complexity:** Độ phức tạp thời gian (Best, Average, Worst case)\n- **Space Complexity:** Độ phức tạp không gian\n- **Stability:** Tính ổn định\n- **Adaptive:** Hiệu quả với dữ liệu đã gần sắp xếp\n- **Online:** Có thể xử lý dữ liệu đến theo thời gian thực\n\n---\n\n### 2. Bubble Sort (Sắp xếp nổi bọt)\n\n#### 2.1. Ý tưởng\n\nBubble Sort so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này lặp lại cho đến khi mảng được sắp xếp. Phần tử lớn nhất sẽ \"nổi\" lên vị trí cuối cùng sau mỗi lượt.\n\n**Hình ảnh trực quan:**\n- Lượt 1: Phần tử lớn nhất \"nổi\" lên cuối\n- Lượt 2: Phần tử lớn thứ hai nổi lên vị trí kế cuối\n- Tiếp tục cho đến khi mảng được sắp xếp\n\n#### 2.2. Thuật toán\n\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # Duyệt qua tất cả các phần tử\n    for i in range(n):\n        # Cờ để tối ưu hóa\n        swapped = False\n        \n        # Phần tử cuối cùng i phần tử đã được sắp xếp\n        for j in range(0, n - i - 1):\n            # So sánh phần tử liền kề\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # Nếu không có hoán đổi nào, mảng đã sắp xếp\n        if not swapped:\n            break\n    \n    return arr\n\n# Test\narr = [64, 34, 25, 12, 22, 11, 90]\n\n**Các khái niệm quan trọng:**\n- Comparison là phép toán so sánh hai phần tử để xác định mối quan hệ thứ tự giữa chúng (ví dụ: lớn hơn, nhỏ hơn, bằng). Đây là phép toán cơ bản trong các thuật toán sắp xếp comparison-based.\n- Stability (tính ổn định) là một tính chất quan trọng của thuật toán sắp xếp, cho biết liệu thuật toán có giữ nguyên thứ tự tương đối ban đầu của các phần tử có giá trị bằng nhau sau khi sắp xếp hay không. Một thuật toán được gọi là \"stable\" (ổn định) nếu nó đảm bảo rằng các phần tử có giá trị bằng nhau sẽ duy trì thứ tự tương đối của chúng trong mảng đã sắp xếp so với mảng ban đầu. Ngược lại, một thuật toán \"unstable\" (không ổn định) không đảm bảo giữ được thứ tự tương đối này, nghĩa là thứ tự của các phần tử bằng nhau có thể bị thay đổi. Các thuật toán ổn định bao gồm Merge Sort, Bubble Sort và Insertion Sort. Trong khi đó, Quicksort, Heap Sort và Selection Sort là các thuật toán không ổn định.\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n\n**Mối quan hệ:**\n- Sorting tối ưu hóa Binary Search bằng cách sắp xếp dữ liệu, cho phép Binary Search hoạt động hiệu quả hơn với độ phức tạp O(log n).\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn.\n\n**Nội dung từ tài liệu:**\n# Học Máy (Machine Learning)\n## Hồi Quy Tuyến Tính (Linear Regression)\nHệ số góc: $\beta_1 = \frac{\\sum_{i=1}^{n}(x_i - \bar{x})(y_i - \bar{y})}{\\sum_{i=1}^{n}(x_i - \bar{x})^2}$\n\nHệ số chặn: $\beta_0 = \bar{y} - \beta_1\bar{x}$\n\nTrong đó $\bar{x}$ và $\bar{y}$ là giá trị trung bình của $x$ và $y$.\n\n**Ví Dụ Minh Họa:**\nGiả sử chúng ta muốn dự đoán giá nhà (triệu đồng) dựa trên diện tích (m²):\n- Dữ liệu: Diện tích [50, 60, 70, 80, 90], Giá [1500, 1800, 2100, 2400, 2700]\n- Sau khi áp dụng OLS, ta có thể tìm được: $y = 300 + 30x$\n- Diễn giải: Giá cơ bản là 300 triệu, mỗi m² tăng thêm 30 triệu\n\n### Hồi Quy Tuyến Tính Bội\n\nKhi xử lý nhiều đặc trưng, phương trình mở rộng thành:\n\n$$y = \beta_0 + \beta_1x_1 + \beta_2x_2 + ... + \beta_nx_n + \\epsilon$$\n\n**Ví dụ:** Dự đoán giá nhà với nhiều yếu tố:\n$$Giá = \beta_0 + \beta_1 \times Diện\\ tích + \beta_2 \times Số\\ phòng + \beta_3 \times Khoảng\\ cách\\ trung\\ tâm$$\n\n**Dạng Ma Trận:**\n$$\\mathbf{y} = \\mathbf{X}\boldsymbol{\beta} + \boldsymbol{\\epsilon}$$\n\nTrong đó:\n- $\\mathbf{y}$ là vector cột của các giá trị mục tiêu (kích thước $m \times 1$)\n- $\\mathbf{X}$ là ma trận đặc trưng (kích thước $m \times (n+1)$), bao gồm cột 1 cho hệ số chặn\n- $\boldsymbol{\beta}$ là vector các hệ số (kích thước $(n+1) \times 1$)\n- $\boldsymbol{\\epsilon}$ là vector sai số\n\n**Nghiệm Dạng Đóng (Closed-form Solution):**\n$$\boldsymbol{\beta} = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y}$$\n\n**Ưu điểm của nghiệm dạng đóng:**\n- Tính toán trực tiếp, không cần lặp\n- Cho kết quả chính xác (không phụ thuộc tốc độ học)\n- Phù hợp khi số lượng đặc trưng nhỏ (< 10,000)\n\n**Nhược điểm:**\n- Phức tạp tính toán: $O(n^3)$ với $n$ là số đặc trưng\n- Yêu cầu $\\mathbf{X}^T\\mathbf{X}$ khả nghịch\n- Không hiệu quả với dữ liệu lớn\n\n### Các Giả Định Của Hồi Quy Tuyến Tính\n\nĐể hồi quy tuyến tính hoạt động tốt, cần thỏa mãn các giả định sau:\n\n**1. Tính Tuyến Tính (Linearity):**\n- Mối quan hệ giữa các đặc trưng và mục tiêu là tuyến tính\n- Kiểm tra: Vẽ biểu đồ phân tán giữa $x$ và $y$\n\n**Các khái niệm quan trọng:**\n- Tính Tuyến Tính (Linearity) là một giả định quan trọng của Hồi Quy Tuyến Tính, cho rằng mối quan hệ giữa các đặc trưng và biến mục tiêu là tuyến tính. Giả định này có thể được kiểm tra bằng cách vẽ biểu đồ phân tán giữa các biến độc lập và biến phụ thuộc.\n\n**Mối quan hệ:**\n- Hồi Quy Tuyến Tính yêu cầu giả định Tính Tuyến Tính, tức là mối quan hệ giữa các đặc trưng và mục tiêu phải là tuyến tính, để hoạt động hiệu quả."
        },
        "output_without_context": {
            "question": "Thứ tự toàn phần có thuộc tính nào sau đây?",
            "answer": "Phản đối xứng, bắc cầu và toàn bộ."
        }
    },
    {
        "topic_description": "Chủ đề này tìm hiểu về hàm gọi lại (callbacks) và cách chúng được sử dụng trong việc sắp xếp các loại dữ liệu khác nhau mà không cần thông tin cụ thể. Học sinh sẽ cần hiểu nguyên lý hoạt động của hàm sort() và các giao diện tương ứng. Câu hỏi có thể kiểm tra sự hiểu biết về cách thức các hàm này hoạt động trong Java và các ngôn ngữ khác.",
        "output_with_context": {
            "question": "Trong Java, hàm sort() sử dụng hàm gọi lại (callback) để xác định thứ tự sắp xếp của các phần tử. Hàm gọi lại này thường nhận hai tham số đại diện cho hai phần tử cần so sánh. Tham số này thường được định nghĩa như thế nào?",
            "answer": "Hàm gọi lại thường được định nghĩa dưới dạng một hàm hoặc biểu thức lambda nhận hai tham số và trả về một giá trị nguyên để xác định thứ tự của chúng.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n### 1. Giới thiệu về Sắp xếp\n\n#### 1.1. Khái niệm\n\nSắp xếp (Sorting) là quá trình sắp đặt các phần tử trong một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một trong những thao tác cơ bản và quan trọng nhất trong khoa học máy tính.\n\n**Tại sao sắp xếp quan trọng?**\n- Giúp tìm kiếm nhanh hơn (Binary Search)\n- Tối ưu hóa các thuật toán khác\n- Cải thiện hiệu suất của database\n- Trực quan hóa và phân tích dữ liệu\n\n#### 1.2. Phân loại thuật toán sắp xếp\n\n**a) Theo phương pháp:**\n- **Comparison-based:** So sánh các phần tử (Bubble, Selection, Insertion, Merge, Quick)\n- **Non-comparison-based:** Không so sánh trực tiếp (Counting, Radix, Bucket)\n\n**b) Theo tính ổn định (Stability):**\n- **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- **Unstable:** Không đảm bảo thứ tự tương đối\n\n**c) Theo bộ nhớ:**\n- **In-place:** Sử dụng O(1) bộ nhớ phụ\n- **Out-of-place:** Cần thêm bộ nhớ phụ\n\n#### 1.3. Các tiêu chí đánh giá\n\n- **Time Complexity:** Độ phức tạp thời gian (Best, Average, Worst case)\n- **Space Complexity:** Độ phức tạp không gian\n- **Stability:** Tính ổn định\n- **Adaptive:** Hiệu quả với dữ liệu đã gần sắp xếp\n- **Online:** Có thể xử lý dữ liệu đến theo thời gian thực\n\n---\n\n### 2. Bubble Sort (Sắp xếp nổi bọt)\n\n#### 2.1. Ý tưởng\n\nBubble Sort so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này lặp lại cho đến khi mảng được sắp xếp. Phần tử lớn nhất sẽ \"nổi\" lên vị trí cuối cùng sau mỗi lượt.\n\n**Hình ảnh trực quan:**\n- Lượt 1: Phần tử lớn nhất \"nổi\" lên cuối\n- Lượt 2: Phần tử lớn thứ hai nổi lên vị trí kế cuối\n- Tiếp tục cho đến khi mảng được sắp xếp\n\n#### 2.2. Thuật toán\n\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # Duyệt qua tất cả các phần tử\n    for i in range(n):\n        # Cờ để tối ưu hóa\n        swapped = False\n        \n        # Phần tử cuối cùng i phần tử đã được sắp xếp\n        for j in range(0, n - i - 1):\n            # So sánh phần tử liền kề\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # Nếu không có hoán đổi nào, mảng đã sắp xếp\n        if not swapped:\n            break\n    \n    return arr\n\n# Test\narr = [64, 34, 25, 12, 22, 11, 90]\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Comparison là phép toán so sánh hai phần tử để xác định mối quan hệ thứ tự giữa chúng (ví dụ: lớn hơn, nhỏ hơn, bằng). Đây là phép toán cơ bản trong các thuật toán sắp xếp comparison-based.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n\n**Mối quan hệ:**\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n        [11, 12, 22, 25, 64]\n\nBước 4: Tìm min = 25, không cần hoán đổi\n        [11, 12, 22, 25, 64]\n```\n\n#### 3.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n²)\n- **Average case:** O(n²)\n- **Worst case:** O(n²)\n- Số lần so sánh luôn cố định: n(n-1)/2\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ❌ Unstable (có thể làm stable với cài đặt khác)\n- ✅ In-place\n- ❌ Không adaptive\n- ✅ Số lần hoán đổi ít nhất: O(n)\n\n**Ưu điểm:**\n- Đơn giản, dễ hiểu\n- Số lần hoán đổi ít (tốt khi chi phí hoán đổi cao)\n- Hoạt động tốt với mảng nhỏ\n\n**Nhược điểm:**\n- Không hiệu quả với dữ liệu lớn\n- Không tận dụng được dữ liệu đã sắp xếp\n\n---\n\n### 4. Insertion Sort (Sắp xếp chèn)\n\n#### 4.1. Ý tưởng\n\nInsertion Sort xây dựng mảng đã sắp xếp từng phần tử một. Nó giống như cách chúng ta sắp xếp bài trong tay: lấy một lá bài và chèn nó vào đúng vị trí trong phần đã sắp xếp.\n\n**Nguyên lý:**\n1. Bắt đầu từ phần tử thứ hai\n2. So sánh với các phần tử bên trái\n3. Dịch các phần tử lớn hơn sang phải\n4. Chèn phần tử vào vị trí đúng\n\n#### 4.2. Thuật toán\n\n```python\ndef insertion_sort(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        key = arr[i]\n        j = i - 1\n        \n        # Di chuyển các phần tử lớn hơn key sang phải\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        \n        # Chèn key vào vị trí đúng\n        arr[j + 1] = key\n    \n    return arr\n\n# Test\narr = [12, 11, 13, 5, 6]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", insertion_sort(arr.copy()))\n```\n\n#### 4.3. Minh họa từng bước\n\n```\nMảng: [12, 11, 13, 5, 6]\n\nBước 1: key = 11\n        [11, 12, 13, 5, 6]\n\nBước 2: key = 13, không thay đổi\n        [11, 12, 13, 5, 6]\n\nBước 3: key = 5\n        [5, 11, 12, 13, 6]\n\nBước 4: key = 6\n        [5, 6, 11, 12, 13]\n```\n\n#### 4.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive\n- ✅ Online\n\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n\n**Mối quan hệ:**\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", bubble_sort(arr.copy()))\n```\n\n#### 2.3. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã được sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1) - In-place\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive (với tối ưu hóa)\n- ❌ Hiệu quả thấp với dữ liệu lớn\n\n#### 2.4. Biến thể: Cocktail Shaker Sort\n\n```python\ndef cocktail_sort(arr):\n    n = len(arr)\n    start = 0\n    end = n - 1\n    swapped = True\n    \n    while swapped:\n        swapped = False\n        \n        # Đi từ trái sang phải\n        for i in range(start, end):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        if not swapped:\n            break\n        \n        swapped = False\n        end -= 1\n        \n        # Đi từ phải sang trái\n        for i in range(end - 1, start - 1, -1):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        start += 1\n    \n    return arr\n```\n\n---\n\n### 3. Selection Sort (Sắp xếp chọn)\n\n#### 3.1. Ý tưởng\n\nSelection Sort chia mảng thành hai phần: phần đã sắp xếp và phần chưa sắp xếp. Trong mỗi bước, thuật toán tìm phần tử nhỏ nhất trong phần chưa sắp xếp và đưa nó vào cuối phần đã sắp xếp.\n\n**Các bước:**\n1. Tìm phần tử nhỏ nhất trong mảng chưa sắp xếp\n2. Hoán đổi nó với phần tử đầu tiên của mảng chưa sắp xếp\n3. Di chuyển ranh giới giữa phần đã sắp xếp và chưa sắp xếp\n4. Lặp lại cho đến khi mảng được sắp xếp\n\n#### 3.2. Thuật toán\n\n```python\ndef selection_sort(arr):\n    n = len(arr)\n    \n    for i in range(n):\n        # Tìm phần tử nhỏ nhất trong phần chưa sắp xếp\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Hoán đổi phần tử nhỏ nhất với phần tử đầu tiên\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    \n    return arr\n\n# Test\narr = [64, 25, 12, 22, 11]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", selection_sort(arr.copy()))\n```\n\n#### 3.3. Minh họa từng bước\n\n```\nMảng: [64, 25, 12, 22, 11]\n\nBước 1: Tìm min = 11, hoán đổi với vị trí 0\n        [11, 25, 12, 22, 64]\n\nBước 2: Tìm min = 12, hoán đổi với vị trí 1\n        [11, 12, 25, 22, 64]\n\nBước 3: Tìm min = 22, hoán đổi với vị trí 2\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn."
        },
        "output_without_context": {
            "question": "Trong Java, hàm nào được sử dụng để sắp xếp một mảng mà không cần thông tin cụ thể về cách sắp xếp, thông qua việc sử dụng hàm gọi lại?",
            "answer": "sort()"
        }
    },
    {
        "topic_description": "Chủ đề này xem xét kỹ thuật sắp xếp chọn (Selection Sort), quy trình hoạt động và ứng dụng của nó. Học sinh sẽ phân tích số lượng so sánh và hoán đổi trong quá trình sắp xếp. Các câu hỏi sẽ kiểm tra cách tính toán số lần so sánh và cách sắp xếp hoạt động trong bài thực hành.",
        "output_with_context": {
            "question": "Trong thuật toán Selection Sort, số lần so sánh tối đa được thực hiện để sắp xếp một mảng có n phần tử là bao nhiêu?",
            "answer": "n(n-1)/2",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n**Ưu điểm:**\n- Đơn giản, dễ cài đặt\n- Hiệu quả với mảng nhỏ hoặc gần như đã sắp xếp\n- Stable và adaptive\n- Online - có thể sắp xếp dữ liệu đến dần dần\n- Ít hoán đổi hơn Bubble Sort\n\n**Nhược điểm:**\n- Không hiệu quả với dữ liệu lớn và ngẫu nhiên\n\n#### 4.5. Tối ưu hóa: Binary Insertion Sort\n\n```python\ndef binary_search(arr, item, start, end):\n    \"\"\"Tìm vị trí chèn bằng Binary Search\"\"\"\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] < item:\n            start = mid + 1\n        elif arr[mid] > item:\n            end = mid - 1\n        else:\n            return mid + 1\n    return start\n\ndef binary_insertion_sort(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        key = arr[i]\n        # Tìm vị trí chèn bằng Binary Search\n        pos = binary_search(arr, key, 0, i - 1)\n        \n        # Dịch chuyển các phần tử\n        arr = arr[:pos] + [key] + arr[pos:i] + arr[i+1:]\n    \n    return arr\n```\n\nGiảm số lần so sánh từ O(n²) xuống O(n log n), nhưng số lần dịch chuyển vẫn là O(n²).\n\n---\n\n### 5. So sánh các thuật toán cơ bản\n\n| Thuật toán | Best | Average | Worst | Space | Stable | Adaptive |\n|------------|------|---------|-------|-------|--------|----------|\n| Bubble Sort | O(n) | O(n²) | O(n²) | O(1) | ✅ | ✅ |\n| Selection Sort | O(n²) | O(n²) | O(n²) | O(1) | ❌ | ❌ |\n| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) | ✅ | ✅ |\n\n#### 5.1. Khi nào sử dụng?\n\n**Bubble Sort:**\n- Mảng nhỏ và gần như đã sắp xếp\n- Mục đích giáo dục\n- Khi cần thuật toán đơn giản nhất\n\n**Selection Sort:**\n- Khi chi phí hoán đổi cao (ít hoán đổi nhất)\n- Mảng nhỏ\n- Khi bộ nhớ phụ bị hạn chế\n\n**Insertion Sort:**\n- Mảng nhỏ (< 50 phần tử)\n- Mảng gần như đã sắp xếp\n- Dữ liệu đến theo thời gian thực (online)\n- Kết hợp với Merge Sort hoặc Quick Sort cho mảng con nhỏ\n\n#### 5.2. Code so sánh hiệu năng\n\n```python\nimport time\nimport random\n\ndef compare_sorting_algorithms(size=1000):\n    # Tạo mảng ngẫu nhiên\n    arr = [random.randint(1, 1000) for _ in range(size)]\n    \n    algorithms = {\n        'Bubble Sort': bubble_sort,\n        'Selection Sort': selection_sort,\n        'Insertion Sort': insertion_sort\n    }\n    \n    results = {}\n    \n    for name, func in algorithms.items():\n        test_arr = arr.copy()\n        start_time = time.time()\n        func(test_arr)\n        end_time = time.time()\n        results[name] = end_time - start_time\n    \n    # In kết quả\n    print(f\"\nThời gian thực thi với mảng {size} phần tử:\")\n    for name, exec_time in sorted(results.items(), key=lambda x: x[1]):\n        print(f\"{name:20s}: {exec_time:.6f} giây\")\n\n# Test với các kích thước khác nhau\n\n**Các khái niệm quan trọng:**\n- Selection Sort là một thuật toán sắp xếp cơ bản, hoạt động bằng cách chia mảng thành hai phần: phần đã sắp xếp và phần chưa sắp xếp. Trong mỗi bước lặp, thuật toán tìm phần tử nhỏ nhất (hoặc lớn nhất) trong phần chưa sắp xếp và hoán đổi nó với phần tử đầu tiên của phần chưa sắp xếp, sau đó mở rộng phần đã sắp xếp. Quá trình này lặp đi lặp lại cho đến khi toàn bộ mảng được sắp xếp, đảm bảo rằng sau mỗi bước, một phần tử đã được đặt đúng vị trí cuối cùng của nó. Thuật toán này đơn giản, dễ hiểu và có ưu điểm là thực hiện số lần hoán đổi ít nhất. Độ phức tạp thời gian của Selection Sort là O(n²) trong cả trường hợp tốt nhất, trung bình và xấu nhất, trong khi độ phức tạp không gian là O(1).\n\n**Mối quan hệ:**\n- Selection Sort sử dụng phép toán Hoán đổi để đặt phần tử nhỏ nhất vào đúng vị trí của nó trong mảng.\n- Selection Sort có số lần so sánh luôn cố định là n(n-1)/2, đây là một đặc điểm của thuật toán này.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n        [11, 12, 22, 25, 64]\n\nBước 4: Tìm min = 25, không cần hoán đổi\n        [11, 12, 22, 25, 64]\n```\n\n#### 3.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n²)\n- **Average case:** O(n²)\n- **Worst case:** O(n²)\n- Số lần so sánh luôn cố định: n(n-1)/2\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ❌ Unstable (có thể làm stable với cài đặt khác)\n- ✅ In-place\n- ❌ Không adaptive\n- ✅ Số lần hoán đổi ít nhất: O(n)\n\n**Ưu điểm:**\n- Đơn giản, dễ hiểu\n- Số lần hoán đổi ít (tốt khi chi phí hoán đổi cao)\n- Hoạt động tốt với mảng nhỏ\n\n**Nhược điểm:**\n- Không hiệu quả với dữ liệu lớn\n- Không tận dụng được dữ liệu đã sắp xếp\n\n---\n\n### 4. Insertion Sort (Sắp xếp chèn)\n\n#### 4.1. Ý tưởng\n\nInsertion Sort xây dựng mảng đã sắp xếp từng phần tử một. Nó giống như cách chúng ta sắp xếp bài trong tay: lấy một lá bài và chèn nó vào đúng vị trí trong phần đã sắp xếp.\n\n**Nguyên lý:**\n1. Bắt đầu từ phần tử thứ hai\n2. So sánh với các phần tử bên trái\n3. Dịch các phần tử lớn hơn sang phải\n4. Chèn phần tử vào vị trí đúng\n\n#### 4.2. Thuật toán\n\n```python\ndef insertion_sort(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        key = arr[i]\n        j = i - 1\n        \n        # Di chuyển các phần tử lớn hơn key sang phải\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        \n        # Chèn key vào vị trí đúng\n        arr[j + 1] = key\n    \n    return arr\n\n# Test\narr = [12, 11, 13, 5, 6]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", insertion_sort(arr.copy()))\n```\n\n#### 4.3. Minh họa từng bước\n\n```\nMảng: [12, 11, 13, 5, 6]\n\nBước 1: key = 11\n        [11, 12, 13, 5, 6]\n\nBước 2: key = 13, không thay đổi\n        [11, 12, 13, 5, 6]\n\nBước 3: key = 5\n        [5, 11, 12, 13, 6]\n\nBước 4: key = 6\n        [5, 6, 11, 12, 13]\n```\n\n#### 4.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive\n- ✅ Online\n\n\n**Các khái niệm quan trọng:**\n- Selection Sort là một thuật toán sắp xếp cơ bản, hoạt động bằng cách chia mảng thành hai phần: phần đã sắp xếp và phần chưa sắp xếp. Trong mỗi bước lặp, thuật toán tìm phần tử nhỏ nhất (hoặc lớn nhất) trong phần chưa sắp xếp và hoán đổi nó với phần tử đầu tiên của phần chưa sắp xếp, sau đó mở rộng phần đã sắp xếp. Quá trình này lặp đi lặp lại cho đến khi toàn bộ mảng được sắp xếp, đảm bảo rằng sau mỗi bước, một phần tử đã được đặt đúng vị trí cuối cùng của nó. Thuật toán này đơn giản, dễ hiểu và có ưu điểm là thực hiện số lần hoán đổi ít nhất. Độ phức tạp thời gian của Selection Sort là O(n²) trong cả trường hợp tốt nhất, trung bình và xấu nhất, trong khi độ phức tạp không gian là O(1).\n- Số lần so sánh trong Selection Sort luôn cố định là n(n-1)/2, với n là số phần tử trong mảng. Công thức này thể hiện rằng thuật toán luôn thực hiện một số lượng so sánh nhất định bất kể trạng thái ban đầu của mảng.\n\n**Mối quan hệ:**\n- Selection Sort sử dụng phép toán Hoán đổi để đặt phần tử nhỏ nhất vào đúng vị trí của nó trong mảng.\n- Selection Sort có số lần so sánh luôn cố định là n(n-1)/2, đây là một đặc điểm của thuật toán này.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", bubble_sort(arr.copy()))\n```\n\n#### 2.3. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã được sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1) - In-place\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive (với tối ưu hóa)\n- ❌ Hiệu quả thấp với dữ liệu lớn\n\n#### 2.4. Biến thể: Cocktail Shaker Sort\n\n```python\ndef cocktail_sort(arr):\n    n = len(arr)\n    start = 0\n    end = n - 1\n    swapped = True\n    \n    while swapped:\n        swapped = False\n        \n        # Đi từ trái sang phải\n        for i in range(start, end):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        if not swapped:\n            break\n        \n        swapped = False\n        end -= 1\n        \n        # Đi từ phải sang trái\n        for i in range(end - 1, start - 1, -1):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        start += 1\n    \n    return arr\n```\n\n---\n\n### 3. Selection Sort (Sắp xếp chọn)\n\n#### 3.1. Ý tưởng\n\nSelection Sort chia mảng thành hai phần: phần đã sắp xếp và phần chưa sắp xếp. Trong mỗi bước, thuật toán tìm phần tử nhỏ nhất trong phần chưa sắp xếp và đưa nó vào cuối phần đã sắp xếp.\n\n**Các bước:**\n1. Tìm phần tử nhỏ nhất trong mảng chưa sắp xếp\n2. Hoán đổi nó với phần tử đầu tiên của mảng chưa sắp xếp\n3. Di chuyển ranh giới giữa phần đã sắp xếp và chưa sắp xếp\n4. Lặp lại cho đến khi mảng được sắp xếp\n\n#### 3.2. Thuật toán\n\n```python\ndef selection_sort(arr):\n    n = len(arr)\n    \n    for i in range(n):\n        # Tìm phần tử nhỏ nhất trong phần chưa sắp xếp\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Hoán đổi phần tử nhỏ nhất với phần tử đầu tiên\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    \n    return arr\n\n# Test\narr = [64, 25, 12, 22, 11]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", selection_sort(arr.copy()))\n```\n\n#### 3.3. Minh họa từng bước\n\n```\nMảng: [64, 25, 12, 22, 11]\n\nBước 1: Tìm min = 11, hoán đổi với vị trí 0\n        [11, 25, 12, 22, 64]\n\nBước 2: Tìm min = 12, hoán đổi với vị trí 1\n        [11, 12, 25, 22, 64]\n\nBước 3: Tìm min = 22, hoán đổi với vị trí 2\n\n**Các khái niệm quan trọng:**\n- Selection Sort là một thuật toán sắp xếp cơ bản, hoạt động bằng cách chia mảng thành hai phần: phần đã sắp xếp và phần chưa sắp xếp. Trong mỗi bước lặp, thuật toán tìm phần tử nhỏ nhất (hoặc lớn nhất) trong phần chưa sắp xếp và hoán đổi nó với phần tử đầu tiên của phần chưa sắp xếp, sau đó mở rộng phần đã sắp xếp. Quá trình này lặp đi lặp lại cho đến khi toàn bộ mảng được sắp xếp, đảm bảo rằng sau mỗi bước, một phần tử đã được đặt đúng vị trí cuối cùng của nó. Thuật toán này đơn giản, dễ hiểu và có ưu điểm là thực hiện số lần hoán đổi ít nhất. Độ phức tạp thời gian của Selection Sort là O(n²) trong cả trường hợp tốt nhất, trung bình và xấu nhất, trong khi độ phức tạp không gian là O(1).\n\n**Mối quan hệ:**\n- Selection Sort sử dụng phép toán Hoán đổi để đặt phần tử nhỏ nhất vào đúng vị trí của nó trong mảng.\n- Selection Sort có số lần so sánh luôn cố định là n(n-1)/2, đây là một đặc điểm của thuật toán này.\n- Selection Sort giải quyết bài toán Sorting bằng cách tìm và đặt các phần tử vào đúng vị trí của chúng.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n### 1. Giới thiệu về Sắp xếp\n\n#### 1.1. Khái niệm\n\nSắp xếp (Sorting) là quá trình sắp đặt các phần tử trong một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một trong những thao tác cơ bản và quan trọng nhất trong khoa học máy tính.\n\n**Tại sao sắp xếp quan trọng?**\n- Giúp tìm kiếm nhanh hơn (Binary Search)\n- Tối ưu hóa các thuật toán khác\n- Cải thiện hiệu suất của database\n- Trực quan hóa và phân tích dữ liệu\n\n#### 1.2. Phân loại thuật toán sắp xếp\n\n**a) Theo phương pháp:**\n- **Comparison-based:** So sánh các phần tử (Bubble, Selection, Insertion, Merge, Quick)\n- **Non-comparison-based:** Không so sánh trực tiếp (Counting, Radix, Bucket)\n\n**b) Theo tính ổn định (Stability):**\n- **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- **Unstable:** Không đảm bảo thứ tự tương đối\n\n**c) Theo bộ nhớ:**\n- **In-place:** Sử dụng O(1) bộ nhớ phụ\n- **Out-of-place:** Cần thêm bộ nhớ phụ\n\n#### 1.3. Các tiêu chí đánh giá\n\n- **Time Complexity:** Độ phức tạp thời gian (Best, Average, Worst case)\n- **Space Complexity:** Độ phức tạp không gian\n- **Stability:** Tính ổn định\n- **Adaptive:** Hiệu quả với dữ liệu đã gần sắp xếp\n- **Online:** Có thể xử lý dữ liệu đến theo thời gian thực\n\n---\n\n### 2. Bubble Sort (Sắp xếp nổi bọt)\n\n#### 2.1. Ý tưởng\n\nBubble Sort so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này lặp lại cho đến khi mảng được sắp xếp. Phần tử lớn nhất sẽ \"nổi\" lên vị trí cuối cùng sau mỗi lượt.\n\n**Hình ảnh trực quan:**\n- Lượt 1: Phần tử lớn nhất \"nổi\" lên cuối\n- Lượt 2: Phần tử lớn thứ hai nổi lên vị trí kế cuối\n- Tiếp tục cho đến khi mảng được sắp xếp\n\n#### 2.2. Thuật toán\n\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # Duyệt qua tất cả các phần tử\n    for i in range(n):\n        # Cờ để tối ưu hóa\n        swapped = False\n        \n        # Phần tử cuối cùng i phần tử đã được sắp xếp\n        for j in range(0, n - i - 1):\n            # So sánh phần tử liền kề\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # Nếu không có hoán đổi nào, mảng đã sắp xếp\n        if not swapped:\n            break\n    \n    return arr\n\n# Test\narr = [64, 34, 25, 12, 22, 11, 90]\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Selection Sort giải quyết bài toán Sorting bằng cách tìm và đặt các phần tử vào đúng vị trí của chúng."
        },
        "output_without_context": {
            "question": "Trong phương pháp sắp xếp chọn, số lần so sánh tối đa cần thực hiện để sắp xếp một mảng có n phần tử là bao nhiêu?",
            "answer": "n(n-1)/2"
        }
    },
    {
        "topic_description": "Chủ đề này trình bày về sắp xếp chèn (Insertion Sort), quy trình và các trường hợp hoạt động (tốt nhất, xấu nhất, trung bình). Học sinh sẽ cần tính toán số lần so sánh và hoán đổi trong các trường hợp khác nhau. Câu hỏi sẽ kiểm tra khả năng phân tích và so sánh hiệu suất của các loại sắp xếp khác nhau.",
        "output_with_context": {
            "question": "So sánh độ phức tạp thời gian của Insertion Sort trong trường hợp tốt nhất và trường hợp xấu nhất. Kết quả nào là chính xác?",
            "answer": "Trường hợp tốt nhất là O(n), trường hợp xấu nhất là O(n²).",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n        [11, 12, 22, 25, 64]\n\nBước 4: Tìm min = 25, không cần hoán đổi\n        [11, 12, 22, 25, 64]\n```\n\n#### 3.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n²)\n- **Average case:** O(n²)\n- **Worst case:** O(n²)\n- Số lần so sánh luôn cố định: n(n-1)/2\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ❌ Unstable (có thể làm stable với cài đặt khác)\n- ✅ In-place\n- ❌ Không adaptive\n- ✅ Số lần hoán đổi ít nhất: O(n)\n\n**Ưu điểm:**\n- Đơn giản, dễ hiểu\n- Số lần hoán đổi ít (tốt khi chi phí hoán đổi cao)\n- Hoạt động tốt với mảng nhỏ\n\n**Nhược điểm:**\n- Không hiệu quả với dữ liệu lớn\n- Không tận dụng được dữ liệu đã sắp xếp\n\n---\n\n### 4. Insertion Sort (Sắp xếp chèn)\n\n#### 4.1. Ý tưởng\n\nInsertion Sort xây dựng mảng đã sắp xếp từng phần tử một. Nó giống như cách chúng ta sắp xếp bài trong tay: lấy một lá bài và chèn nó vào đúng vị trí trong phần đã sắp xếp.\n\n**Nguyên lý:**\n1. Bắt đầu từ phần tử thứ hai\n2. So sánh với các phần tử bên trái\n3. Dịch các phần tử lớn hơn sang phải\n4. Chèn phần tử vào vị trí đúng\n\n#### 4.2. Thuật toán\n\n```python\ndef insertion_sort(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        key = arr[i]\n        j = i - 1\n        \n        # Di chuyển các phần tử lớn hơn key sang phải\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        \n        # Chèn key vào vị trí đúng\n        arr[j + 1] = key\n    \n    return arr\n\n# Test\narr = [12, 11, 13, 5, 6]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", insertion_sort(arr.copy()))\n```\n\n#### 4.3. Minh họa từng bước\n\n```\nMảng: [12, 11, 13, 5, 6]\n\nBước 1: key = 11\n        [11, 12, 13, 5, 6]\n\nBước 2: key = 13, không thay đổi\n        [11, 12, 13, 5, 6]\n\nBước 3: key = 5\n        [5, 11, 12, 13, 6]\n\nBước 4: key = 6\n        [5, 6, 11, 12, 13]\n```\n\n#### 4.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive\n- ✅ Online\n\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n- Insertion Sort là một thuật toán sắp xếp đơn giản, hoạt động bằng cách xây dựng mảng đã sắp xếp từng phần tử một. Thuật toán này lặp qua mảng, lấy từng phần tử từ phần chưa sắp xếp và chèn nó vào đúng vị trí trong phần đã sắp xếp. Nó giống như cách sắp xếp bài trong tay. Insertion Sort là một thuật toán stable (ổn định) và adaptive (thích ứng), hiệu quả cho các tập dữ liệu nhỏ hoặc dữ liệu đã gần sắp xếp, và có khả năng xử lý dữ liệu online. Về độ phức tạp thời gian, best case là O(n) (khi mảng đã sắp xếp), còn average case và worst case đều là O(n²). Độ phức tạp không gian là O(1) vì đây là thuật toán tại chỗ (in-place).\n\n**Mối quan hệ:**\n- Insertion Sort giải quyết bài toán Sorting bằng cách chèn từng phần tử vào đúng vị trí trong phần đã sắp xếp của mảng.\n- Insertion Sort có độ phức tạp thời gian O(n²) trong Average case và Worst case (khi mảng sắp xếp ngược), do mỗi phần tử có thể phải so sánh và dịch chuyển qua tất cả các phần tử đã sắp xếp trước đó.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n**Ưu điểm:**\n- Đơn giản, dễ cài đặt\n- Hiệu quả với mảng nhỏ hoặc gần như đã sắp xếp\n- Stable và adaptive\n- Online - có thể sắp xếp dữ liệu đến dần dần\n- Ít hoán đổi hơn Bubble Sort\n\n**Nhược điểm:**\n- Không hiệu quả với dữ liệu lớn và ngẫu nhiên\n\n#### 4.5. Tối ưu hóa: Binary Insertion Sort\n\n```python\ndef binary_search(arr, item, start, end):\n    \"\"\"Tìm vị trí chèn bằng Binary Search\"\"\"\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] < item:\n            start = mid + 1\n        elif arr[mid] > item:\n            end = mid - 1\n        else:\n            return mid + 1\n    return start\n\ndef binary_insertion_sort(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        key = arr[i]\n        # Tìm vị trí chèn bằng Binary Search\n        pos = binary_search(arr, key, 0, i - 1)\n        \n        # Dịch chuyển các phần tử\n        arr = arr[:pos] + [key] + arr[pos:i] + arr[i+1:]\n    \n    return arr\n```\n\nGiảm số lần so sánh từ O(n²) xuống O(n log n), nhưng số lần dịch chuyển vẫn là O(n²).\n\n---\n\n### 5. So sánh các thuật toán cơ bản\n\n| Thuật toán | Best | Average | Worst | Space | Stable | Adaptive |\n|------------|------|---------|-------|-------|--------|----------|\n| Bubble Sort | O(n) | O(n²) | O(n²) | O(1) | ✅ | ✅ |\n| Selection Sort | O(n²) | O(n²) | O(n²) | O(1) | ❌ | ❌ |\n| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) | ✅ | ✅ |\n\n#### 5.1. Khi nào sử dụng?\n\n**Bubble Sort:**\n- Mảng nhỏ và gần như đã sắp xếp\n- Mục đích giáo dục\n- Khi cần thuật toán đơn giản nhất\n\n**Selection Sort:**\n- Khi chi phí hoán đổi cao (ít hoán đổi nhất)\n- Mảng nhỏ\n- Khi bộ nhớ phụ bị hạn chế\n\n**Insertion Sort:**\n- Mảng nhỏ (< 50 phần tử)\n- Mảng gần như đã sắp xếp\n- Dữ liệu đến theo thời gian thực (online)\n- Kết hợp với Merge Sort hoặc Quick Sort cho mảng con nhỏ\n\n#### 5.2. Code so sánh hiệu năng\n\n```python\nimport time\nimport random\n\ndef compare_sorting_algorithms(size=1000):\n    # Tạo mảng ngẫu nhiên\n    arr = [random.randint(1, 1000) for _ in range(size)]\n    \n    algorithms = {\n        'Bubble Sort': bubble_sort,\n        'Selection Sort': selection_sort,\n        'Insertion Sort': insertion_sort\n    }\n    \n    results = {}\n    \n    for name, func in algorithms.items():\n        test_arr = arr.copy()\n        start_time = time.time()\n        func(test_arr)\n        end_time = time.time()\n        results[name] = end_time - start_time\n    \n    # In kết quả\n    print(f\"\nThời gian thực thi với mảng {size} phần tử:\")\n    for name, exec_time in sorted(results.items(), key=lambda x: x[1]):\n        print(f\"{name:20s}: {exec_time:.6f} giây\")\n\n# Test với các kích thước khác nhau\n\n**Các khái niệm quan trọng:**\n- Insertion Sort là một thuật toán sắp xếp đơn giản, hoạt động bằng cách xây dựng mảng đã sắp xếp từng phần tử một. Thuật toán này lặp qua mảng, lấy từng phần tử từ phần chưa sắp xếp và chèn nó vào đúng vị trí trong phần đã sắp xếp. Nó giống như cách sắp xếp bài trong tay. Insertion Sort là một thuật toán stable (ổn định) và adaptive (thích ứng), hiệu quả cho các tập dữ liệu nhỏ hoặc dữ liệu đã gần sắp xếp, và có khả năng xử lý dữ liệu online. Về độ phức tạp thời gian, best case là O(n) (khi mảng đã sắp xếp), còn average case và worst case đều là O(n²). Độ phức tạp không gian là O(1) vì đây là thuật toán tại chỗ (in-place).\n\n**Mối quan hệ:**\n- Insertion Sort có độ phức tạp thời gian O(n²) trong Average case và Worst case (khi mảng sắp xếp ngược), do mỗi phần tử có thể phải so sánh và dịch chuyển qua tất cả các phần tử đã sắp xếp trước đó.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\nfor size in [100, 500, 1000]:\n    compare_sorting_algorithms(size)\n```\n\n#### 5.3. Ứng dụng thực tế\n\n**1. Sắp xếp trong Database:**\n- Sử dụng Insertion Sort cho dữ liệu nhỏ\n- Kết hợp với các thuật toán nâng cao\n\n**2. Sắp xếp trong thư viện:**\n```python\n# Python's sorted() và list.sort() sử dụng Timsort\n# (kết hợp Merge Sort và Insertion Sort)\n\n# Sắp xếp cơ bản\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6]\nsorted_numbers = sorted(numbers)\n\n# Sắp xếp với key function\nstudents = [\n    {'name': 'An', 'score': 85},\n    {'name': 'Bình', 'score': 92},\n    {'name': 'Chi', 'score': 78}\n]\nsorted_students = sorted(students, key=lambda x: x['score'], reverse=True)\n```\n\n**3. Sắp xếp custom objects:**\n```python\nclass Student:\n    def __init__(self, name, grade):\n        self.name = name\n        self.grade = grade\n    \n    def __lt__(self, other):\n        return self.grade < other.grade\n    \n    def __repr__(self):\n        return f\"Student({self.name}, {self.grade})\"\n\nstudents = [Student(\"An\", 85), Student(\"Bình\", 92), Student(\"Chi\", 78)]\nsorted_students = insertion_sort(students)\nprint(sorted_students)\n```\n\n---\n\n### 6. Tối ưu hóa và Thủ thuật\n\n#### 6.1. Early termination (Dừng sớm)\n\n```python\ndef optimized_bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:  # Dừng nếu không có hoán đổi\n            break\n    return arr\n```\n\n#### 6.2. Giảm số lần hoán đổi\n\n```python\ndef optimized_insertion_sort(arr):\n    \"\"\"Sử dụng shifting thay vì swapping\"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]  # Shift thay vì swap\n            j -= 1\n        arr[j + 1] = key\n    return arr\n```\n\n#### 6.3. Hybrid approach\n\n```python\ndef hybrid_sort(arr, threshold=10):\n    \"\"\"Sử dụng Insertion Sort cho mảng nhỏ\"\"\"\n    if len(arr) <= threshold:\n        return insertion_sort(arr)\n    else:\n        # Sử dụng thuật toán khác cho mảng lớn\n        return sorted(arr)  # Placeholder\n```\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Insertion Sort là một thuật toán sắp xếp đơn giản, hoạt động bằng cách xây dựng mảng đã sắp xếp từng phần tử một. Thuật toán này lặp qua mảng, lấy từng phần tử từ phần chưa sắp xếp và chèn nó vào đúng vị trí trong phần đã sắp xếp. Nó giống như cách sắp xếp bài trong tay. Insertion Sort là một thuật toán stable (ổn định) và adaptive (thích ứng), hiệu quả cho các tập dữ liệu nhỏ hoặc dữ liệu đã gần sắp xếp, và có khả năng xử lý dữ liệu online. Về độ phức tạp thời gian, best case là O(n) (khi mảng đã sắp xếp), còn average case và worst case đều là O(n²). Độ phức tạp không gian là O(1) vì đây là thuật toán tại chỗ (in-place).\n\n**Mối quan hệ:**\n- Insertion Sort có độ phức tạp thời gian O(n²) trong Average case và Worst case (khi mảng sắp xếp ngược), do mỗi phần tử có thể phải so sánh và dịch chuyển qua tất cả các phần tử đã sắp xếp trước đó.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", bubble_sort(arr.copy()))\n```\n\n#### 2.3. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã được sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1) - In-place\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive (với tối ưu hóa)\n- ❌ Hiệu quả thấp với dữ liệu lớn\n\n#### 2.4. Biến thể: Cocktail Shaker Sort\n\n```python\ndef cocktail_sort(arr):\n    n = len(arr)\n    start = 0\n    end = n - 1\n    swapped = True\n    \n    while swapped:\n        swapped = False\n        \n        # Đi từ trái sang phải\n        for i in range(start, end):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        if not swapped:\n            break\n        \n        swapped = False\n        end -= 1\n        \n        # Đi từ phải sang trái\n        for i in range(end - 1, start - 1, -1):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        start += 1\n    \n    return arr\n```\n\n---\n\n### 3. Selection Sort (Sắp xếp chọn)\n\n#### 3.1. Ý tưởng\n\nSelection Sort chia mảng thành hai phần: phần đã sắp xếp và phần chưa sắp xếp. Trong mỗi bước, thuật toán tìm phần tử nhỏ nhất trong phần chưa sắp xếp và đưa nó vào cuối phần đã sắp xếp.\n\n**Các bước:**\n1. Tìm phần tử nhỏ nhất trong mảng chưa sắp xếp\n2. Hoán đổi nó với phần tử đầu tiên của mảng chưa sắp xếp\n3. Di chuyển ranh giới giữa phần đã sắp xếp và chưa sắp xếp\n4. Lặp lại cho đến khi mảng được sắp xếp\n\n#### 3.2. Thuật toán\n\n```python\ndef selection_sort(arr):\n    n = len(arr)\n    \n    for i in range(n):\n        # Tìm phần tử nhỏ nhất trong phần chưa sắp xếp\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Hoán đổi phần tử nhỏ nhất với phần tử đầu tiên\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    \n    return arr\n\n# Test\narr = [64, 25, 12, 22, 11]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", selection_sort(arr.copy()))\n```\n\n#### 3.3. Minh họa từng bước\n\n```\nMảng: [64, 25, 12, 22, 11]\n\nBước 1: Tìm min = 11, hoán đổi với vị trí 0\n        [11, 25, 12, 22, 64]\n\nBước 2: Tìm min = 12, hoán đổi với vị trí 1\n        [11, 12, 25, 22, 64]\n\nBước 3: Tìm min = 22, hoán đổi với vị trí 2\n\n**Các khái niệm quan trọng:**\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Insertion Sort giải quyết bài toán Sorting bằng cách chèn từng phần tử vào đúng vị trí trong phần đã sắp xếp của mảng.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n### 1. Giới thiệu về Sắp xếp\n\n#### 1.1. Khái niệm\n\nSắp xếp (Sorting) là quá trình sắp đặt các phần tử trong một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một trong những thao tác cơ bản và quan trọng nhất trong khoa học máy tính.\n\n**Tại sao sắp xếp quan trọng?**\n- Giúp tìm kiếm nhanh hơn (Binary Search)\n- Tối ưu hóa các thuật toán khác\n- Cải thiện hiệu suất của database\n- Trực quan hóa và phân tích dữ liệu\n\n#### 1.2. Phân loại thuật toán sắp xếp\n\n**a) Theo phương pháp:**\n- **Comparison-based:** So sánh các phần tử (Bubble, Selection, Insertion, Merge, Quick)\n- **Non-comparison-based:** Không so sánh trực tiếp (Counting, Radix, Bucket)\n\n**b) Theo tính ổn định (Stability):**\n- **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- **Unstable:** Không đảm bảo thứ tự tương đối\n\n**c) Theo bộ nhớ:**\n- **In-place:** Sử dụng O(1) bộ nhớ phụ\n- **Out-of-place:** Cần thêm bộ nhớ phụ\n\n#### 1.3. Các tiêu chí đánh giá\n\n- **Time Complexity:** Độ phức tạp thời gian (Best, Average, Worst case)\n- **Space Complexity:** Độ phức tạp không gian\n- **Stability:** Tính ổn định\n- **Adaptive:** Hiệu quả với dữ liệu đã gần sắp xếp\n- **Online:** Có thể xử lý dữ liệu đến theo thời gian thực\n\n---\n\n### 2. Bubble Sort (Sắp xếp nổi bọt)\n\n#### 2.1. Ý tưởng\n\nBubble Sort so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này lặp lại cho đến khi mảng được sắp xếp. Phần tử lớn nhất sẽ \"nổi\" lên vị trí cuối cùng sau mỗi lượt.\n\n**Hình ảnh trực quan:**\n- Lượt 1: Phần tử lớn nhất \"nổi\" lên cuối\n- Lượt 2: Phần tử lớn thứ hai nổi lên vị trí kế cuối\n- Tiếp tục cho đến khi mảng được sắp xếp\n\n#### 2.2. Thuật toán\n\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # Duyệt qua tất cả các phần tử\n    for i in range(n):\n        # Cờ để tối ưu hóa\n        swapped = False\n        \n        # Phần tử cuối cùng i phần tử đã được sắp xếp\n        for j in range(0, n - i - 1):\n            # So sánh phần tử liền kề\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # Nếu không có hoán đổi nào, mảng đã sắp xếp\n        if not swapped:\n            break\n    \n    return arr\n\n# Test\narr = [64, 34, 25, 12, 22, 11, 90]\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Insertion Sort giải quyết bài toán Sorting bằng cách chèn từng phần tử vào đúng vị trí trong phần đã sắp xếp của mảng."
        },
        "output_without_context": {
            "question": "So với các thuật toán sắp xếp khác, sắp xếp chèn (Insertion Sort) có hiệu suất như thế nào trong trường hợp dữ liệu đã được sắp xếp trước?",
            "answer": "Sắp xếp chèn có hiệu suất tốt nhất với độ phức tạp O(n) trong trường hợp dữ liệu đã được sắp xếp."
        }
    },
    {
        "topic_description": "Chủ đề này tích hợp kiến thức từ tuần trước về Stack và Queue với các phương pháp sắp xếp. Học sinh sẽ cần liên kết cách Stack có thể được áp dụng trong các thuật toán sắp xếp và phân tích hiệu suất. Câu hỏi sẽ kiểm tra kỹ năng áp dụng và phân tích giữa hai khái niệm.",
        "output_with_context": {
            "question": "Trong thuật toán sắp xếp nào, Stack được sử dụng để lưu trữ các phần tử tạm thời trong quá trình xử lý, giúp thực hiện việc sắp xếp theo thứ tự LIFO?",
            "answer": "Thuật toán Quick Sort",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return result\n\n# Test\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\nprint(bfs(graph, 'A'))  # ['A', 'B', 'C', 'D', 'E', 'F']\n```\n\n**b) Quản lý tài nguyên chia sẻ:**\n- CPU scheduling\n- Disk scheduling\n- Printer queue\n\n**c) Xử lý bất đồng bộ:**\n- Message queue trong các hệ thống phân tán\n- Event handling trong GUI\n\n**d) Cache implementation:**\n- LRU (Least Recently Used) cache sử dụng kết hợp queue và hash map\n\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n```\n\n#### 2.6. So sánh Stack và Queue\n\n| Đặc điểm | Stack | Queue |\n|----------|-------|-------|\n| Nguyên tắc | LIFO | FIFO |\n| Thao tác chính | Push, Pop | Enqueue, Dequeue |\n| Truy cập | Chỉ ở đỉnh (top) | Ở đầu (front) và cuối (rear) |\n| Ứng dụng | Backtracking, Expression evaluation | BFS, Scheduling |\n| Cài đặt | Array, Linked List | Array (Circular), Linked List |\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n\n**Mối quan hệ:**\n- Stack và Queue là hai cấu trúc dữ liệu tuyến tính cơ bản có nguyên tắc hoạt động và ứng dụng khác nhau.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\n# Test\nprint(is_valid_parentheses(\"()[]{}\"))  # True\nprint(is_valid_parentheses(\"([)]\"))    # False\n```\n\n**b) Chuyển đổi biểu thức Infix sang Postfix:**\n\n```python\ndef infix_to_postfix(expression):\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    stack = []\n    output = []\n    \n    for char in expression:\n        if char.isalnum():  # Toán hạng\n            output.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output.append(stack.pop())\n            stack.pop()  # Loại bỏ '('\n        else:  # Toán tử\n            while (stack and stack[-1] != '(' and\n                   precedence.get(stack[-1], 0) >= precedence.get(char, 0)):\n                output.append(stack.pop())\n            stack.append(char)\n    \n    while stack:\n        output.append(stack.pop())\n    \n    return ''.join(output)\n\n# Test\nprint(infix_to_postfix(\"A+B*C\"))  # ABC*+\n```\n\n**c) Tính giá trị biểu thức Postfix:**\n\n```python\ndef evaluate_postfix(expression):\n    stack = []\n    \n    for char in expression:\n        if char.isdigit():\n            stack.append(int(char))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            \n            if char == '+':\n                stack.append(a + b)\n            elif char == '-':\n                stack.append(a - b)\n            elif char == '*':\n                stack.append(a * b)\n            elif char == '/':\n                stack.append(a // b)\n    \n    return stack.pop()\n\n# Test\nprint(evaluate_postfix(\"23*5+\"))  # 11\n```\n\n**d) Thuật toán quay lui (Backtracking):**\nStack được sử dụng trong các thuật toán quay lui như giải mê cung, N-Queens, sudoku solver.\n\n**e) Đánh giá biểu thức số học và biên dịch:**\nCompiler sử dụng stack để parse và đánh giá các biểu thức.\n\n---\n\n### 2. Queue (Hàng đợi)\n\n#### 2.1. Khái niệm cơ bản\n\nQueue là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **FIFO (First In First Out)** - \"vào trước ra trước\". Phần tử được thêm vào đầu tiên sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Hàng người xếp hàng mua vé: Người đến trước được phục vụ trước\n- Hàng đợi in ấn: Tài liệu gửi in trước sẽ được in trước\n- Hàng đợi xử lý trong hệ thống: CPU scheduling, disk scheduling\n\n#### 2.2. Các thao tác cơ bản\n\n**a) Enqueue (Thêm vào):** Thêm phần tử vào cuối queue\n- Độ phức tạp: O(1)\n\n**b) Dequeue (Lấy ra):** Xóa và trả về phần tử ở đầu queue\n- Độ phức tạp: O(1)\n\n**c) Front/Peek:** Xem phần tử ở đầu queue mà không xóa\n- Độ phức tạp: O(1)\n\n**d) Rear:** Xem phần tử ở cuối queue\n- Độ phức tạp: O(1)\n\n**e) isEmpty:** Kiểm tra queue có rỗng không\n- Độ phức tạp: O(1)\n\n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Stack và Queue là hai cấu trúc dữ liệu tuyến tính cơ bản có nguyên tắc hoạt động và ứng dụng khác nhau.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Stack & Queue\n**f) Size:** Trả về số lượng phần tử trong queue\n- Độ phức tạp: O(1)\n\n#### 2.3. Cài đặt Queue\n\n**Cách 1: Sử dụng mảng (Circular Queue)**\n\n```python\nclass CircularQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = [None] * capacity\n        self.front = -1\n        self.rear = -1\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        if self.is_full():\n            raise Exception(\"Queue is full\")\n        \n        if self.front == -1:  # Queue rỗng\n            self.front = 0\n        \n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = item\n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.queue[self.front]\n        \n        if self.front == self.rear:  # Chỉ còn 1 phần tử\n            self.front = -1\n            self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.queue[self.front]\n    \n    def is_empty(self):\n        return self.front == -1\n    \n    def is_full(self):\n        return (self.rear + 1) % self.capacity == self.front\n    \n    def size(self):\n        return self.size_count\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass QueueLinkedList:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size_count = 0\n    \n    def enqueue(self, item):\n        new_node = Node(item)\n        \n        if self.rear is None:  # Queue rỗng\n            self.front = self.rear = new_node\n        else:\n            self.rear.next = new_node\n            self.rear = new_node\n        \n        self.size_count += 1\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        \n        item = self.front.data\n        self.front = self.front.next\n        \n        if self.front is None:  # Queue trở nên rỗng\n            self.rear = None\n        \n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Queue is empty\")\n        return self.front.data\n    \n    def is_empty(self):\n        return self.front is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 2.4. Các loại Queue đặc biệt\n\n**a) Deque (Double-ended Queue):**\nCho phép thêm và xóa phần tử ở cả hai đầu.\n\n```python\nfrom collections import deque\n\ndq = deque()\ndq.append(1)      # Thêm vào phải\ndq.appendleft(2)  # Thêm vào trái\ndq.pop()          # Xóa từ phải\ndq.popleft()      # Xóa từ trái\n```\n\n**b) Priority Queue (Hàng đợi ưu tiên):**\nMỗi phần tử có một độ ưu tiên, phần tử có độ ưu tiên cao nhất được xử lý trước.\n\n```python\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, item, priority):\n        heapq.heappush(self.heap, (priority, item))\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Priority Queue is empty\")\n        return heapq.heappop(self.heap)[1]\n    \n    def is_empty(self):\n        return len(self.heap) == 0\n```\n\n#### 2.5. Ứng dụng của Queue\n\n**a) BFS (Breadth-First Search) trong đồ thị:**\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n    \n\n**Các khái niệm quan trọng:**\n- Queue (Hàng đợi) là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc FIFO (First-In, First-Out) – \"vào trước ra trước\", nghĩa là phần tử được thêm vào đầu tiên sẽ được lấy ra hoặc loại bỏ đầu tiên. Các phép toán cơ bản bao gồm Enqueue (thêm phần tử vào cuối), Dequeue (xóa phần tử khỏi đầu), Peek (xem phần tử đầu), Is_Empty (kiểm tra rỗng), Is_Full (kiểm tra đầy), và Size (trả về số lượng phần tử). Truy cập được thực hiện ở đầu (front) và cuối (rear). Queue thường được cài đặt bằng Array (Circular Array) hoặc Linked List. Ứng dụng của Queue rất đa dạng, bao gồm duyệt đồ thị theo chiều rộng (BFS) để lưu trữ các đỉnh cần được thăm theo thứ tự level, quản lý tài nguyên chia sẻ, hàng đợi in ấn, và CPU scheduling.\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Stack và Queue là hai cấu trúc dữ liệu tuyến tính cơ bản có nguyên tắc hoạt động và ứng dụng khác nhau.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n\n## Stack & Queue\n\n### 1. Stack (Ngăn xếp)\n\n#### 1.1. Khái niệm cơ bản\n\nStack là một cấu trúc dữ liệu tuyến tính hoạt động theo nguyên tắc **LIFO (Last In First Out)** - \"vào sau ra trước\". Điều này có nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên.\n\n**Ví dụ thực tế:**\n- Chồng sách: Cuốn sách đặt lên trên cùng sẽ là cuốn được lấy ra đầu tiên\n- Lịch sử trình duyệt: Nút \"Back\" đưa bạn về trang trước đó theo thứ tự ngược lại\n- Undo/Redo trong text editor\n\n#### 1.2. Các thao tác cơ bản\n\n**a) Push (Đẩy):** Thêm một phần tử vào đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Tăng con trở top lên 1 và thêm phần tử\n\n**b) Pop (Lấy ra):** Xóa và trả về phần tử ở đỉnh stack\n- Độ phức tạp: O(1)\n- Thao tác: Lấy phần tử tại top và giảm top xuống 1\n\n**c) Peek/Top:** Xem phần tử ở đỉnh stack mà không xóa\n- Độ phức tạp: O(1)\n\n**d) isEmpty:** Kiểm tra stack có rỗng không\n- Độ phức tạp: O(1)\n\n**e) Size:** Trả về số lượng phần tử trong stack\n- Độ phức tạp: O(1)\n\n#### 1.3. Cài đặt Stack\n\n**Cách 1: Sử dụng mảng (Array)**\n\n```python\nclass Stack:\n    def __init__(self, capacity=100):\n        self.capacity = capacity\n        self.stack = []\n        self.top = -1\n    \n    def push(self, item):\n        if self.top >= self.capacity - 1:\n            raise Exception(\"Stack Overflow\")\n        self.stack.append(item)\n        self.top += 1\n        return True\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.stack[self.top]\n        self.stack.pop()\n        self.top -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.stack[self.top]\n    \n    def is_empty(self):\n        return self.top == -1\n    \n    def size(self):\n        return self.top + 1\n    \n    def display(self):\n        if self.is_empty():\n            print(\"Stack is empty\")\n        else:\n            print(\"Stack elements:\", end=\" \")\n            for i in range(self.top, -1, -1):\n                print(self.stack[i], end=\" \")\n            print()\n```\n\n**Cách 2: Sử dụng Linked List**\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass StackLinkedList:\n    def __init__(self):\n        self.head = None\n        self.size_count = 0\n    \n    def push(self, item):\n        new_node = Node(item)\n        new_node.next = self.head\n        self.head = new_node\n        self.size_count += 1\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack Underflow\")\n        item = self.head.data\n        self.head = self.head.next\n        self.size_count -= 1\n        return item\n    \n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.head.data\n    \n    def is_empty(self):\n        return self.head is None\n    \n    def size(self):\n        return self.size_count\n```\n\n#### 1.4. Ứng dụng của Stack\n\n**a) Kiểm tra dấu ngoặc hợp lệ:**\n\n```python\ndef is_valid_parentheses(s):\n    stack = []\n\n**Các khái niệm quan trọng:**\n- Stack là một cấu trúc dữ liệu tuyến tính và trừu tượng, hoạt động theo nguyên tắc LIFO (Last In, First Out) – \"vào sau ra trước\", nghĩa là phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên. Truy cập chỉ được thực hiện ở đỉnh (top) của stack. Các phép toán cơ bản của Stack bao gồm: push (thêm phần tử vào đỉnh), pop (xóa phần tử khỏi đỉnh), peek/top (xem phần tử ở đỉnh), is_empty (kiểm tra stack rỗng), và size (trả về số lượng phần tử). Tất cả các phép toán này đều có độ phức tạp thời gian O(1). Stack thường được cài đặt bằng Array hoặc Linked List. Ứng dụng của Stack rất đa dạng, bao gồm: triển khai duyệt Preorder không đệ quy, quản lý các lời gọi hàm, kiểm tra tính hợp lệ của dấu ngoặc, chuyển đổi và đánh giá biểu thức, các thuật toán quay lui (backtracking), quản lý lịch sử trình duyệt, và chức năng Undo/Redo.\n- Stack là một cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO (Last In, First Out). Trong ngữ cảnh của Mergesort đệ quy, stack được sử dụng để lưu trữ các lời gọi hàm đệ quy, góp phần vào độ phức tạp không gian O(log n).\n\n**Mối quan hệ:**\n- Stack và Queue là hai cấu trúc dữ liệu tuyến tính cơ bản có nguyên tắc hoạt động và ứng dụng khác nhau."
        },
        "output_without_context": {
            "question": "Trong thuật toán sắp xếp nào, Stack được sử dụng để lưu trữ các phần tử tạm thời trong quá trình sắp xếp?",
            "answer": "Thuật toán sắp xếp nhanh (Quick Sort)"
        }
    },
    {
        "topic_description": "Chủ đề này so sánh thuật toán Shellsort với các phương pháp sắp xếp khác, đồng thời giới thiệu cách thực hiện sắp xếp ngẫu nhiên trong lập trình. Học sinh sẽ phân tích hiệu suất trong các trường hợp khác nhau. Các câu hỏi sẽ tập trung vào việc so sánh hiệu suất và ứng dụng giữa Shellsort và các cách sắp xếp khác.",
        "output_with_context": {
            "question": "So với các thuật toán sắp xếp khác, Shellsort có ưu điểm gì nổi bật trong việc xử lý các mảng lớn và không sắp xếp?",
            "answer": "Shellsort có hiệu suất tốt hơn so với các thuật toán như Bubble Sort và Insertion Sort trong trường hợp mảng lớn và không sắp xếp.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", bubble_sort(arr.copy()))\n```\n\n#### 2.3. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã được sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1) - In-place\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive (với tối ưu hóa)\n- ❌ Hiệu quả thấp với dữ liệu lớn\n\n#### 2.4. Biến thể: Cocktail Shaker Sort\n\n```python\ndef cocktail_sort(arr):\n    n = len(arr)\n    start = 0\n    end = n - 1\n    swapped = True\n    \n    while swapped:\n        swapped = False\n        \n        # Đi từ trái sang phải\n        for i in range(start, end):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        if not swapped:\n            break\n        \n        swapped = False\n        end -= 1\n        \n        # Đi từ phải sang trái\n        for i in range(end - 1, start - 1, -1):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        start += 1\n    \n    return arr\n```\n\n---\n\n### 3. Selection Sort (Sắp xếp chọn)\n\n#### 3.1. Ý tưởng\n\nSelection Sort chia mảng thành hai phần: phần đã sắp xếp và phần chưa sắp xếp. Trong mỗi bước, thuật toán tìm phần tử nhỏ nhất trong phần chưa sắp xếp và đưa nó vào cuối phần đã sắp xếp.\n\n**Các bước:**\n1. Tìm phần tử nhỏ nhất trong mảng chưa sắp xếp\n2. Hoán đổi nó với phần tử đầu tiên của mảng chưa sắp xếp\n3. Di chuyển ranh giới giữa phần đã sắp xếp và chưa sắp xếp\n4. Lặp lại cho đến khi mảng được sắp xếp\n\n#### 3.2. Thuật toán\n\n```python\ndef selection_sort(arr):\n    n = len(arr)\n    \n    for i in range(n):\n        # Tìm phần tử nhỏ nhất trong phần chưa sắp xếp\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Hoán đổi phần tử nhỏ nhất với phần tử đầu tiên\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    \n    return arr\n\n# Test\narr = [64, 25, 12, 22, 11]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", selection_sort(arr.copy()))\n```\n\n#### 3.3. Minh họa từng bước\n\n```\nMảng: [64, 25, 12, 22, 11]\n\nBước 1: Tìm min = 11, hoán đổi với vị trí 0\n        [11, 25, 12, 22, 64]\n\nBước 2: Tìm min = 12, hoán đổi với vị trí 1\n        [11, 12, 25, 22, 64]\n\nBước 3: Tìm min = 22, hoán đổi với vị trí 2\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Cocktail Shaker Sort (còn gọi là Bidirectional Bubble Sort) là một biến thể của Bubble Sort, cải thiện hiệu suất bằng cách sắp xếp theo cả hai hướng (từ trái sang phải và từ phải sang trái) trong mỗi lần lặp. Điều này giúp các phần tử nhỏ nhất và lớn nhất di chuyển nhanh hơn về đúng vị trí của chúng. Độ phức tạp thời gian của Cocktail Shaker Sort vẫn là O(n²) trong trường hợp xấu nhất và trung bình, và O(n) trong trường hợp tốt nhất. Độ phức tạp không gian là O(1).\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Merge Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong một mảng theo thứ tự mong muốn.\n- Cocktail Shaker Sort là một biến thể của Bubble Sort, cải thiện hiệu suất bằng cách sắp xếp theo hai hướng.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n        [11, 12, 22, 25, 64]\n\nBước 4: Tìm min = 25, không cần hoán đổi\n        [11, 12, 22, 25, 64]\n```\n\n#### 3.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n²)\n- **Average case:** O(n²)\n- **Worst case:** O(n²)\n- Số lần so sánh luôn cố định: n(n-1)/2\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ❌ Unstable (có thể làm stable với cài đặt khác)\n- ✅ In-place\n- ❌ Không adaptive\n- ✅ Số lần hoán đổi ít nhất: O(n)\n\n**Ưu điểm:**\n- Đơn giản, dễ hiểu\n- Số lần hoán đổi ít (tốt khi chi phí hoán đổi cao)\n- Hoạt động tốt với mảng nhỏ\n\n**Nhược điểm:**\n- Không hiệu quả với dữ liệu lớn\n- Không tận dụng được dữ liệu đã sắp xếp\n\n---\n\n### 4. Insertion Sort (Sắp xếp chèn)\n\n#### 4.1. Ý tưởng\n\nInsertion Sort xây dựng mảng đã sắp xếp từng phần tử một. Nó giống như cách chúng ta sắp xếp bài trong tay: lấy một lá bài và chèn nó vào đúng vị trí trong phần đã sắp xếp.\n\n**Nguyên lý:**\n1. Bắt đầu từ phần tử thứ hai\n2. So sánh với các phần tử bên trái\n3. Dịch các phần tử lớn hơn sang phải\n4. Chèn phần tử vào vị trí đúng\n\n#### 4.2. Thuật toán\n\n```python\ndef insertion_sort(arr):\n    n = len(arr)\n    \n    for i in range(1, n):\n        key = arr[i]\n        j = i - 1\n        \n        # Di chuyển các phần tử lớn hơn key sang phải\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        \n        # Chèn key vào vị trí đúng\n        arr[j + 1] = key\n    \n    return arr\n\n# Test\narr = [12, 11, 13, 5, 6]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", insertion_sort(arr.copy()))\n```\n\n#### 4.3. Minh họa từng bước\n\n```\nMảng: [12, 11, 13, 5, 6]\n\nBước 1: key = 11\n        [11, 12, 13, 5, 6]\n\nBước 2: key = 13, không thay đổi\n        [11, 12, 13, 5, 6]\n\nBước 3: key = 5\n        [5, 11, 12, 13, 6]\n\nBước 4: key = 6\n        [5, 6, 11, 12, 13]\n```\n\n#### 4.4. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1)\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive\n- ✅ Online\n\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Merge Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong một mảng theo thứ tự mong muốn.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n### 1. Giới thiệu về Sắp xếp\n\n#### 1.1. Khái niệm\n\nSắp xếp (Sorting) là quá trình sắp đặt các phần tử trong một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một trong những thao tác cơ bản và quan trọng nhất trong khoa học máy tính.\n\n**Tại sao sắp xếp quan trọng?**\n- Giúp tìm kiếm nhanh hơn (Binary Search)\n- Tối ưu hóa các thuật toán khác\n- Cải thiện hiệu suất của database\n- Trực quan hóa và phân tích dữ liệu\n\n#### 1.2. Phân loại thuật toán sắp xếp\n\n**a) Theo phương pháp:**\n- **Comparison-based:** So sánh các phần tử (Bubble, Selection, Insertion, Merge, Quick)\n- **Non-comparison-based:** Không so sánh trực tiếp (Counting, Radix, Bucket)\n\n**b) Theo tính ổn định (Stability):**\n- **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- **Unstable:** Không đảm bảo thứ tự tương đối\n\n**c) Theo bộ nhớ:**\n- **In-place:** Sử dụng O(1) bộ nhớ phụ\n- **Out-of-place:** Cần thêm bộ nhớ phụ\n\n#### 1.3. Các tiêu chí đánh giá\n\n- **Time Complexity:** Độ phức tạp thời gian (Best, Average, Worst case)\n- **Space Complexity:** Độ phức tạp không gian\n- **Stability:** Tính ổn định\n- **Adaptive:** Hiệu quả với dữ liệu đã gần sắp xếp\n- **Online:** Có thể xử lý dữ liệu đến theo thời gian thực\n\n---\n\n### 2. Bubble Sort (Sắp xếp nổi bọt)\n\n#### 2.1. Ý tưởng\n\nBubble Sort so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này lặp lại cho đến khi mảng được sắp xếp. Phần tử lớn nhất sẽ \"nổi\" lên vị trí cuối cùng sau mỗi lượt.\n\n**Hình ảnh trực quan:**\n- Lượt 1: Phần tử lớn nhất \"nổi\" lên cuối\n- Lượt 2: Phần tử lớn thứ hai nổi lên vị trí kế cuối\n- Tiếp tục cho đến khi mảng được sắp xếp\n\n#### 2.2. Thuật toán\n\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # Duyệt qua tất cả các phần tử\n    for i in range(n):\n        # Cờ để tối ưu hóa\n        swapped = False\n        \n        # Phần tử cuối cùng i phần tử đã được sắp xếp\n        for j in range(0, n - i - 1):\n            # So sánh phần tử liền kề\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # Nếu không có hoán đổi nào, mảng đã sắp xếp\n        if not swapped:\n            break\n    \n    return arr\n\n# Test\narr = [64, 34, 25, 12, 22, 11, 90]\n\n**Các khái niệm quan trọng:**\n- Sorting là bài toán sắp xếp các phần tử trong một danh sách theo một thứ tự nhất định (tăng dần hoặc giảm dần). Selection Sort và Insertion Sort là hai thuật toán cơ bản giải quyết bài toán này.\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n- Sorting là bài toán sắp xếp các phần tử của một danh sách hoặc mảng theo một thứ tự nhất định (tăng dần hoặc giảm dần). Heap Sort và Merge Sort là các thuật toán giải quyết bài toán này.\n\n**Mối quan hệ:**\n- Merge Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong một mảng theo thứ tự mong muốn."
        },
        "output_without_context": {
            "question": "So với các thuật toán sắp xếp khác, Shellsort có ưu điểm gì nổi bật trong việc xử lý các dãy số lớn?",
            "answer": "Shellsort thường có hiệu suất tốt hơn trong việc sắp xếp các dãy số lớn nhờ vào việc giảm thiểu số lần so sánh và hoán đổi."
        }
    },
    {
        "topic_description": "Chủ đề này trình bày về các thực hành tốt nhất trong việc xáo trộn dữ liệu, bao gồm việc sử dụng bộ tạo số ngẫu nhiên an toàn. Học sinh cần nhận diện các nguy cơ và chiến lược để cải thiện hiệu suất xáo trộn. Câu hỏi sẽ kiểm tra khả năng đánh giá và tạo ra các phương pháp tốt nhất cho việc randomization.",
        "output_with_context": {
            "question": "Kỹ thuật nào được sử dụng trong Quicksort để tránh trường hợp xấu nhất O(n²) bằng cách chọn phần tử pivot một cách ngẫu nhiên?",
            "answer": "Random Pivot",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Quicksort\n- Ví dụ: Mảng đã sắp xếp với pivot là phần tử đầu/cuối\n- Độ cao cây đệ quy: n\n- Tổng: O(n²)\n\n**Minh họa Worst Case:**\n```\nMảng: [1, 2, 3, 4, 5] (pivot = cuối)\n\nLần 1: [1,2,3,4] | 5 | []       - n operations\nLần 2: [1,2,3] | 4 | []         - (n-1) operations\nLần 3: [1,2] | 3 | []           - (n-2) operations\n...\nTổng: n + (n-1) + (n-2) + ... + 1 = n(n+1)/2 = O(n²)\n```\n\n#### 3.2. Độ phức tạp không gian\n\n**Space Complexity:**\n- **Best/Average case:** O(log n) - Chiều cao cây đệ quy\n- **Worst case:** O(n) - Cây đệ quy thoái hóa\n\n**In-place:** ✅ (không cần mảng phụ, chỉ dùng stack cho đệ quy)\n\n#### 3.3. Đặc điểm\n\n**Ưu điểm:**\n- ✅ Rất nhanh trong thực tế (cache-friendly)\n- ✅ In-place (O(log n) space)\n- ✅ Dễ song song hóa\n- ✅ Có thể tối ưu cho nhiều trường hợp\n\n**Nhược điểm:**\n- ❌ Unstable (không giữ thứ tự tương đối)\n- ❌ Worst case O(n²) (có thể tránh với random pivot)\n- ❌ Không tốt với dữ liệu đã sắp xếp (nếu không tối ưu)\n\n---\n\n### 4. Tối ưu hóa Quick Sort\n\n#### 4.1. Random Pivot (Tránh worst case)\n\n```python\nimport random\n\ndef randomized_partition(arr, low, high):\n    \"\"\"\n    Chọn pivot ngẫu nhiên\n    \"\"\"\n    # Chọn random index và đổi về cuối\n    random_index = random.randint(low, high)\n    arr[random_index], arr[high] = arr[high], arr[random_index]\n    return partition(arr, low, high)\n\ndef randomized_quick_sort(arr, low=0, high=None):\n    \"\"\"\n    Randomized Quick Sort - Tránh worst case O(n²)\n    \"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        pivot_index = randomized_partition(arr, low, high)\n        randomized_quick_sort(arr, low, pivot_index - 1)\n        randomized_quick_sort(arr, pivot_index + 1, high)\n    \n    return arr\n```\n\n#### 4.2. Median-of-Three (Tối ưu)\n\n```python\ndef median_of_three(arr, low, high):\n    \"\"\"\n    Chọn median của 3 phần tử làm pivot\n    \"\"\"\n    mid = (low + high) // 2\n    \n    # Sắp xếp 3 phần tử\n    if arr[low] > arr[mid]:\n        arr[low], arr[mid] = arr[mid], arr[low]\n    if arr[low] > arr[high]:\n        arr[low], arr[high] = arr[high], arr[low]\n    if arr[mid] > arr[high]:\n        arr[mid], arr[high] = arr[high], arr[mid]\n    \n    # Đặt median (arr[mid]) vào vị trí high-1\n    arr[mid], arr[high - 1] = arr[high - 1], arr[mid]\n    return arr[high - 1]\n```\n\n#### 4.3. Three-Way Partitioning (Dutch National Flag)\n\nXử lý tốt khi có nhiều phần tử trùng lặp.\n\n```python\ndef three_way_partition(arr, low, high):\n    \"\"\"\n    Chia mảng thành 3 phần: < pivot, = pivot, > pivot\n    \"\"\"\n    if high <= low:\n        return low, high\n    \n    pivot = arr[low]\n\n**Các khái niệm quan trọng:**\n- Randomized_partition là một biến thể của phép toán partition trong Quicksort, trong đó pivot được chọn ngẫu nhiên từ mảng con trước khi thực hiện phân hoạch. Mục đích là để tránh trường hợp xấu nhất của Quicksort.\n- Random Pivot là một kỹ thuật tối ưu hóa Quicksort bằng cách chọn phần tử pivot một cách ngẫu nhiên. Kỹ thuật này giúp tránh trường hợp xấu nhất O(n²) của Quicksort, chuyển đổi nó thành trường hợp trung bình O(n log n) với xác suất cao.\n- Randomized Quick Sort là một phiên bản của Quicksort sử dụng kỹ thuật Random Pivot để chọn pivot ngẫu nhiên. Điều này giúp giảm đáng kể khả năng gặp phải trường hợp xấu nhất O(n²) và đảm bảo hiệu suất trung bình O(n log n) với xác suất cao.\n\n**Mối quan hệ:**\n- Randomized Quick Sort sử dụng kỹ thuật Random Pivot để cải thiện hiệu suất và tránh trường hợp xấu nhất.\n- Random Pivot tối ưu hóa Quicksort bằng cách chọn pivot ngẫu nhiên để tránh trường hợp xấu nhất O(n²).\n\n**Nội dung từ tài liệu:**\n# Học Máy (Machine Learning)\n## Lựa Chọn Đặc Trưng & Tối Ưu Hóa Mô Hình\n- Precision, Recall, F1, AUC\n- Business metrics\n\n**6. Avoid Data Leakage:**\n- **Proper CV:** Fit preprocessors trên train folds only\n- **Time-based splits:** cho time series\n- **No target leakage:** Features không chứa info về target\n- **Test set untouched:** Cho đến cuối\n\n**7. Document Everything:**\n- Experiments log\n- Model versions\n- Hyperparameters\n- Results và insights\n\n**8. Reproducibility:**\n- Set random seeds\n- Version control code\n- Save data versions\n- Document environment\n- Use containers (Docker)\n\n**9. Model Versioning:**\n- MLflow, DVC\n- Track models\n- Compare versions\n- Rollback nếu cần\n\n**10. Validation Strategy:**\n- Robust CV\n- Hold-out test set\n- Temporal validation cho time series\n\n**11. Feature Engineering First:**\n- \"Data > Algorithms\"\n- Good features > Complex models\n- Domain knowledge valuable\n\n**12. Monitor Training:**\n- Training vs validation\n- Learning curves\n- Early signs of overfitting\n\n**13. Consider Production:**\n- Inference time\n- Model size\n- Dependencies\n- Maintenance\n- Explainability\n\n**14. Test on Real Data:**\n- Not just metrics\n- Qualitative analysis\n- Edge cases\n- Failure modes\n\n---\n\n---\n\n## Học Không Giám Sát (Unsupervised Learning)\n\n### Giới Thiệu Về Học Không Giám Sát\n\nHọc không giám sát khám phá các mẫu ẩn trong dữ liệu không có nhãn mà không cần biến mục tiêu tường minh. Nó được sử dụng cho phân tích dữ liệu khám phá, nhận dạng mẫu và nén dữ liệu.\n\n**Đặc điểm chính:**\n- Không có labels (y)\n- Chỉ có features (X)\n- Tìm structure trong data\n- Exploratory analysis\n\n**So với Supervised Learning:**\n| Tiêu chí | Supervised | Unsupervised |\n|----------|-----------|--------------|\n| Labels | Có | Không |\n| Mục tiêu | Dự đoán | Khám phá |\n| Feedback | Có (accuracy) | Không rõ ràng |\n| Ứng dụng | Classification, Regression | Clustering, Dimensionality Reduction |\n\n**Các tác vụ chính:**\n1. **Clustering:** Nhóm dữ liệu tương tự\n2. **Dimensionality Reduction:** Giảm số chiều\n3. **Anomaly Detection:** Phát hiện bất thường\n4. **Association Rule Learning:** Tìm mối quan hệ\n\n**Thách thức:**\n- Không có ground truth để đánh giá\n- Khó xác định số clusters/components\n- Kết quả có thể subjective\n- Cần domain knowledge để interpret\n\n### Clustering (Phân Cụm)\n\nNhóm các điểm dữ liệu tương tự lại với nhau.\n\n**Mục tiêu:**\n- High intra-cluster similarity (trong cùng cluster)\n- Low inter-cluster similarity (giữa các clusters)\n\n**Ứng dụng:**\n- Customer segmentation\n- Document clustering\n- Image segmentation\n- Anomaly detection\n- Data compression\n\n### K-Means Clustering\n\nThuật toán phân cụm phổ biến nhất, chia dữ liệu thành K clusters.\n\n**Thuật toán:**\n\n**Bước 1: Initialization**\n- Chọn K centroids ngẫu nhiên\n- Có thể từ data points hoặc random positions\n\n**Bước 2: Assignment**\n- Gán mỗi điểm đến centroid gần nhất\n- Sử dụng Euclidean distance:\n$$d(x, \\mu_k) = ||x - \\mu_k|| = \\sqrt{\\sum_{j=1}^{n}(x_j - \\mu_{kj})^2}$$\n\n**Bước 3: Update**\n- Cập nhật centroids = mean của các điểm assigned\n$$\\mu_k = \frac{1}{|C_k|}\\sum_{x \\in C_k}x$$\n\n\n**Các khái niệm quan trọng:**\n- Random seeds là các giá trị số được sử dụng để khởi tạo bộ tạo số ngẫu nhiên, đảm bảo rằng các kết quả của các thuật toán có yếu tố ngẫu nhiên (như khởi tạo trọng số hoặc chia dữ liệu) có thể được tái tạo chính xác trong các lần chạy khác nhau.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", bubble_sort(arr.copy()))\n```\n\n#### 2.3. Phân tích\n\n**Độ phức tạp thời gian:**\n- **Best case:** O(n) - Mảng đã được sắp xếp\n- **Average case:** O(n²)\n- **Worst case:** O(n²) - Mảng sắp xếp ngược\n\n**Độ phức tạp không gian:** O(1) - In-place\n\n**Đặc điểm:**\n- ✅ Stable\n- ✅ In-place\n- ✅ Adaptive (với tối ưu hóa)\n- ❌ Hiệu quả thấp với dữ liệu lớn\n\n#### 2.4. Biến thể: Cocktail Shaker Sort\n\n```python\ndef cocktail_sort(arr):\n    n = len(arr)\n    start = 0\n    end = n - 1\n    swapped = True\n    \n    while swapped:\n        swapped = False\n        \n        # Đi từ trái sang phải\n        for i in range(start, end):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        if not swapped:\n            break\n        \n        swapped = False\n        end -= 1\n        \n        # Đi từ phải sang trái\n        for i in range(end - 1, start - 1, -1):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        \n        start += 1\n    \n    return arr\n```\n\n---\n\n### 3. Selection Sort (Sắp xếp chọn)\n\n#### 3.1. Ý tưởng\n\nSelection Sort chia mảng thành hai phần: phần đã sắp xếp và phần chưa sắp xếp. Trong mỗi bước, thuật toán tìm phần tử nhỏ nhất trong phần chưa sắp xếp và đưa nó vào cuối phần đã sắp xếp.\n\n**Các bước:**\n1. Tìm phần tử nhỏ nhất trong mảng chưa sắp xếp\n2. Hoán đổi nó với phần tử đầu tiên của mảng chưa sắp xếp\n3. Di chuyển ranh giới giữa phần đã sắp xếp và chưa sắp xếp\n4. Lặp lại cho đến khi mảng được sắp xếp\n\n#### 3.2. Thuật toán\n\n```python\ndef selection_sort(arr):\n    n = len(arr)\n    \n    for i in range(n):\n        # Tìm phần tử nhỏ nhất trong phần chưa sắp xếp\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Hoán đổi phần tử nhỏ nhất với phần tử đầu tiên\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    \n    return arr\n\n# Test\narr = [64, 25, 12, 22, 11]\nprint(\"Mảng ban đầu:\", arr)\nprint(\"Mảng sau khi sắp xếp:\", selection_sort(arr.copy()))\n```\n\n#### 3.3. Minh họa từng bước\n\n```\nMảng: [64, 25, 12, 22, 11]\n\nBước 1: Tìm min = 11, hoán đổi với vị trí 0\n        [11, 25, 12, 22, 64]\n\nBước 2: Tìm min = 12, hoán đổi với vị trí 1\n        [11, 12, 25, 22, 64]\n\nBước 3: Tìm min = 22, hoán đổi với vị trí 2\n\n**Các khái niệm quan trọng:**\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n\n**Mối quan hệ:**\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn.\n- Merge Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong một mảng theo thứ tự mong muốn.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\n\n### 1. Giới thiệu về Sắp xếp\n\n#### 1.1. Khái niệm\n\nSắp xếp (Sorting) là quá trình sắp đặt các phần tử trong một tập hợp theo một thứ tự nhất định (tăng dần hoặc giảm dần). Đây là một trong những thao tác cơ bản và quan trọng nhất trong khoa học máy tính.\n\n**Tại sao sắp xếp quan trọng?**\n- Giúp tìm kiếm nhanh hơn (Binary Search)\n- Tối ưu hóa các thuật toán khác\n- Cải thiện hiệu suất của database\n- Trực quan hóa và phân tích dữ liệu\n\n#### 1.2. Phân loại thuật toán sắp xếp\n\n**a) Theo phương pháp:**\n- **Comparison-based:** So sánh các phần tử (Bubble, Selection, Insertion, Merge, Quick)\n- **Non-comparison-based:** Không so sánh trực tiếp (Counting, Radix, Bucket)\n\n**b) Theo tính ổn định (Stability):**\n- **Stable:** Giữ nguyên thứ tự tương đối của các phần tử bằng nhau\n- **Unstable:** Không đảm bảo thứ tự tương đối\n\n**c) Theo bộ nhớ:**\n- **In-place:** Sử dụng O(1) bộ nhớ phụ\n- **Out-of-place:** Cần thêm bộ nhớ phụ\n\n#### 1.3. Các tiêu chí đánh giá\n\n- **Time Complexity:** Độ phức tạp thời gian (Best, Average, Worst case)\n- **Space Complexity:** Độ phức tạp không gian\n- **Stability:** Tính ổn định\n- **Adaptive:** Hiệu quả với dữ liệu đã gần sắp xếp\n- **Online:** Có thể xử lý dữ liệu đến theo thời gian thực\n\n---\n\n### 2. Bubble Sort (Sắp xếp nổi bọt)\n\n#### 2.1. Ý tưởng\n\nBubble Sort so sánh từng cặp phần tử liền kề và hoán đổi chúng nếu chúng sai thứ tự. Quá trình này lặp lại cho đến khi mảng được sắp xếp. Phần tử lớn nhất sẽ \"nổi\" lên vị trí cuối cùng sau mỗi lượt.\n\n**Hình ảnh trực quan:**\n- Lượt 1: Phần tử lớn nhất \"nổi\" lên cuối\n- Lượt 2: Phần tử lớn thứ hai nổi lên vị trí kế cuối\n- Tiếp tục cho đến khi mảng được sắp xếp\n\n#### 2.2. Thuật toán\n\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # Duyệt qua tất cả các phần tử\n    for i in range(n):\n        # Cờ để tối ưu hóa\n        swapped = False\n        \n        # Phần tử cuối cùng i phần tử đã được sắp xếp\n        for j in range(0, n - i - 1):\n            # So sánh phần tử liền kề\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # Nếu không có hoán đổi nào, mảng đã sắp xếp\n        if not swapped:\n            break\n    \n    return arr\n\n# Test\narr = [64, 34, 25, 12, 22, 11, 90]\n\n**Các khái niệm quan trọng:**\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n\n**Mối quan hệ:**\n- Bubble Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong mảng theo thứ tự mong muốn.\n- Merge Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong một mảng theo thứ tự mong muốn.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Basic Sorting Algorithms\nfor size in [100, 500, 1000]:\n    compare_sorting_algorithms(size)\n```\n\n#### 5.3. Ứng dụng thực tế\n\n**1. Sắp xếp trong Database:**\n- Sử dụng Insertion Sort cho dữ liệu nhỏ\n- Kết hợp với các thuật toán nâng cao\n\n**2. Sắp xếp trong thư viện:**\n```python\n# Python's sorted() và list.sort() sử dụng Timsort\n# (kết hợp Merge Sort và Insertion Sort)\n\n# Sắp xếp cơ bản\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6]\nsorted_numbers = sorted(numbers)\n\n# Sắp xếp với key function\nstudents = [\n    {'name': 'An', 'score': 85},\n    {'name': 'Bình', 'score': 92},\n    {'name': 'Chi', 'score': 78}\n]\nsorted_students = sorted(students, key=lambda x: x['score'], reverse=True)\n```\n\n**3. Sắp xếp custom objects:**\n```python\nclass Student:\n    def __init__(self, name, grade):\n        self.name = name\n        self.grade = grade\n    \n    def __lt__(self, other):\n        return self.grade < other.grade\n    \n    def __repr__(self):\n        return f\"Student({self.name}, {self.grade})\"\n\nstudents = [Student(\"An\", 85), Student(\"Bình\", 92), Student(\"Chi\", 78)]\nsorted_students = insertion_sort(students)\nprint(sorted_students)\n```\n\n---\n\n### 6. Tối ưu hóa và Thủ thuật\n\n#### 6.1. Early termination (Dừng sớm)\n\n```python\ndef optimized_bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:  # Dừng nếu không có hoán đổi\n            break\n    return arr\n```\n\n#### 6.2. Giảm số lần hoán đổi\n\n```python\ndef optimized_insertion_sort(arr):\n    \"\"\"Sử dụng shifting thay vì swapping\"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]  # Shift thay vì swap\n            j -= 1\n        arr[j + 1] = key\n    return arr\n```\n\n#### 6.3. Hybrid approach\n\n```python\ndef hybrid_sort(arr, threshold=10):\n    \"\"\"Sử dụng Insertion Sort cho mảng nhỏ\"\"\"\n    if len(arr) <= threshold:\n        return insertion_sort(arr)\n    else:\n        # Sử dụng thuật toán khác cho mảng lớn\n        return sorted(arr)  # Placeholder\n```\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Sorting (Sắp xếp) là bài toán hoặc quá trình tổ chức/sắp đặt các phần tử của một danh sách, mảng, hoặc tập hợp theo một thứ tự nhất định (ví dụ: tăng dần hoặc giảm dần). Đây là một trong những bài toán/thao tác cơ bản và quan trọng nhất trong khoa học máy tính, có nhiều ứng dụng thực tế như trong cơ sở dữ liệu, tìm kiếm nhanh hơn, tối ưu hóa các thuật toán khác, xử lý dữ liệu, cải thiện hiệu suất của database và trực quan hóa dữ liệu.\n\n**Mối quan hệ:**\n- Merge Sort giải quyết bài toán Sorting bằng cách sắp xếp các phần tử trong một mảng theo thứ tự mong muốn."
        },
        "output_without_context": {
            "question": "Trong việc xáo trộn dữ liệu, phương pháp nào được coi là thực hành tốt nhất để đảm bảo tính ngẫu nhiên và an toàn?",
            "answer": "Sử dụng bộ tạo số ngẫu nhiên an toàn."
        }
    }
]