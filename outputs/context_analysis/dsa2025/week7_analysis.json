[
    {
        "topic_description": "Chủ đề này khám phá khái niệm hàm băm (Hash Function) và cách tính toán chỉ mục mảng từ khóa. Học sinh sẽ nắm vững định nghĩa, ví dụ, cùng với vấn đề phát sinh và xung đột trong hàm băm. Đây là kiến thức cơ bản cần thiết để hiểu cách hoạt động của bảng băm.",
        "output_with_context": {
            "question": "Hàm băm (hash function) là gì và mục đích chính của nó trong bảng băm là gì?",
            "answer": "Hàm băm là một phép toán chuyển đổi khóa thành chỉ mục trong bảng băm, với mục đích chính là phân phối các khóa một cách đồng đều để giảm thiểu va chạm.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n        return -1\n    \n    def remove(self, key):\n        \"\"\"Time: O(n/k)\"\"\"\n        index = self._hash(key)\n        \n        for i, (k, v) in enumerate(self.buckets[index]):\n            if k == key:\n                self.buckets[index].pop(i)\n                return\n\n# Test\nhashmap = MyHashMap()\nhashmap.put(1, 1)\nhashmap.put(2, 2)\nprint(hashmap.get(1))    # 1\nhashmap.put(2, 1)\nprint(hashmap.get(2))    # 1\nhashmap.remove(2)\nprint(hashmap.get(2))    # -1\n```\n\n---\n\n### 6. Python Dictionary\n\nPython's `dict` là hash table được tối ưu cao:\n\n```python\n# Tạo dictionary\nd = {}\nd = dict()\nd = {'apple': 5, 'banana': 3}\n\n# Thao tác cơ bản\nd['cherry'] = 2        # Insert/Update - O(1)\nvalue = d['apple']     # Get - O(1)\ndel d['banana']        # Delete - O(1)\nexists = 'apple' in d  # Contains - O(1)\n\n# Methods\nkeys = d.keys()        # Tất cả keys\nvalues = d.values()    # Tất cả values\nitems = d.items()      # Tất cả (key, value) pairs\n\n# Get với default\nvalue = d.get('grape', 0)  # Trả về 0 nếu không tìm thấy\n\n# Duyệt\nfor key in d:\n    print(key, d[key])\n\nfor key, value in d.items():\n    print(key, value)\n\n# Counter\nfrom collections import Counter\nwords = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']\ncount = Counter(words)\nprint(count)  # Counter({'apple': 3, 'banana': 2, 'cherry': 1})\n\n# DefaultDict\nfrom collections import defaultdict\ndd = defaultdict(int)  # Default value = 0\ndd['apple'] += 1\n\ndd_list = defaultdict(list)  # Default value = []\ndd_list['fruits'].append('apple')\n```\n\n---\n\n### 7. Phân tích độ phức tạp\n\n| Thao tác | Average | Worst | Space |\n|----------|---------|-------|-------|\n| Insert | O(1) | O(n) | O(n) |\n| Search | O(1) | O(n) | O(n) |\n| Delete | O(1) | O(n) | O(n) |\n\n**Worst case:** Khi tất cả keys hash về cùng index (collision)\n\n**Load factor ảnh hưởng:**\n- α < 0.7: Performance tốt\n- α > 0.7: Nên resize\n\n---\n\n### 8. Khi nào dùng Hash Table?\n\n**Nên dùng:**\n- ✅ Cần lookup/insert/delete nhanh O(1)\n- ✅ Không cần thứ tự\n- ✅ Unique keys\n- ✅ Counting, frequency\n- ✅ Caching\n\n**Không nên dùng:**\n- ❌ Cần duy trì thứ tự → BST, Sorted Array\n- ❌ Cần range query → BST\n- ❌ Cần min/max → Heap\n- ❌ Memory bị hạn chế → Array\n\n---\n\n\n**Các khái niệm quan trọng:**\n- hash_function (hoặc _hash) là một phép toán cơ bản trong Hash Table, có nhiệm vụ chuyển đổi một khóa (key) thành một chỉ mục số nguyên (index) trong phạm vi kích thước của mảng lưu trữ của bảng băm. Hàm băm này được thiết kế để xử lý cả khóa số nguyên (thường bằng phép chia lấy dư) và khóa chuỗi (bằng cách tính tổng trọng số của các ký tự), sử dụng phép toán modulo để đảm bảo chỉ mục nằm trong giới hạn của bảng. Mục tiêu chính của một hàm băm tốt là phân phối các khóa một cách đồng đều khắp bảng để giảm thiểu va chạm, với độ phức tạp lý tưởng là O(1).\n- _hash là phép toán hàm băm nội bộ của MyHashMap, dùng để tính toán chỉ số (index) của bucket cho một key cụ thể. Công thức băm được sử dụng là `key % self.size`.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (original_index + i * i) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n#### 3.4. Double Hashing\n\n```python\nclass HashTableDoubleHashing:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [None] * size\n        self.count = 0\n    \n    def hash1(self, key):\n        \"\"\"Primary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def hash2(self, key):\n        \"\"\"Secondary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 37 + ord(char))\n            return 1 + (hash_value % (self.size - 1))\n        return 1 + (key % (self.size - 1))\n    \n    def insert(self, key, value):\n        \"\"\"\n        Double hashing: h(k, i) = (h1(k) + i*h2(k)) mod m\n        \"\"\"\n        index = self.hash1(key)\n        step = self.hash2(key)\n        i = 0\n        \n        while self.table[index] is not None:\n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (self.hash1(key) + i * step) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n---\n\n### 4. So sánh Chaining vs Open Addressing\n\n| Đặc điểm | Chaining | Open Addressing |\n|----------|----------|-----------------|\n| **Collision** | Dùng linked list | Tìm slot khác |\n| **Memory** | Thêm memory cho pointers | Chỉ dùng array |\n| **Load factor** | Có thể > 1 | Phải < 1 |\n| **Cache** | Kém (pointers) | Tốt (locality) |\n| **Delete** | Dễ | Phức tạp (cần marker) |\n| **Resize** | Ít cần | Cần thường xuyên |\n| **Performance** | Ổn định | Giảm khi đầy |\n\n**Khi nào dùng:**\n- **Chaining:** Không biết trước số phần tử, collision rate cao\n- **Open Addressing:** Biết trước size, cần tối ưu cache\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Two Sum Problem\n\n```python\ndef two_sum(nums, target):\n    \"\"\"\n    Tìm 2 số có tổng = target\n    Time: O(n), Space: O(n)\n    \"\"\"\n    hash_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in hash_map:\n            return [hash_map[complement], i]\n        \n        hash_map[num] = i\n    \n    return []\n\n# Test\nprint(two_sum([2, 7, 11, 15], 9))  # [0, 1]\n```\n\n#### 5.2. Group Anagrams\n\n```python\ndef group_anagrams(words):\n    \"\"\"\n    Nhóm các từ là anagram của nhau\n    Time: O(n * k log k) với k là độ dài từ\n    \"\"\"\n    from collections import defaultdict\n    \n    anagram_map = defaultdict(list)\n    \n    for word in words:\n        # Sort chữ cái làm key\n        key = ''.join(sorted(word))\n        anagram_map[key].append(word)\n    \n    return list(anagram_map.values())\n\n# Test\nwords = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(group_anagrams(words))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n```\n\n\n**Các khái niệm quan trọng:**\n- hash2 là hàm băm phụ được sử dụng trong Double Hashing để tính toán bước nhảy (step size) khi xảy ra va chạm. Hàm này phải đảm bảo trả về một giá trị khác 0 và tương đối nguyên tố với kích thước bảng băm để đảm bảo tất cả các vị trí trong bảng có thể được duyệt qua. Đối với khóa là chuỗi, nó tính tổng trọng số của các ký tự; đối với khóa là số nguyên, nó sử dụng phép toán modulo. Độ phức tạp thời gian của hash2 phụ thuộc vào độ dài của khóa, ví dụ O(k) cho chuỗi có độ dài k.\n- hash1 là hàm băm chính được sử dụng trong Double Hashing để tính toán vị trí ban đầu của một khóa trong bảng băm. Đối với khóa là chuỗi, nó tính tổng trọng số của các ký tự; đối với khóa là số nguyên, nó sử dụng phép toán modulo. Độ phức tạp thời gian của hash1 phụ thuộc vào độ dài của khóa, ví dụ O(k) cho chuỗi có độ dài k.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Hash Table (Bảng băm)** là một cấu trúc dữ liệu cho phép lưu trữ và truy xuất dữ liệu với độ phức tạp trung bình **O(1)**. Hash Table sử dụng **hash function** để chuyển đổi key thành index trong mảng.\n\n**Thành phần chính:**\n- **Key:** Khóa duy nhất để truy cập giá trị\n- **Value:** Giá trị được lưu trữ\n- **Hash Function:** Hàm chuyển key thành index\n- **Bucket/Slot:** Vị trí trong mảng để lưu cặp key-value\n\n**Ví dụ:**\n```\nKey: \"apple\"  → Hash(\"apple\") → Index: 5\nKey: \"banana\" → Hash(\"banana\") → Index: 2\nKey: \"cherry\" → Hash(\"cherry\") → Index: 8\n\nArray: [_, _, \"banana\", _, _, \"apple\", _, _, \"cherry\", _]\nIndex:  0  1     2      3  4     5     6  7     8      9\n```\n\n#### 1.2. Hash Function\n\n**Yêu cầu của hash function tốt:**\n1. **Deterministic:** Cùng input luôn cho cùng output\n2. **Uniform distribution:** Phân bố đều các key\n3. **Fast to compute:** Tính toán nhanh O(1)\n4. **Minimize collisions:** Giảm xung đột\n\n**Các phương pháp hash phổ biến:**\n\n**a) Division Method:**\n```python\ndef hash_division(key, table_size):\n    \"\"\"h(k) = k mod m\"\"\"\n    return key % table_size\n```\n\n**b) Multiplication Method:**\n```python\ndef hash_multiplication(key, table_size):\n    \"\"\"h(k) = floor(m * (k*A mod 1))\"\"\"\n    A = 0.6180339887  # (√5 - 1) / 2\n    return int(table_size * ((key * A) % 1))\n```\n\n**c) String Hash (Polynomial Rolling Hash):**\n```python\ndef hash_string(key, table_size):\n    \"\"\"Hash cho string\"\"\"\n    hash_value = 0\n    prime = 31\n    \n    for char in key:\n        hash_value = (hash_value * prime + ord(char)) % table_size\n    \n    return hash_value\n```\n\n**d) Universal Hashing:**\n```python\nimport random\n\ndef universal_hash(key, table_size):\n    \"\"\"Chọn ngẫu nhiên từ họ hash functions\"\"\"\n    p = 1000000007  # Số nguyên tố lớn\n    a = random.randint(1, p - 1)\n    b = random.randint(0, p - 1)\n    \n    return ((a * key + b) % p) % table_size\n```\n\n#### 1.3. Collision (Xung đột)\n\n**Collision xảy ra khi:** 2 key khác nhau có cùng hash value.\n\n```\nhash(\"apple\") = 5\nhash(\"avocado\") = 5  ← Collision!\n```\n\n**Hai phương pháp xử lý collision chính:**\n1. **Chaining (Open Hashing)**\n2. **Open Addressing (Closed Hashing)**\n\n---\n\n### 2. Chaining (Separate Chaining)\n\n#### 2.1. Ý tưởng\n\nMỗi slot trong bảng băm chứa một **linked list** (hoặc dynamic array) các phần tử có cùng hash value.\n\n**Minh họa:**\n```\nHash Table với Chaining:\n\nIndex 0: → [(\"apple\", 5)]\nIndex 1: → []\nIndex 2: → [(\"banana\", 3)] → [(\"blueberry\", 7)]\nIndex 3: → [(\"cherry\", 2)]\nIndex 4: → []\nIndex 5: → [(\"date\", 8)] → [(\"durian\", 9)]\n```\n\n#### 2.2. Cài đặt\n\n```python\nclass HashTableChaining:\n\n**Các khái niệm quan trọng:**\n- Hash Function là một hàm chuyển đổi Key thành một index (vị trí) trong mảng của Hash Table. Một hash function tốt cần phải deterministic, phân bố đều các key (uniform distribution), tính toán nhanh (O(1)), và giảm thiểu xung đột (minimize collisions).\n- Hash Table (Bảng băm) là một cấu trúc dữ liệu lưu trữ các cặp khóa-giá trị (key-value pairs) bằng cách sử dụng một hàm băm (hash function) để tính toán một chỉ mục (index) vào một mảng các \"buckets\" hoặc \"slots\", nơi các giá trị tương ứng được lưu trữ. Mục tiêu chính của Hash Table là cung cấp thời gian truy cập dữ liệu nhanh chóng, với độ phức tạp trung bình O(1) cho các phép toán cơ bản như Insert, Search, Delete. Các thành phần chính bao gồm Key, Value, Hash Function và Bucket/Slot. Tuy nhiên, trong trường hợp xấu nhất (worst case) khi xảy ra nhiều va chạm (collision), độ phức tạp có thể suy biến thành O(n). Hash Table giải quyết vấn đề va chạm bằng các kỹ thuật như Chaining (sử dụng mảng các danh sách liên kết, nơi mỗi phần tử của mảng là một danh sách chứa các cặp khóa-giá trị có cùng giá trị băm), Linear Probing hoặc Quadratic Probing. Các phép toán cơ bản có thể bao gồm insert, search, delete, contains, load_factor và resize. Hash Table không duy trì thứ tự sorted của dữ liệu.\n- Minimize collisions là một yêu cầu của hash function, nghĩa là hàm băm nên được thiết kế để giảm thiểu số lần hai key khác nhau tạo ra cùng một index.\n\n**Mối quan hệ:**\n- Double Hashing là một kỹ thuật giải quyết va chạm được cài đặt trong Hash Table để tìm vị trí trống khi có va chạm.\n- Hash Function áp dụng String Hash như một phương pháp để tính toán hash value cho các chuỗi.\n- Hash Function có tính chất Minimize collisions, nghĩa là nó nên giảm thiểu số lần hai key khác nhau tạo ra cùng một index.\n- Hash Function áp dụng Universal Hashing như một phương pháp để chọn ngẫu nhiên một hàm băm từ một họ các hàm băm.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n    def __init__(self, size=10):\n        self.size = size\n        self.table = [[] for _ in range(size)]\n        self.count = 0\n    \n    def hash_function(self, key):\n        \"\"\"Hash function đơn giản\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def insert(self, key, value):\n        \"\"\"\n        Thêm hoặc cập nhật key-value\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        # Kiểm tra key đã tồn tại chưa\n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                # Update giá trị\n                self.table[index][i] = (key, value)\n                return\n        \n        # Thêm mới\n        self.table[index].append((key, value))\n        self.count += 1\n        \n        # Resize nếu load factor quá cao\n        if self.load_factor() > 0.7:\n            self._resize()\n    \n    def search(self, key):\n        \"\"\"\n        Tìm giá trị theo key\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        for k, v in self.table[index]:\n            if k == key:\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def delete(self, key):\n        \"\"\"\n        Xóa key-value\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                self.table[index].pop(i)\n                self.count -= 1\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def contains(self, key):\n        \"\"\"Kiểm tra key có tồn tại không\"\"\"\n        try:\n            self.search(key)\n            return True\n        except KeyError:\n            return False\n    \n    def load_factor(self):\n        \"\"\"Tính load factor = n / m\"\"\"\n        return self.count / self.size\n    \n    def _resize(self):\n        \"\"\"Tăng kích thước bảng khi load factor cao\"\"\"\n        old_table = self.table\n        self.size *= 2\n        self.table = [[] for _ in range(self.size)]\n        self.count = 0\n        \n        # Rehash tất cả phần tử\n        for bucket in old_table:\n            for key, value in bucket:\n                self.insert(key, value)\n    \n    def __str__(self):\n        result = []\n        for i, bucket in enumerate(self.table):\n            if bucket:\n                result.append(f\"Index {i}: {bucket}\")\n        return \"\n\".join(result) if result else \"Empty hash table\"\n```\n\n#### 2.3. Test Chaining\n\n```python\n# Test\nht = HashTableChaining(size=5)\n\n# Insert\nht.insert(\"apple\", 5)\nht.insert(\"banana\", 3)\nht.insert(\"cherry\", 2)\nht.insert(\"date\", 8)\nht.insert(\"elderberry\", 7)\n\nprint(\"Hash Table:\")\nprint(ht)\nprint(f\"\nLoad factor: {ht.load_factor():.2f}\")\n\n# Search\nprint(f\"\nSearch 'apple': {ht.search('apple')}\")\nprint(f\"Contains 'grape': {ht.contains('grape')}\")\n\n# Update\nht.insert(\"apple\", 10)\nprint(f\"Updated 'apple': {ht.search('apple')}\")\n\n# Delete\nht.delete(\"banana\")\nprint(f\"\nAfter deleting 'banana':\")\nprint(ht)\n```\n\n---\n\n### 3. Open Addressing\n\n#### 3.1. Ý tưởng\n\nKhi collision xảy ra, tìm slot trống khác trong cùng bảng băm bằng **probing**.\n\n**Các phương pháp probing:**\n1. **Linear Probing:** h(k, i) = (h(k) + i) mod m\n2. **Quadratic Probing:** h(k, i) = (h(k) + c₁·i + c₂·i²) mod m\n3. **Double Hashing:** h(k, i) = (h₁(k) + i·h₂(k)) mod m\n\n\n**Các khái niệm quan trọng:**\n- Hash Table (Bảng băm) là một cấu trúc dữ liệu lưu trữ các cặp khóa-giá trị (key-value pairs) bằng cách sử dụng một hàm băm (hash function) để tính toán một chỉ mục (index) vào một mảng các \"buckets\" hoặc \"slots\", nơi các giá trị tương ứng được lưu trữ. Mục tiêu chính của Hash Table là cung cấp thời gian truy cập dữ liệu nhanh chóng, với độ phức tạp trung bình O(1) cho các phép toán cơ bản như Insert, Search, Delete. Các thành phần chính bao gồm Key, Value, Hash Function và Bucket/Slot. Tuy nhiên, trong trường hợp xấu nhất (worst case) khi xảy ra nhiều va chạm (collision), độ phức tạp có thể suy biến thành O(n). Hash Table giải quyết vấn đề va chạm bằng các kỹ thuật như Chaining (sử dụng mảng các danh sách liên kết, nơi mỗi phần tử của mảng là một danh sách chứa các cặp khóa-giá trị có cùng giá trị băm), Linear Probing hoặc Quadratic Probing. Các phép toán cơ bản có thể bao gồm insert, search, delete, contains, load_factor và resize. Hash Table không duy trì thứ tự sorted của dữ liệu.\n\n**Mối quan hệ:**\n- Double Hashing là một kỹ thuật giải quyết va chạm được cài đặt trong Hash Table để tìm vị trí trống khi có va chạm."
        },
        "output_without_context": {
            "question": "Hàm băm (Hash Function) được định nghĩa là gì trong lĩnh vực lập trình?",
            "answer": "Là một hàm chuyển đổi dữ liệu đầu vào thành một giá trị số cố định."
        }
    },
    {
        "topic_description": "Chủ đề này tập trung vào quy ước mã băm của Java, giúp sinh viên hiểu cách phương thức hashCode() hoạt động. Họ sẽ được kiểm tra về các điều kiện cần và mong muốn đối với giá trị trả về của mã băm và cách thực hiện điều này cho các lớp người dùng định nghĩa.",
        "output_with_context": {
            "question": "Phương thức nào trong Java được sử dụng để tính toán giá trị mã băm cho một đối tượng?",
            "answer": "hashCode()",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n        return -1\n    \n    def remove(self, key):\n        \"\"\"Time: O(n/k)\"\"\"\n        index = self._hash(key)\n        \n        for i, (k, v) in enumerate(self.buckets[index]):\n            if k == key:\n                self.buckets[index].pop(i)\n                return\n\n# Test\nhashmap = MyHashMap()\nhashmap.put(1, 1)\nhashmap.put(2, 2)\nprint(hashmap.get(1))    # 1\nhashmap.put(2, 1)\nprint(hashmap.get(2))    # 1\nhashmap.remove(2)\nprint(hashmap.get(2))    # -1\n```\n\n---\n\n### 6. Python Dictionary\n\nPython's `dict` là hash table được tối ưu cao:\n\n```python\n# Tạo dictionary\nd = {}\nd = dict()\nd = {'apple': 5, 'banana': 3}\n\n# Thao tác cơ bản\nd['cherry'] = 2        # Insert/Update - O(1)\nvalue = d['apple']     # Get - O(1)\ndel d['banana']        # Delete - O(1)\nexists = 'apple' in d  # Contains - O(1)\n\n# Methods\nkeys = d.keys()        # Tất cả keys\nvalues = d.values()    # Tất cả values\nitems = d.items()      # Tất cả (key, value) pairs\n\n# Get với default\nvalue = d.get('grape', 0)  # Trả về 0 nếu không tìm thấy\n\n# Duyệt\nfor key in d:\n    print(key, d[key])\n\nfor key, value in d.items():\n    print(key, value)\n\n# Counter\nfrom collections import Counter\nwords = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']\ncount = Counter(words)\nprint(count)  # Counter({'apple': 3, 'banana': 2, 'cherry': 1})\n\n# DefaultDict\nfrom collections import defaultdict\ndd = defaultdict(int)  # Default value = 0\ndd['apple'] += 1\n\ndd_list = defaultdict(list)  # Default value = []\ndd_list['fruits'].append('apple')\n```\n\n---\n\n### 7. Phân tích độ phức tạp\n\n| Thao tác | Average | Worst | Space |\n|----------|---------|-------|-------|\n| Insert | O(1) | O(n) | O(n) |\n| Search | O(1) | O(n) | O(n) |\n| Delete | O(1) | O(n) | O(n) |\n\n**Worst case:** Khi tất cả keys hash về cùng index (collision)\n\n**Load factor ảnh hưởng:**\n- α < 0.7: Performance tốt\n- α > 0.7: Nên resize\n\n---\n\n### 8. Khi nào dùng Hash Table?\n\n**Nên dùng:**\n- ✅ Cần lookup/insert/delete nhanh O(1)\n- ✅ Không cần thứ tự\n- ✅ Unique keys\n- ✅ Counting, frequency\n- ✅ Caching\n\n**Không nên dùng:**\n- ❌ Cần duy trì thứ tự → BST, Sorted Array\n- ❌ Cần range query → BST\n- ❌ Cần min/max → Heap\n- ❌ Memory bị hạn chế → Array\n\n---\n\n\n**Các khái niệm quan trọng:**\n- hash_function (hoặc _hash) là một phép toán cơ bản trong Hash Table, có nhiệm vụ chuyển đổi một khóa (key) thành một chỉ mục số nguyên (index) trong phạm vi kích thước của mảng lưu trữ của bảng băm. Hàm băm này được thiết kế để xử lý cả khóa số nguyên (thường bằng phép chia lấy dư) và khóa chuỗi (bằng cách tính tổng trọng số của các ký tự), sử dụng phép toán modulo để đảm bảo chỉ mục nằm trong giới hạn của bảng. Mục tiêu chính của một hàm băm tốt là phân phối các khóa một cách đồng đều khắp bảng để giảm thiểu va chạm, với độ phức tạp lý tưởng là O(1).\n- _hash là phép toán hàm băm nội bộ của MyHashMap, dùng để tính toán chỉ số (index) của bucket cho một key cụ thể. Công thức băm được sử dụng là `key % self.size`.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Hash Table (Bảng băm)** là một cấu trúc dữ liệu cho phép lưu trữ và truy xuất dữ liệu với độ phức tạp trung bình **O(1)**. Hash Table sử dụng **hash function** để chuyển đổi key thành index trong mảng.\n\n**Thành phần chính:**\n- **Key:** Khóa duy nhất để truy cập giá trị\n- **Value:** Giá trị được lưu trữ\n- **Hash Function:** Hàm chuyển key thành index\n- **Bucket/Slot:** Vị trí trong mảng để lưu cặp key-value\n\n**Ví dụ:**\n```\nKey: \"apple\"  → Hash(\"apple\") → Index: 5\nKey: \"banana\" → Hash(\"banana\") → Index: 2\nKey: \"cherry\" → Hash(\"cherry\") → Index: 8\n\nArray: [_, _, \"banana\", _, _, \"apple\", _, _, \"cherry\", _]\nIndex:  0  1     2      3  4     5     6  7     8      9\n```\n\n#### 1.2. Hash Function\n\n**Yêu cầu của hash function tốt:**\n1. **Deterministic:** Cùng input luôn cho cùng output\n2. **Uniform distribution:** Phân bố đều các key\n3. **Fast to compute:** Tính toán nhanh O(1)\n4. **Minimize collisions:** Giảm xung đột\n\n**Các phương pháp hash phổ biến:**\n\n**a) Division Method:**\n```python\ndef hash_division(key, table_size):\n    \"\"\"h(k) = k mod m\"\"\"\n    return key % table_size\n```\n\n**b) Multiplication Method:**\n```python\ndef hash_multiplication(key, table_size):\n    \"\"\"h(k) = floor(m * (k*A mod 1))\"\"\"\n    A = 0.6180339887  # (√5 - 1) / 2\n    return int(table_size * ((key * A) % 1))\n```\n\n**c) String Hash (Polynomial Rolling Hash):**\n```python\ndef hash_string(key, table_size):\n    \"\"\"Hash cho string\"\"\"\n    hash_value = 0\n    prime = 31\n    \n    for char in key:\n        hash_value = (hash_value * prime + ord(char)) % table_size\n    \n    return hash_value\n```\n\n**d) Universal Hashing:**\n```python\nimport random\n\ndef universal_hash(key, table_size):\n    \"\"\"Chọn ngẫu nhiên từ họ hash functions\"\"\"\n    p = 1000000007  # Số nguyên tố lớn\n    a = random.randint(1, p - 1)\n    b = random.randint(0, p - 1)\n    \n    return ((a * key + b) % p) % table_size\n```\n\n#### 1.3. Collision (Xung đột)\n\n**Collision xảy ra khi:** 2 key khác nhau có cùng hash value.\n\n```\nhash(\"apple\") = 5\nhash(\"avocado\") = 5  ← Collision!\n```\n\n**Hai phương pháp xử lý collision chính:**\n1. **Chaining (Open Hashing)**\n2. **Open Addressing (Closed Hashing)**\n\n---\n\n### 2. Chaining (Separate Chaining)\n\n#### 2.1. Ý tưởng\n\nMỗi slot trong bảng băm chứa một **linked list** (hoặc dynamic array) các phần tử có cùng hash value.\n\n**Minh họa:**\n```\nHash Table với Chaining:\n\nIndex 0: → [(\"apple\", 5)]\nIndex 1: → []\nIndex 2: → [(\"banana\", 3)] → [(\"blueberry\", 7)]\nIndex 3: → [(\"cherry\", 2)]\nIndex 4: → []\nIndex 5: → [(\"date\", 8)] → [(\"durian\", 9)]\n```\n\n#### 2.2. Cài đặt\n\n```python\nclass HashTableChaining:\n\n**Các khái niệm quan trọng:**\n- Hash Function là một hàm chuyển đổi Key thành một index (vị trí) trong mảng của Hash Table. Một hash function tốt cần phải deterministic, phân bố đều các key (uniform distribution), tính toán nhanh (O(1)), và giảm thiểu xung đột (minimize collisions).\n- String Hash (Polynomial Rolling Hash) là một phương pháp hash được sử dụng cho các key là chuỗi ký tự. Nó tính toán hash value bằng cách kết hợp giá trị ASCII của từng ký tự với một số nguyên tố (prime) và phép modulo để giữ giá trị trong phạm vi table_size.\n\n**Mối quan hệ:**\n- String Hash sử dụng hằng số prime = 31 trong công thức tính toán hash value.\n- Hash Function áp dụng String Hash như một phương pháp để tính toán hash value cho các chuỗi.\n- Hash Function áp dụng Division Method như một phương pháp để tính toán hash value.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (original_index + i * i) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n#### 3.4. Double Hashing\n\n```python\nclass HashTableDoubleHashing:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [None] * size\n        self.count = 0\n    \n    def hash1(self, key):\n        \"\"\"Primary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def hash2(self, key):\n        \"\"\"Secondary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 37 + ord(char))\n            return 1 + (hash_value % (self.size - 1))\n        return 1 + (key % (self.size - 1))\n    \n    def insert(self, key, value):\n        \"\"\"\n        Double hashing: h(k, i) = (h1(k) + i*h2(k)) mod m\n        \"\"\"\n        index = self.hash1(key)\n        step = self.hash2(key)\n        i = 0\n        \n        while self.table[index] is not None:\n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (self.hash1(key) + i * step) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n---\n\n### 4. So sánh Chaining vs Open Addressing\n\n| Đặc điểm | Chaining | Open Addressing |\n|----------|----------|-----------------|\n| **Collision** | Dùng linked list | Tìm slot khác |\n| **Memory** | Thêm memory cho pointers | Chỉ dùng array |\n| **Load factor** | Có thể > 1 | Phải < 1 |\n| **Cache** | Kém (pointers) | Tốt (locality) |\n| **Delete** | Dễ | Phức tạp (cần marker) |\n| **Resize** | Ít cần | Cần thường xuyên |\n| **Performance** | Ổn định | Giảm khi đầy |\n\n**Khi nào dùng:**\n- **Chaining:** Không biết trước số phần tử, collision rate cao\n- **Open Addressing:** Biết trước size, cần tối ưu cache\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Two Sum Problem\n\n```python\ndef two_sum(nums, target):\n    \"\"\"\n    Tìm 2 số có tổng = target\n    Time: O(n), Space: O(n)\n    \"\"\"\n    hash_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in hash_map:\n            return [hash_map[complement], i]\n        \n        hash_map[num] = i\n    \n    return []\n\n# Test\nprint(two_sum([2, 7, 11, 15], 9))  # [0, 1]\n```\n\n#### 5.2. Group Anagrams\n\n```python\ndef group_anagrams(words):\n    \"\"\"\n    Nhóm các từ là anagram của nhau\n    Time: O(n * k log k) với k là độ dài từ\n    \"\"\"\n    from collections import defaultdict\n    \n    anagram_map = defaultdict(list)\n    \n    for word in words:\n        # Sort chữ cái làm key\n        key = ''.join(sorted(word))\n        anagram_map[key].append(word)\n    \n    return list(anagram_map.values())\n\n# Test\nwords = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(group_anagrams(words))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n```\n\n\n**Các khái niệm quan trọng:**\n- hash1 là hàm băm chính được sử dụng trong Double Hashing để tính toán vị trí ban đầu của một khóa trong bảng băm. Đối với khóa là chuỗi, nó tính tổng trọng số của các ký tự; đối với khóa là số nguyên, nó sử dụng phép toán modulo. Độ phức tạp thời gian của hash1 phụ thuộc vào độ dài của khóa, ví dụ O(k) cho chuỗi có độ dài k.\n- hash2 là hàm băm phụ được sử dụng trong Double Hashing để tính toán bước nhảy (step size) khi xảy ra va chạm. Hàm này phải đảm bảo trả về một giá trị khác 0 và tương đối nguyên tố với kích thước bảng băm để đảm bảo tất cả các vị trí trong bảng có thể được duyệt qua. Đối với khóa là chuỗi, nó tính tổng trọng số của các ký tự; đối với khóa là số nguyên, nó sử dụng phép toán modulo. Độ phức tạp thời gian của hash2 phụ thuộc vào độ dài của khóa, ví dụ O(k) cho chuỗi có độ dài k.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n    def __init__(self, size=10):\n        self.size = size\n        self.table = [[] for _ in range(size)]\n        self.count = 0\n    \n    def hash_function(self, key):\n        \"\"\"Hash function đơn giản\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def insert(self, key, value):\n        \"\"\"\n        Thêm hoặc cập nhật key-value\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        # Kiểm tra key đã tồn tại chưa\n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                # Update giá trị\n                self.table[index][i] = (key, value)\n                return\n        \n        # Thêm mới\n        self.table[index].append((key, value))\n        self.count += 1\n        \n        # Resize nếu load factor quá cao\n        if self.load_factor() > 0.7:\n            self._resize()\n    \n    def search(self, key):\n        \"\"\"\n        Tìm giá trị theo key\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        for k, v in self.table[index]:\n            if k == key:\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def delete(self, key):\n        \"\"\"\n        Xóa key-value\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                self.table[index].pop(i)\n                self.count -= 1\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def contains(self, key):\n        \"\"\"Kiểm tra key có tồn tại không\"\"\"\n        try:\n            self.search(key)\n            return True\n        except KeyError:\n            return False\n    \n    def load_factor(self):\n        \"\"\"Tính load factor = n / m\"\"\"\n        return self.count / self.size\n    \n    def _resize(self):\n        \"\"\"Tăng kích thước bảng khi load factor cao\"\"\"\n        old_table = self.table\n        self.size *= 2\n        self.table = [[] for _ in range(self.size)]\n        self.count = 0\n        \n        # Rehash tất cả phần tử\n        for bucket in old_table:\n            for key, value in bucket:\n                self.insert(key, value)\n    \n    def __str__(self):\n        result = []\n        for i, bucket in enumerate(self.table):\n            if bucket:\n                result.append(f\"Index {i}: {bucket}\")\n        return \"\n\".join(result) if result else \"Empty hash table\"\n```\n\n#### 2.3. Test Chaining\n\n```python\n# Test\nht = HashTableChaining(size=5)\n\n# Insert\nht.insert(\"apple\", 5)\nht.insert(\"banana\", 3)\nht.insert(\"cherry\", 2)\nht.insert(\"date\", 8)\nht.insert(\"elderberry\", 7)\n\nprint(\"Hash Table:\")\nprint(ht)\nprint(f\"\nLoad factor: {ht.load_factor():.2f}\")\n\n# Search\nprint(f\"\nSearch 'apple': {ht.search('apple')}\")\nprint(f\"Contains 'grape': {ht.contains('grape')}\")\n\n# Update\nht.insert(\"apple\", 10)\nprint(f\"Updated 'apple': {ht.search('apple')}\")\n\n# Delete\nht.delete(\"banana\")\nprint(f\"\nAfter deleting 'banana':\")\nprint(ht)\n```\n\n---\n\n### 3. Open Addressing\n\n#### 3.1. Ý tưởng\n\nKhi collision xảy ra, tìm slot trống khác trong cùng bảng băm bằng **probing**.\n\n**Các phương pháp probing:**\n1. **Linear Probing:** h(k, i) = (h(k) + i) mod m\n2. **Quadratic Probing:** h(k, i) = (h(k) + c₁·i + c₂·i²) mod m\n3. **Double Hashing:** h(k, i) = (h₁(k) + i·h₂(k)) mod m\n\n\n**Các khái niệm quan trọng:**\n- hash_function (hoặc _hash) là một phép toán cơ bản trong Hash Table, có nhiệm vụ chuyển đổi một khóa (key) thành một chỉ mục số nguyên (index) trong phạm vi kích thước của mảng lưu trữ của bảng băm. Hàm băm này được thiết kế để xử lý cả khóa số nguyên (thường bằng phép chia lấy dư) và khóa chuỗi (bằng cách tính tổng trọng số của các ký tự), sử dụng phép toán modulo để đảm bảo chỉ mục nằm trong giới hạn của bảng. Mục tiêu chính của một hàm băm tốt là phân phối các khóa một cách đồng đều khắp bảng để giảm thiểu va chạm, với độ phức tạp lý tưởng là O(1).\n\n**Mối quan hệ:**\n- HashTableLinearProbing cài đặt phép toán hash_function để băm khóa.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n#### 3.2. Linear Probing\n\n```python\nclass HashTableLinearProbing:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [None] * size\n        self.count = 0\n        self.DELETED = \"DELETED\"  # Marker cho phần tử đã xóa\n    \n    def hash_function(self, key):\n        \"\"\"Hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def insert(self, key, value):\n        \"\"\"\n        Thêm key-value với linear probing\n        Time: O(1) average\n        \"\"\"\n        if self.load_factor() >= 0.7:\n            self._resize()\n        \n        index = self.hash_function(key)\n        original_index = index\n        i = 0\n        \n        while self.table[index] is not None:\n            # Nếu key đã tồn tại, update\n            if self.table[index] != self.DELETED and self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            # Linear probing\n            i += 1\n            index = (original_index + i) % self.size\n            \n            # Nếu đã duyệt hết bảng\n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        # Tìm được slot trống\n        self.table[index] = (key, value)\n        self.count += 1\n    \n    def search(self, key):\n        \"\"\"\n        Tìm giá trị theo key\n        Time: O(1) average\n        \"\"\"\n        index = self.hash_function(key)\n        original_index = index\n        i = 0\n        \n        while self.table[index] is not None:\n            if self.table[index] != self.DELETED and self.table[index][0] == key:\n                return self.table[index][1]\n            \n            i += 1\n            index = (original_index + i) % self.size\n            \n            if i >= self.size:\n                break\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def delete(self, key):\n        \"\"\"\n        Xóa key-value\n        Đánh dấu DELETED thay vì xóa thật\n        \"\"\"\n        index = self.hash_function(key)\n        original_index = index\n        i = 0\n        \n        while self.table[index] is not None:\n            if self.table[index] != self.DELETED and self.table[index][0] == key:\n                value = self.table[index][1]\n                self.table[index] = self.DELETED\n                self.count -= 1\n                return value\n            \n            i += 1\n            index = (original_index + i) % self.size\n            \n            if i >= self.size:\n                break\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def load_factor(self):\n        return self.count / self.size\n    \n    def _resize(self):\n        \"\"\"Resize bảng\"\"\"\n        old_table = self.table\n        self.size *= 2\n        self.table = [None] * self.size\n        self.count = 0\n        \n        for item in old_table:\n            if item is not None and item != self.DELETED:\n                self.insert(item[0], item[1])\n    \n    def __str__(self):\n        result = []\n        for i, item in enumerate(self.table):\n            if item is not None and item != self.DELETED:\n                result.append(f\"Index {i}: {item}\")\n        return \"\n\".join(result) if result else \"Empty hash table\"\n```\n\n#### 3.3. Quadratic Probing\n\n```python\nclass HashTableQuadraticProbing:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [None] * size\n        self.count = 0\n    \n    def hash_function(self, key):\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def insert(self, key, value):\n        \"\"\"\n        Quadratic probing: h(k, i) = (h(k) + i²) mod m\n        \"\"\"\n        index = self.hash_function(key)\n        original_index = index\n        i = 0\n        \n        while self.table[index] is not None:\n\n**Các khái niệm quan trọng:**\n- hash_function (hoặc _hash) là một phép toán cơ bản trong Hash Table, có nhiệm vụ chuyển đổi một khóa (key) thành một chỉ mục số nguyên (index) trong phạm vi kích thước của mảng lưu trữ của bảng băm. Hàm băm này được thiết kế để xử lý cả khóa số nguyên (thường bằng phép chia lấy dư) và khóa chuỗi (bằng cách tính tổng trọng số của các ký tự), sử dụng phép toán modulo để đảm bảo chỉ mục nằm trong giới hạn của bảng. Mục tiêu chính của một hàm băm tốt là phân phối các khóa một cách đồng đều khắp bảng để giảm thiểu va chạm, với độ phức tạp lý tưởng là O(1).\n\n**Mối quan hệ:**\n- HashTableLinearProbing cài đặt phép toán hash_function để băm khóa."
        },
        "output_without_context": {
            "question": "Phương thức hashCode() trong Java được sử dụng để làm gì?",
            "answer": "Trả về một giá trị băm nguyên cho đối tượng, giúp xác định sự khác biệt giữa các đối tượng."
        }
    },
    {
        "topic_description": "Chủ đề này phân tích xung đột xảy ra khi hai khóa khác nhau băm vào cùng một chỉ mục trong một bảng băm. Sinh viên sẽ hiểu nguyên nhân, đặc điểm của xung đột cùng với cách xử lý. Điều này có thể được kiểm tra qua các câu hỏi về ví dụ và đồ thị.",
        "output_with_context": {
            "question": "Xung đột trong bảng băm xảy ra khi hai khóa khác nhau được ánh xạ tới cùng một chỉ mục. Phương pháp nào sau đây được sử dụng để xử lý xung đột trong bảng băm?",
            "answer": "Chaining (Open Hashing) và Open Addressing.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Hash Table (Bảng băm)** là một cấu trúc dữ liệu cho phép lưu trữ và truy xuất dữ liệu với độ phức tạp trung bình **O(1)**. Hash Table sử dụng **hash function** để chuyển đổi key thành index trong mảng.\n\n**Thành phần chính:**\n- **Key:** Khóa duy nhất để truy cập giá trị\n- **Value:** Giá trị được lưu trữ\n- **Hash Function:** Hàm chuyển key thành index\n- **Bucket/Slot:** Vị trí trong mảng để lưu cặp key-value\n\n**Ví dụ:**\n```\nKey: \"apple\"  → Hash(\"apple\") → Index: 5\nKey: \"banana\" → Hash(\"banana\") → Index: 2\nKey: \"cherry\" → Hash(\"cherry\") → Index: 8\n\nArray: [_, _, \"banana\", _, _, \"apple\", _, _, \"cherry\", _]\nIndex:  0  1     2      3  4     5     6  7     8      9\n```\n\n#### 1.2. Hash Function\n\n**Yêu cầu của hash function tốt:**\n1. **Deterministic:** Cùng input luôn cho cùng output\n2. **Uniform distribution:** Phân bố đều các key\n3. **Fast to compute:** Tính toán nhanh O(1)\n4. **Minimize collisions:** Giảm xung đột\n\n**Các phương pháp hash phổ biến:**\n\n**a) Division Method:**\n```python\ndef hash_division(key, table_size):\n    \"\"\"h(k) = k mod m\"\"\"\n    return key % table_size\n```\n\n**b) Multiplication Method:**\n```python\ndef hash_multiplication(key, table_size):\n    \"\"\"h(k) = floor(m * (k*A mod 1))\"\"\"\n    A = 0.6180339887  # (√5 - 1) / 2\n    return int(table_size * ((key * A) % 1))\n```\n\n**c) String Hash (Polynomial Rolling Hash):**\n```python\ndef hash_string(key, table_size):\n    \"\"\"Hash cho string\"\"\"\n    hash_value = 0\n    prime = 31\n    \n    for char in key:\n        hash_value = (hash_value * prime + ord(char)) % table_size\n    \n    return hash_value\n```\n\n**d) Universal Hashing:**\n```python\nimport random\n\ndef universal_hash(key, table_size):\n    \"\"\"Chọn ngẫu nhiên từ họ hash functions\"\"\"\n    p = 1000000007  # Số nguyên tố lớn\n    a = random.randint(1, p - 1)\n    b = random.randint(0, p - 1)\n    \n    return ((a * key + b) % p) % table_size\n```\n\n#### 1.3. Collision (Xung đột)\n\n**Collision xảy ra khi:** 2 key khác nhau có cùng hash value.\n\n```\nhash(\"apple\") = 5\nhash(\"avocado\") = 5  ← Collision!\n```\n\n**Hai phương pháp xử lý collision chính:**\n1. **Chaining (Open Hashing)**\n2. **Open Addressing (Closed Hashing)**\n\n---\n\n### 2. Chaining (Separate Chaining)\n\n#### 2.1. Ý tưởng\n\nMỗi slot trong bảng băm chứa một **linked list** (hoặc dynamic array) các phần tử có cùng hash value.\n\n**Minh họa:**\n```\nHash Table với Chaining:\n\nIndex 0: → [(\"apple\", 5)]\nIndex 1: → []\nIndex 2: → [(\"banana\", 3)] → [(\"blueberry\", 7)]\nIndex 3: → [(\"cherry\", 2)]\nIndex 4: → []\nIndex 5: → [(\"date\", 8)] → [(\"durian\", 9)]\n```\n\n#### 2.2. Cài đặt\n\n```python\nclass HashTableChaining:\n\n**Các khái niệm quan trọng:**\n- Chaining (còn gọi là Open Hashing hoặc Separate Chaining) là một kỹ thuật xử lý va chạm (xung đột) trong Hash Table. Trong kỹ thuật này, mỗi vị trí (slot/bucket) trong bảng băm là một cấu trúc dữ liệu (thường là danh sách liên kết hoặc mảng động) chứa tất cả các cặp khóa-giá trị hoặc phần tử băm vào cùng một chỉ mục (hash value). Khi va chạm xảy ra, cặp khóa-giá trị mới chỉ đơn giản được thêm vào danh sách tại vị trí đó, cho phép lưu trữ nhiều phần tử tại cùng một chỉ mục.\n- Collision (va chạm/xung đột) là một tính chất hoặc tình huống xảy ra trong Hash Table khi hai hoặc nhiều khóa khác nhau được hàm băm ánh xạ tới cùng một chỉ mục (bucket/vị trí/slot) trong bảng băm. Đây là một vấn đề quan trọng cần được xử lý để đảm bảo tính đúng đắn và hiệu quả của Hash Table. Các phương pháp phổ biến để giải quyết va chạm bao gồm chaining (sử dụng danh sách liên kết tại mỗi chỉ mục) và open addressing (tìm kiếm một vị trí khác trong bảng).\n\n**Mối quan hệ:**\n- Chaining giải quyết vấn đề Collision bằng cách sử dụng linked list tại mỗi vị trí trong bảng băm để lưu trữ các phần tử có cùng giá trị băm.\n- Chaining giải quyết vấn đề Collision bằng cách lưu trữ các phần tử có cùng hash value vào một linked list tại mỗi slot.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n        return -1\n    \n    def remove(self, key):\n        \"\"\"Time: O(n/k)\"\"\"\n        index = self._hash(key)\n        \n        for i, (k, v) in enumerate(self.buckets[index]):\n            if k == key:\n                self.buckets[index].pop(i)\n                return\n\n# Test\nhashmap = MyHashMap()\nhashmap.put(1, 1)\nhashmap.put(2, 2)\nprint(hashmap.get(1))    # 1\nhashmap.put(2, 1)\nprint(hashmap.get(2))    # 1\nhashmap.remove(2)\nprint(hashmap.get(2))    # -1\n```\n\n---\n\n### 6. Python Dictionary\n\nPython's `dict` là hash table được tối ưu cao:\n\n```python\n# Tạo dictionary\nd = {}\nd = dict()\nd = {'apple': 5, 'banana': 3}\n\n# Thao tác cơ bản\nd['cherry'] = 2        # Insert/Update - O(1)\nvalue = d['apple']     # Get - O(1)\ndel d['banana']        # Delete - O(1)\nexists = 'apple' in d  # Contains - O(1)\n\n# Methods\nkeys = d.keys()        # Tất cả keys\nvalues = d.values()    # Tất cả values\nitems = d.items()      # Tất cả (key, value) pairs\n\n# Get với default\nvalue = d.get('grape', 0)  # Trả về 0 nếu không tìm thấy\n\n# Duyệt\nfor key in d:\n    print(key, d[key])\n\nfor key, value in d.items():\n    print(key, value)\n\n# Counter\nfrom collections import Counter\nwords = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']\ncount = Counter(words)\nprint(count)  # Counter({'apple': 3, 'banana': 2, 'cherry': 1})\n\n# DefaultDict\nfrom collections import defaultdict\ndd = defaultdict(int)  # Default value = 0\ndd['apple'] += 1\n\ndd_list = defaultdict(list)  # Default value = []\ndd_list['fruits'].append('apple')\n```\n\n---\n\n### 7. Phân tích độ phức tạp\n\n| Thao tác | Average | Worst | Space |\n|----------|---------|-------|-------|\n| Insert | O(1) | O(n) | O(n) |\n| Search | O(1) | O(n) | O(n) |\n| Delete | O(1) | O(n) | O(n) |\n\n**Worst case:** Khi tất cả keys hash về cùng index (collision)\n\n**Load factor ảnh hưởng:**\n- α < 0.7: Performance tốt\n- α > 0.7: Nên resize\n\n---\n\n### 8. Khi nào dùng Hash Table?\n\n**Nên dùng:**\n- ✅ Cần lookup/insert/delete nhanh O(1)\n- ✅ Không cần thứ tự\n- ✅ Unique keys\n- ✅ Counting, frequency\n- ✅ Caching\n\n**Không nên dùng:**\n- ❌ Cần duy trì thứ tự → BST, Sorted Array\n- ❌ Cần range query → BST\n- ❌ Cần min/max → Heap\n- ❌ Memory bị hạn chế → Array\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Collision (va chạm/xung đột) là một tính chất hoặc tình huống xảy ra trong Hash Table khi hai hoặc nhiều khóa khác nhau được hàm băm ánh xạ tới cùng một chỉ mục (bucket/vị trí/slot) trong bảng băm. Đây là một vấn đề quan trọng cần được xử lý để đảm bảo tính đúng đắn và hiệu quả của Hash Table. Các phương pháp phổ biến để giải quyết va chạm bao gồm chaining (sử dụng danh sách liên kết tại mỗi chỉ mục) và open addressing (tìm kiếm một vị trí khác trong bảng).\n\n**Mối quan hệ:**\n- Chaining giải quyết vấn đề Collision bằng cách sử dụng linked list tại mỗi vị trí trong bảng băm để lưu trữ các phần tử có cùng giá trị băm.\n- Chaining giải quyết vấn đề Collision bằng cách lưu trữ các phần tử có cùng hash value vào một linked list tại mỗi slot.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n    def __init__(self, size=10):\n        self.size = size\n        self.table = [[] for _ in range(size)]\n        self.count = 0\n    \n    def hash_function(self, key):\n        \"\"\"Hash function đơn giản\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def insert(self, key, value):\n        \"\"\"\n        Thêm hoặc cập nhật key-value\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        # Kiểm tra key đã tồn tại chưa\n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                # Update giá trị\n                self.table[index][i] = (key, value)\n                return\n        \n        # Thêm mới\n        self.table[index].append((key, value))\n        self.count += 1\n        \n        # Resize nếu load factor quá cao\n        if self.load_factor() > 0.7:\n            self._resize()\n    \n    def search(self, key):\n        \"\"\"\n        Tìm giá trị theo key\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        for k, v in self.table[index]:\n            if k == key:\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def delete(self, key):\n        \"\"\"\n        Xóa key-value\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                self.table[index].pop(i)\n                self.count -= 1\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def contains(self, key):\n        \"\"\"Kiểm tra key có tồn tại không\"\"\"\n        try:\n            self.search(key)\n            return True\n        except KeyError:\n            return False\n    \n    def load_factor(self):\n        \"\"\"Tính load factor = n / m\"\"\"\n        return self.count / self.size\n    \n    def _resize(self):\n        \"\"\"Tăng kích thước bảng khi load factor cao\"\"\"\n        old_table = self.table\n        self.size *= 2\n        self.table = [[] for _ in range(self.size)]\n        self.count = 0\n        \n        # Rehash tất cả phần tử\n        for bucket in old_table:\n            for key, value in bucket:\n                self.insert(key, value)\n    \n    def __str__(self):\n        result = []\n        for i, bucket in enumerate(self.table):\n            if bucket:\n                result.append(f\"Index {i}: {bucket}\")\n        return \"\n\".join(result) if result else \"Empty hash table\"\n```\n\n#### 2.3. Test Chaining\n\n```python\n# Test\nht = HashTableChaining(size=5)\n\n# Insert\nht.insert(\"apple\", 5)\nht.insert(\"banana\", 3)\nht.insert(\"cherry\", 2)\nht.insert(\"date\", 8)\nht.insert(\"elderberry\", 7)\n\nprint(\"Hash Table:\")\nprint(ht)\nprint(f\"\nLoad factor: {ht.load_factor():.2f}\")\n\n# Search\nprint(f\"\nSearch 'apple': {ht.search('apple')}\")\nprint(f\"Contains 'grape': {ht.contains('grape')}\")\n\n# Update\nht.insert(\"apple\", 10)\nprint(f\"Updated 'apple': {ht.search('apple')}\")\n\n# Delete\nht.delete(\"banana\")\nprint(f\"\nAfter deleting 'banana':\")\nprint(ht)\n```\n\n---\n\n### 3. Open Addressing\n\n#### 3.1. Ý tưởng\n\nKhi collision xảy ra, tìm slot trống khác trong cùng bảng băm bằng **probing**.\n\n**Các phương pháp probing:**\n1. **Linear Probing:** h(k, i) = (h(k) + i) mod m\n2. **Quadratic Probing:** h(k, i) = (h(k) + c₁·i + c₂·i²) mod m\n3. **Double Hashing:** h(k, i) = (h₁(k) + i·h₂(k)) mod m\n\n\n**Các khái niệm quan trọng:**\n- Chaining (còn gọi là Open Hashing hoặc Separate Chaining) là một kỹ thuật xử lý va chạm (xung đột) trong Hash Table. Trong kỹ thuật này, mỗi vị trí (slot/bucket) trong bảng băm là một cấu trúc dữ liệu (thường là danh sách liên kết hoặc mảng động) chứa tất cả các cặp khóa-giá trị hoặc phần tử băm vào cùng một chỉ mục (hash value). Khi va chạm xảy ra, cặp khóa-giá trị mới chỉ đơn giản được thêm vào danh sách tại vị trí đó, cho phép lưu trữ nhiều phần tử tại cùng một chỉ mục.\n\n**Mối quan hệ:**\n- Chaining giải quyết vấn đề Collision bằng cách sử dụng linked list tại mỗi vị trí trong bảng băm để lưu trữ các phần tử có cùng giá trị băm.\n- Chaining giải quyết vấn đề Collision bằng cách lưu trữ các phần tử có cùng hash value vào một linked list tại mỗi slot.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (original_index + i * i) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n#### 3.4. Double Hashing\n\n```python\nclass HashTableDoubleHashing:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [None] * size\n        self.count = 0\n    \n    def hash1(self, key):\n        \"\"\"Primary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def hash2(self, key):\n        \"\"\"Secondary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 37 + ord(char))\n            return 1 + (hash_value % (self.size - 1))\n        return 1 + (key % (self.size - 1))\n    \n    def insert(self, key, value):\n        \"\"\"\n        Double hashing: h(k, i) = (h1(k) + i*h2(k)) mod m\n        \"\"\"\n        index = self.hash1(key)\n        step = self.hash2(key)\n        i = 0\n        \n        while self.table[index] is not None:\n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (self.hash1(key) + i * step) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n---\n\n### 4. So sánh Chaining vs Open Addressing\n\n| Đặc điểm | Chaining | Open Addressing |\n|----------|----------|-----------------|\n| **Collision** | Dùng linked list | Tìm slot khác |\n| **Memory** | Thêm memory cho pointers | Chỉ dùng array |\n| **Load factor** | Có thể > 1 | Phải < 1 |\n| **Cache** | Kém (pointers) | Tốt (locality) |\n| **Delete** | Dễ | Phức tạp (cần marker) |\n| **Resize** | Ít cần | Cần thường xuyên |\n| **Performance** | Ổn định | Giảm khi đầy |\n\n**Khi nào dùng:**\n- **Chaining:** Không biết trước số phần tử, collision rate cao\n- **Open Addressing:** Biết trước size, cần tối ưu cache\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Two Sum Problem\n\n```python\ndef two_sum(nums, target):\n    \"\"\"\n    Tìm 2 số có tổng = target\n    Time: O(n), Space: O(n)\n    \"\"\"\n    hash_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in hash_map:\n            return [hash_map[complement], i]\n        \n        hash_map[num] = i\n    \n    return []\n\n# Test\nprint(two_sum([2, 7, 11, 15], 9))  # [0, 1]\n```\n\n#### 5.2. Group Anagrams\n\n```python\ndef group_anagrams(words):\n    \"\"\"\n    Nhóm các từ là anagram của nhau\n    Time: O(n * k log k) với k là độ dài từ\n    \"\"\"\n    from collections import defaultdict\n    \n    anagram_map = defaultdict(list)\n    \n    for word in words:\n        # Sort chữ cái làm key\n        key = ''.join(sorted(word))\n        anagram_map[key].append(word)\n    \n    return list(anagram_map.values())\n\n# Test\nwords = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(group_anagrams(words))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n```\n\n\n**Các khái niệm quan trọng:**\n- Collision (va chạm/xung đột) là một tính chất hoặc tình huống xảy ra trong Hash Table khi hai hoặc nhiều khóa khác nhau được hàm băm ánh xạ tới cùng một chỉ mục (bucket/vị trí/slot) trong bảng băm. Đây là một vấn đề quan trọng cần được xử lý để đảm bảo tính đúng đắn và hiệu quả của Hash Table. Các phương pháp phổ biến để giải quyết va chạm bao gồm chaining (sử dụng danh sách liên kết tại mỗi chỉ mục) và open addressing (tìm kiếm một vị trí khác trong bảng).\n\n**Mối quan hệ:**\n- Chaining giải quyết vấn đề Collision bằng cách sử dụng linked list tại mỗi vị trí trong bảng băm để lưu trữ các phần tử có cùng giá trị băm.\n- Chaining giải quyết vấn đề Collision bằng cách lưu trữ các phần tử có cùng hash value vào một linked list tại mỗi slot."
        },
        "output_without_context": {
            "question": "Xung đột trong hàm băm xảy ra khi hai khóa khác nhau băm vào cùng một chỉ mục trong bảng băm. Điều này có thể được xử lý bằng cách nào?",
            "answer": "Sử dụng phương pháp xử lý xung đột như chaining hoặc open addressing."
        }
    },
    {
        "topic_description": "Chủ đề này hướng dẫn về bảng băm chuỗi riêng biệt (Separate-Chaining Symbol Table), sự triển khai và cách mà bảng này xử lý việc xung đột, cùng với hiệu suất của nó. Học sinh sẽ cần ứng dụng kiến thức trong các câu hỏi liên quan từ tuần trước.",
        "output_with_context": {
            "question": "Khi sử dụng bảng băm chuỗi riêng biệt (Separate Chaining), nếu hai khóa khác nhau có cùng giá trị băm, chúng sẽ được lưu trữ như thế nào trong bảng băm?",
            "answer": "Chúng sẽ được lưu trữ trong một danh sách liên kết tại cùng một chỉ mục trong bảng băm.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Hash Table (Bảng băm)** là một cấu trúc dữ liệu cho phép lưu trữ và truy xuất dữ liệu với độ phức tạp trung bình **O(1)**. Hash Table sử dụng **hash function** để chuyển đổi key thành index trong mảng.\n\n**Thành phần chính:**\n- **Key:** Khóa duy nhất để truy cập giá trị\n- **Value:** Giá trị được lưu trữ\n- **Hash Function:** Hàm chuyển key thành index\n- **Bucket/Slot:** Vị trí trong mảng để lưu cặp key-value\n\n**Ví dụ:**\n```\nKey: \"apple\"  → Hash(\"apple\") → Index: 5\nKey: \"banana\" → Hash(\"banana\") → Index: 2\nKey: \"cherry\" → Hash(\"cherry\") → Index: 8\n\nArray: [_, _, \"banana\", _, _, \"apple\", _, _, \"cherry\", _]\nIndex:  0  1     2      3  4     5     6  7     8      9\n```\n\n#### 1.2. Hash Function\n\n**Yêu cầu của hash function tốt:**\n1. **Deterministic:** Cùng input luôn cho cùng output\n2. **Uniform distribution:** Phân bố đều các key\n3. **Fast to compute:** Tính toán nhanh O(1)\n4. **Minimize collisions:** Giảm xung đột\n\n**Các phương pháp hash phổ biến:**\n\n**a) Division Method:**\n```python\ndef hash_division(key, table_size):\n    \"\"\"h(k) = k mod m\"\"\"\n    return key % table_size\n```\n\n**b) Multiplication Method:**\n```python\ndef hash_multiplication(key, table_size):\n    \"\"\"h(k) = floor(m * (k*A mod 1))\"\"\"\n    A = 0.6180339887  # (√5 - 1) / 2\n    return int(table_size * ((key * A) % 1))\n```\n\n**c) String Hash (Polynomial Rolling Hash):**\n```python\ndef hash_string(key, table_size):\n    \"\"\"Hash cho string\"\"\"\n    hash_value = 0\n    prime = 31\n    \n    for char in key:\n        hash_value = (hash_value * prime + ord(char)) % table_size\n    \n    return hash_value\n```\n\n**d) Universal Hashing:**\n```python\nimport random\n\ndef universal_hash(key, table_size):\n    \"\"\"Chọn ngẫu nhiên từ họ hash functions\"\"\"\n    p = 1000000007  # Số nguyên tố lớn\n    a = random.randint(1, p - 1)\n    b = random.randint(0, p - 1)\n    \n    return ((a * key + b) % p) % table_size\n```\n\n#### 1.3. Collision (Xung đột)\n\n**Collision xảy ra khi:** 2 key khác nhau có cùng hash value.\n\n```\nhash(\"apple\") = 5\nhash(\"avocado\") = 5  ← Collision!\n```\n\n**Hai phương pháp xử lý collision chính:**\n1. **Chaining (Open Hashing)**\n2. **Open Addressing (Closed Hashing)**\n\n---\n\n### 2. Chaining (Separate Chaining)\n\n#### 2.1. Ý tưởng\n\nMỗi slot trong bảng băm chứa một **linked list** (hoặc dynamic array) các phần tử có cùng hash value.\n\n**Minh họa:**\n```\nHash Table với Chaining:\n\nIndex 0: → [(\"apple\", 5)]\nIndex 1: → []\nIndex 2: → [(\"banana\", 3)] → [(\"blueberry\", 7)]\nIndex 3: → [(\"cherry\", 2)]\nIndex 4: → []\nIndex 5: → [(\"date\", 8)] → [(\"durian\", 9)]\n```\n\n#### 2.2. Cài đặt\n\n```python\nclass HashTableChaining:\n\n**Các khái niệm quan trọng:**\n- Chaining (còn gọi là Open Hashing hoặc Separate Chaining) là một kỹ thuật xử lý va chạm (xung đột) trong Hash Table. Trong kỹ thuật này, mỗi vị trí (slot/bucket) trong bảng băm là một cấu trúc dữ liệu (thường là danh sách liên kết hoặc mảng động) chứa tất cả các cặp khóa-giá trị hoặc phần tử băm vào cùng một chỉ mục (hash value). Khi va chạm xảy ra, cặp khóa-giá trị mới chỉ đơn giản được thêm vào danh sách tại vị trí đó, cho phép lưu trữ nhiều phần tử tại cùng một chỉ mục.\n- Collision (va chạm/xung đột) là một tính chất hoặc tình huống xảy ra trong Hash Table khi hai hoặc nhiều khóa khác nhau được hàm băm ánh xạ tới cùng một chỉ mục (bucket/vị trí/slot) trong bảng băm. Đây là một vấn đề quan trọng cần được xử lý để đảm bảo tính đúng đắn và hiệu quả của Hash Table. Các phương pháp phổ biến để giải quyết va chạm bao gồm chaining (sử dụng danh sách liên kết tại mỗi chỉ mục) và open addressing (tìm kiếm một vị trí khác trong bảng).\n- HashTableChaining là một cài đặt cụ thể của Hash Table sử dụng phương pháp Chaining để xử lý xung đột. Mỗi vị trí trong mảng chính của HashTableChaining sẽ trỏ đến một Linked List (hoặc một cấu trúc dữ liệu tương tự) chứa các cặp key-value có cùng giá trị băm.\n\n**Mối quan hệ:**\n- Chaining giải quyết vấn đề Collision bằng cách sử dụng linked list tại mỗi vị trí trong bảng băm để lưu trữ các phần tử có cùng giá trị băm.\n- Chaining giải quyết vấn đề Collision bằng cách lưu trữ các phần tử có cùng hash value vào một linked list tại mỗi slot.\n- HashTableChaining cài đặt phương pháp Chaining để xử lý xung đột.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (original_index + i * i) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n#### 3.4. Double Hashing\n\n```python\nclass HashTableDoubleHashing:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [None] * size\n        self.count = 0\n    \n    def hash1(self, key):\n        \"\"\"Primary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def hash2(self, key):\n        \"\"\"Secondary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 37 + ord(char))\n            return 1 + (hash_value % (self.size - 1))\n        return 1 + (key % (self.size - 1))\n    \n    def insert(self, key, value):\n        \"\"\"\n        Double hashing: h(k, i) = (h1(k) + i*h2(k)) mod m\n        \"\"\"\n        index = self.hash1(key)\n        step = self.hash2(key)\n        i = 0\n        \n        while self.table[index] is not None:\n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (self.hash1(key) + i * step) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n---\n\n### 4. So sánh Chaining vs Open Addressing\n\n| Đặc điểm | Chaining | Open Addressing |\n|----------|----------|-----------------|\n| **Collision** | Dùng linked list | Tìm slot khác |\n| **Memory** | Thêm memory cho pointers | Chỉ dùng array |\n| **Load factor** | Có thể > 1 | Phải < 1 |\n| **Cache** | Kém (pointers) | Tốt (locality) |\n| **Delete** | Dễ | Phức tạp (cần marker) |\n| **Resize** | Ít cần | Cần thường xuyên |\n| **Performance** | Ổn định | Giảm khi đầy |\n\n**Khi nào dùng:**\n- **Chaining:** Không biết trước số phần tử, collision rate cao\n- **Open Addressing:** Biết trước size, cần tối ưu cache\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Two Sum Problem\n\n```python\ndef two_sum(nums, target):\n    \"\"\"\n    Tìm 2 số có tổng = target\n    Time: O(n), Space: O(n)\n    \"\"\"\n    hash_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in hash_map:\n            return [hash_map[complement], i]\n        \n        hash_map[num] = i\n    \n    return []\n\n# Test\nprint(two_sum([2, 7, 11, 15], 9))  # [0, 1]\n```\n\n#### 5.2. Group Anagrams\n\n```python\ndef group_anagrams(words):\n    \"\"\"\n    Nhóm các từ là anagram của nhau\n    Time: O(n * k log k) với k là độ dài từ\n    \"\"\"\n    from collections import defaultdict\n    \n    anagram_map = defaultdict(list)\n    \n    for word in words:\n        # Sort chữ cái làm key\n        key = ''.join(sorted(word))\n        anagram_map[key].append(word)\n    \n    return list(anagram_map.values())\n\n# Test\nwords = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(group_anagrams(words))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n```\n\n\n**Các khái niệm quan trọng:**\n- Collision (va chạm/xung đột) là một tính chất hoặc tình huống xảy ra trong Hash Table khi hai hoặc nhiều khóa khác nhau được hàm băm ánh xạ tới cùng một chỉ mục (bucket/vị trí/slot) trong bảng băm. Đây là một vấn đề quan trọng cần được xử lý để đảm bảo tính đúng đắn và hiệu quả của Hash Table. Các phương pháp phổ biến để giải quyết va chạm bao gồm chaining (sử dụng danh sách liên kết tại mỗi chỉ mục) và open addressing (tìm kiếm một vị trí khác trong bảng).\n\n**Mối quan hệ:**\n- Chaining giải quyết vấn đề Collision bằng cách sử dụng linked list tại mỗi vị trí trong bảng băm để lưu trữ các phần tử có cùng giá trị băm.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n    def __init__(self, size=10):\n        self.size = size\n        self.table = [[] for _ in range(size)]\n        self.count = 0\n    \n    def hash_function(self, key):\n        \"\"\"Hash function đơn giản\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def insert(self, key, value):\n        \"\"\"\n        Thêm hoặc cập nhật key-value\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        # Kiểm tra key đã tồn tại chưa\n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                # Update giá trị\n                self.table[index][i] = (key, value)\n                return\n        \n        # Thêm mới\n        self.table[index].append((key, value))\n        self.count += 1\n        \n        # Resize nếu load factor quá cao\n        if self.load_factor() > 0.7:\n            self._resize()\n    \n    def search(self, key):\n        \"\"\"\n        Tìm giá trị theo key\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        for k, v in self.table[index]:\n            if k == key:\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def delete(self, key):\n        \"\"\"\n        Xóa key-value\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                self.table[index].pop(i)\n                self.count -= 1\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def contains(self, key):\n        \"\"\"Kiểm tra key có tồn tại không\"\"\"\n        try:\n            self.search(key)\n            return True\n        except KeyError:\n            return False\n    \n    def load_factor(self):\n        \"\"\"Tính load factor = n / m\"\"\"\n        return self.count / self.size\n    \n    def _resize(self):\n        \"\"\"Tăng kích thước bảng khi load factor cao\"\"\"\n        old_table = self.table\n        self.size *= 2\n        self.table = [[] for _ in range(self.size)]\n        self.count = 0\n        \n        # Rehash tất cả phần tử\n        for bucket in old_table:\n            for key, value in bucket:\n                self.insert(key, value)\n    \n    def __str__(self):\n        result = []\n        for i, bucket in enumerate(self.table):\n            if bucket:\n                result.append(f\"Index {i}: {bucket}\")\n        return \"\n\".join(result) if result else \"Empty hash table\"\n```\n\n#### 2.3. Test Chaining\n\n```python\n# Test\nht = HashTableChaining(size=5)\n\n# Insert\nht.insert(\"apple\", 5)\nht.insert(\"banana\", 3)\nht.insert(\"cherry\", 2)\nht.insert(\"date\", 8)\nht.insert(\"elderberry\", 7)\n\nprint(\"Hash Table:\")\nprint(ht)\nprint(f\"\nLoad factor: {ht.load_factor():.2f}\")\n\n# Search\nprint(f\"\nSearch 'apple': {ht.search('apple')}\")\nprint(f\"Contains 'grape': {ht.contains('grape')}\")\n\n# Update\nht.insert(\"apple\", 10)\nprint(f\"Updated 'apple': {ht.search('apple')}\")\n\n# Delete\nht.delete(\"banana\")\nprint(f\"\nAfter deleting 'banana':\")\nprint(ht)\n```\n\n---\n\n### 3. Open Addressing\n\n#### 3.1. Ý tưởng\n\nKhi collision xảy ra, tìm slot trống khác trong cùng bảng băm bằng **probing**.\n\n**Các phương pháp probing:**\n1. **Linear Probing:** h(k, i) = (h(k) + i) mod m\n2. **Quadratic Probing:** h(k, i) = (h(k) + c₁·i + c₂·i²) mod m\n3. **Double Hashing:** h(k, i) = (h₁(k) + i·h₂(k)) mod m\n\n\n**Các khái niệm quan trọng:**\n- Chaining (còn gọi là Open Hashing hoặc Separate Chaining) là một kỹ thuật xử lý va chạm (xung đột) trong Hash Table. Trong kỹ thuật này, mỗi vị trí (slot/bucket) trong bảng băm là một cấu trúc dữ liệu (thường là danh sách liên kết hoặc mảng động) chứa tất cả các cặp khóa-giá trị hoặc phần tử băm vào cùng một chỉ mục (hash value). Khi va chạm xảy ra, cặp khóa-giá trị mới chỉ đơn giản được thêm vào danh sách tại vị trí đó, cho phép lưu trữ nhiều phần tử tại cùng một chỉ mục.\n\n**Mối quan hệ:**\n- Chaining giải quyết vấn đề Collision bằng cách sử dụng linked list tại mỗi vị trí trong bảng băm để lưu trữ các phần tử có cùng giá trị băm.\n- Chaining giải quyết vấn đề Collision bằng cách lưu trữ các phần tử có cùng hash value vào một linked list tại mỗi slot.\n- HashTableChaining cài đặt phương pháp Chaining để xử lý xung đột."
        },
        "output_without_context": {
            "question": "Trong bảng băm chuỗi riêng biệt, khi xảy ra xung đột, phương pháp nào được sử dụng để xử lý các phần tử có cùng chỉ số băm?",
            "answer": "Sử dụng danh sách liên kết để lưu trữ các phần tử xung đột."
        }
    },
    {
        "topic_description": "Chủ đề này củng cố việc thu thập dữ liệu về phân tích chuỗi riêng biệt của bảng băm. Học sinh sẽ phân tích cách N và M trong bảng băm ảnh hưởng đến hiệu suất. Các câu hỏi sẽ yêu cầu phân tích dữ liệu khi có nhiều biến.",
        "output_with_context": {
            "question": "Trong phân tích xếp chồng riêng biệt, công thức nào được sử dụng để tính khoảng cách Euclidean giữa một điểm dữ liệu và centroid trong thuật toán K-Means?",
            "answer": "d(x, \\, \\mu_k) = ||x - \\mu_k|| = \\sqrt{\\sum_{j=1}^{n}(x_j - \\mu_{kj})^2}",
            "rag_context": "**Nội dung từ tài liệu:**\n# Học Máy (Machine Learning)\n## Lựa Chọn Đặc Trưng & Tối Ưu Hóa Mô Hình\n- Precision, Recall, F1, AUC\n- Business metrics\n\n**6. Avoid Data Leakage:**\n- **Proper CV:** Fit preprocessors trên train folds only\n- **Time-based splits:** cho time series\n- **No target leakage:** Features không chứa info về target\n- **Test set untouched:** Cho đến cuối\n\n**7. Document Everything:**\n- Experiments log\n- Model versions\n- Hyperparameters\n- Results và insights\n\n**8. Reproducibility:**\n- Set random seeds\n- Version control code\n- Save data versions\n- Document environment\n- Use containers (Docker)\n\n**9. Model Versioning:**\n- MLflow, DVC\n- Track models\n- Compare versions\n- Rollback nếu cần\n\n**10. Validation Strategy:**\n- Robust CV\n- Hold-out test set\n- Temporal validation cho time series\n\n**11. Feature Engineering First:**\n- \"Data > Algorithms\"\n- Good features > Complex models\n- Domain knowledge valuable\n\n**12. Monitor Training:**\n- Training vs validation\n- Learning curves\n- Early signs of overfitting\n\n**13. Consider Production:**\n- Inference time\n- Model size\n- Dependencies\n- Maintenance\n- Explainability\n\n**14. Test on Real Data:**\n- Not just metrics\n- Qualitative analysis\n- Edge cases\n- Failure modes\n\n---\n\n---\n\n## Học Không Giám Sát (Unsupervised Learning)\n\n### Giới Thiệu Về Học Không Giám Sát\n\nHọc không giám sát khám phá các mẫu ẩn trong dữ liệu không có nhãn mà không cần biến mục tiêu tường minh. Nó được sử dụng cho phân tích dữ liệu khám phá, nhận dạng mẫu và nén dữ liệu.\n\n**Đặc điểm chính:**\n- Không có labels (y)\n- Chỉ có features (X)\n- Tìm structure trong data\n- Exploratory analysis\n\n**So với Supervised Learning:**\n| Tiêu chí | Supervised | Unsupervised |\n|----------|-----------|--------------|\n| Labels | Có | Không |\n| Mục tiêu | Dự đoán | Khám phá |\n| Feedback | Có (accuracy) | Không rõ ràng |\n| Ứng dụng | Classification, Regression | Clustering, Dimensionality Reduction |\n\n**Các tác vụ chính:**\n1. **Clustering:** Nhóm dữ liệu tương tự\n2. **Dimensionality Reduction:** Giảm số chiều\n3. **Anomaly Detection:** Phát hiện bất thường\n4. **Association Rule Learning:** Tìm mối quan hệ\n\n**Thách thức:**\n- Không có ground truth để đánh giá\n- Khó xác định số clusters/components\n- Kết quả có thể subjective\n- Cần domain knowledge để interpret\n\n### Clustering (Phân Cụm)\n\nNhóm các điểm dữ liệu tương tự lại với nhau.\n\n**Mục tiêu:**\n- High intra-cluster similarity (trong cùng cluster)\n- Low inter-cluster similarity (giữa các clusters)\n\n**Ứng dụng:**\n- Customer segmentation\n- Document clustering\n- Image segmentation\n- Anomaly detection\n- Data compression\n\n### K-Means Clustering\n\nThuật toán phân cụm phổ biến nhất, chia dữ liệu thành K clusters.\n\n**Thuật toán:**\n\n**Bước 1: Initialization**\n- Chọn K centroids ngẫu nhiên\n- Có thể từ data points hoặc random positions\n\n**Bước 2: Assignment**\n- Gán mỗi điểm đến centroid gần nhất\n- Sử dụng Euclidean distance:\n$$d(x, \\mu_k) = ||x - \\mu_k|| = \\sqrt{\\sum_{j=1}^{n}(x_j - \\mu_{kj})^2}$$\n\n**Bước 3: Update**\n- Cập nhật centroids = mean của các điểm assigned\n$$\\mu_k = \frac{1}{|C_k|}\\sum_{x \\in C_k}x$$\n\n\n**Các khái niệm quan trọng:**\n- Exploratory analysis (Phân tích khám phá) là quá trình phân tích dữ liệu để khám phá các mẫu, phát hiện các điểm bất thường, kiểm tra các giả định và hình thành các giả thuyết. Trong học không giám sát, nó giúp hiểu cấu trúc ẩn của dữ liệu.\n\n**Nội dung từ tài liệu:**\n# Học Máy (Machine Learning)\n## Học Không Giám Sát (Unsupervised Learning)\n- Matrix factorization (NMF, SVD)\n\n**5. Topic Modeling:**\n- Document clustering\n- Automatic tagging\n- Content organization\n- Trend detection\n\n**6. Gene Expression Analysis:**\n- Group similar genes\n- Identify cancer subtypes\n- Drug discovery\n- Understanding diseases\n\n**7. Social Network Analysis:**\n- Community detection\n- Influencer identification\n- Link prediction\n- Recommendation\n\n**8. Data Preprocessing:**\n- Feature extraction (PCA, ICA)\n- Noise reduction (autoencoders)\n- Data compression\n- Dimensionality reduction\n\n**9. Market Basket Analysis:**\n- Product recommendations\n- Store layout\n- Promotions\n- Cross-selling\n\n**10. Image Segmentation:**\n- Medical imaging\n- Object detection preparation\n- Video processing\n- Computer vision preprocessing\n\n---\n\n## Học Sâu (Deep Learning)\n\n### Giới Thiệu về Học Sâu\n\nHọc sâu (Deep Learning) là một nhánh con của học máy sử dụng mạng nơ-ron nhân tạo với nhiều lớp ẩn để học các biểu diễn phân cấp của dữ liệu. Khác với các phương pháp học máy truyền thống, học sâu có khả năng tự động trích xuất đặc trưng từ dữ liệu thô mà không cần kỹ thuật đặc trưng thủ công.\n\n**Đặc điểm chính:**\n- **Học biểu diễn phân cấp:** Các lớp đầu học các đặc trưng cấp thấp (cạnh, góc), các lớp sau học đặc trưng cấp cao hơn (hình dạng, đối tượng)\n- **Khả năng xử lý dữ liệu lớn:** Hiệu suất tăng theo lượng dữ liệu\n- **End-to-end learning:** Học trực tiếp từ đầu vào thô đến đầu ra mong muốn\n- **Tự động trích xuất đặc trưng:** Không cần thiết kế đặc trưng thủ công\n\n**Ứng dụng đã cách mạng hóa:**\n- Thị giác máy tính (nhận dạng ảnh, phát hiện đối tượng)\n- Xử lý ngôn ngữ tự nhiên (dịch máy, chatbot, sinh văn bản)\n- Nhận dạng giọng nói (trợ lý ảo, chuyển đổi giọng nói thành văn bản)\n- Y tế (chẩn đoán hình ảnh, phát triển thuốc)\n- Tự động hóa (xe tự lái, robot)\n\n### Mạng Nơ-ron Nhân Tạo (Artificial Neural Networks - ANN)\n\nMạng nơ-ron nhân tạo được lấy cảm hứng từ cách thức hoạt động của não người, trong đó các nơ-ron sinh học truyền tín hiệu cho nhau thông qua các synapse.\n\n### Perceptron - Đơn Vị Cơ Bản\n\nPerceptron là đơn vị mạng nơ-ron đơn giản nhất, được phát minh bởi Frank Rosenblatt năm 1958.\n\n**Công thức:**\n$$y = \\sigma(w^Tx + b)$$\n\nTrong đó:\n- $x = [x_1, x_2, ..., x_n]^T$: Vector đầu vào (các đặc trưng)\n- $w = [w_1, w_2, ..., w_n]^T$: Vector trọng số (weights)\n- $b$: Hệ số điều chỉnh (bias) - cho phép dịch chuyển hàm quyết định\n- $\\sigma$: Hàm kích hoạt (activation function)\n- $y$: Đầu ra dự đoán\n\n\n**Các khái niệm quan trọng:**\n- Market Basket Analysis là một kỹ thuật học không giám sát và là một ứng dụng của Association Rule Learning, được sử dụng để khám phá các mối quan hệ giữa các mặt hàng thường được mua cùng nhau trong các giao dịch của khách hàng. Kỹ thuật này giúp các nhà bán lẻ hiểu hành vi mua sắm, hữu ích cho việc đề xuất sản phẩm, tối ưu hóa bố trí cửa hàng và chiến lược khuyến mãi.\n- Non-negative Matrix Factorization (NMF) là một thuật toán học không giám sát để phân tích dữ liệu, phân tách một ma trận dữ liệu X thành hai ma trận con W và H (X ≈ WH). Điều kiện ràng buộc quan trọng là tất cả các phần tử của X, W và H phải không âm (≥ 0). NMF tạo ra một biểu diễn dựa trên các \"phần\" (parts-based representation), trong đó W đại diện cho các vector cơ sở (đặc trưng, chủ đề) và H đại diện cho các hệ số (trọng số, thành viên). Thuật toán này thường được sử dụng trong các ứng dụng như topic modeling và phân tích hình ảnh.\n\n**Mối quan hệ:**\n- Market Basket Analysis áp dụng Promotions để thiết kế khuyến mãi.\n- Market Basket Analysis áp dụng Product recommendations để gợi ý sản phẩm.\n- Matrix factorization chứa NMF như một thuật toán cụ thể để phân tách ma trận.\n- Market Basket Analysis áp dụng Store layout để tối ưu bố trí cửa hàng.\n- Association Rule Learning được áp dụng trong Market Basket Analysis để tìm các mối quan hệ giữa các sản phẩm được mua cùng nhau.\n\n**Nội dung từ tài liệu:**\n# Học Máy (Machine Learning)\n## Học Không Giám Sát (Unsupervised Learning)\n**Nguyên lý:**\n- Anomalies are few và different\n- Easier to isolate than normal points\n- Random partitioning\n\n**Path length:**\n- Normal points: Longer paths\n- Anomalies: Shorter paths\n\n**Thuật toán:**\n1. Build ensemble of isolation trees\n2. Each tree: Random splits\n3. Compute average path length\n4. Shorter paths → Higher anomaly score\n\n**Ưu điểm:**\n- Fast, scalable\n- High-dimensional data\n- Không cần distribution assumption\n\n**Nhược điểm:**\n- Không giải thích tại sao anomaly\n- Random (need multiple trees)\n\n**3. One-Class SVM:**\n\n**Nguyên lý:**\n- Learn boundary around normal data\n- Separate normal from origin\n- Points outside boundary = anomalies\n\n**Objective:**\nMaximize margin from origin to hyperplane\n\n**Ưu điểm:**\n- Kernel trick for non-linear\n- Theoretical foundation\n- Good cho high-dim\n\n**Nhược điểm:**\n- Expensive với large data\n- Sensitive to ν parameter\n- Cần feature scaling\n\n**4. Local Outlier Factor (LOF):**\n\n**Nguyên lý:**\n- Compare local density với neighbors\n- Anomaly có density thấp hơn neighbors\n\n**LOF Score:**\n- ~1: Normal\n- <<1: Denser than neighbors (inlier)\n- >>1: Less dense (outlier)\n\n**Ưu điểm:**\n- Local anomalies\n- Varying densities\n\n**Nhược điểm:**\n- Expensive (O(N²))\n- Sensitive to k\n\n**5. Autoencoders:**\n\n**Nguyên lý:**\n- Neural network học reconstruct normal data\n- Anomalies have high reconstruction error\n\n**Reconstruction error:**\n$$Error = ||x - \\hat{x}||^2$$\n\n- Threshold: Mean + k × std\n- Points above threshold = anomalies\n\n**Ưu điểm:**\n- Non-linear patterns\n- High-dimensional\n- Deep representations\n\n**Nhược điểm:**\n- Need training data (mostly normal)\n- Computationally expensive\n- Hyperparameter tuning\n\n**Ứng dụng:**\n- Fraud detection\n- Network intrusion\n- Manufacturing defects\n- Medical diagnosis\n- System monitoring\n\n### Association Rule Learning\n\nKhám phá mối quan hệ giữa các biến.\n\n**Market Basket Analysis:**\nTìm sản phẩm thường được mua cùng nhau.\n\n**Terminology:**\n- **Itemset:** Tập hợp items {Milk, Bread}\n- **Transaction:** Một lần mua hàng\n- **Rule:** A → B (If buy A, then buy B)\n\n**Metrics:**\n\n**1. Support:**\n$$Support(A) = \frac{\text{Transactions containing A}}{\text{Total transactions}}$$\n\n- Tỷ lệ transactions có itemset\n- Popular items có support cao\n\n**2. Confidence:**\n$$Confidence(A \rightarrow B) = \frac{Support(A \\cup B)}{Support(A)} = P(B|A)$$\n\n- Tỷ lệ transactions có B trong số có A\n- Strength của rule\n\n**3. Lift:**\n$$Lift(A \rightarrow B) = \frac{Confidence(A \rightarrow B)}{Support(B)} = \frac{P(A \\cap B)}{P(A)P(B)}$$\n\n- Measure of association\n- Lift = 1: Independent\n- Lift > 1: Positive correlation\n- Lift < 1: Negative correlation\n\n**Ví dụ:**\n- Rule: {Milk} → {Bread}\n- Support({Milk, Bread}) = 0.3 (30% transactions)\n- Confidence = 0.6 (60% người mua Milk cũng mua Bread)\n- Lift = 1.2 (Buying Milk tăng 20% khả năng mua Bread)\n\n**Algorithms:**\n\n**1. Apriori Algorithm:**\n\n**Nguyên lý:**\n- If itemset frequent → all subsets frequent\n- If itemset infrequent → all supersets infrequent\n\n**Steps:**\n1. Find frequent 1-itemsets (support ≥ min_support)\n2. Generate candidate k-itemsets from frequent (k-1)-itemsets\n3. Prune candidates using apriori property\n4. Count support và find frequent k-itemsets\n\n**Các khái niệm quan trọng:**\n- Market Basket Analysis là một kỹ thuật học không giám sát và là một ứng dụng của Association Rule Learning, được sử dụng để khám phá các mối quan hệ giữa các mặt hàng thường được mua cùng nhau trong các giao dịch của khách hàng. Kỹ thuật này giúp các nhà bán lẻ hiểu hành vi mua sắm, hữu ích cho việc đề xuất sản phẩm, tối ưu hóa bố trí cửa hàng và chiến lược khuyến mãi.\n\n**Mối quan hệ:**\n- Market Basket Analysis áp dụng Product recommendations để gợi ý sản phẩm.\n- Market Basket Analysis áp dụng Store layout để tối ưu bố trí cửa hàng.\n- Market Basket Analysis áp dụng Promotions để thiết kế khuyến mãi.\n- Association Rule Learning được áp dụng trong Market Basket Analysis để tìm các mối quan hệ giữa các sản phẩm được mua cùng nhau."
        },
        "output_without_context": {
            "question": "Trong phân tích xếp chồng riêng biệt của bảng băm, N và M ảnh hưởng đến hiệu suất như thế nào khi số lượng biến tăng lên?",
            "answer": "Khi số lượng biến tăng, hiệu suất của bảng băm thường giảm do tăng độ phức tạp trong việc quản lý và truy xuất dữ liệu."
        }
    },
    {
        "topic_description": "Chủ đề này nhằm giúp học sinh hiểu rõ về cách thiết kế mã băm cho các kiểu người dùng định nghĩa. Họ sẽ học cách biến đổi mã băm cho các trường khác nhau và lý do cho sự lựa chọn đó. Kiến thức này kết nối với phần trước có liên quan đến mã băm trong Java.",
        "output_with_context": {
            "question": "Trong phương pháp Double Hashing, công thức nào được sử dụng để tính toán vị trí của một khóa khi xảy ra va chạm?",
            "answer": "h(k, i) = (h1(k) + i*h2(k)) mod m",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (original_index + i * i) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n#### 3.4. Double Hashing\n\n```python\nclass HashTableDoubleHashing:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [None] * size\n        self.count = 0\n    \n    def hash1(self, key):\n        \"\"\"Primary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def hash2(self, key):\n        \"\"\"Secondary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 37 + ord(char))\n            return 1 + (hash_value % (self.size - 1))\n        return 1 + (key % (self.size - 1))\n    \n    def insert(self, key, value):\n        \"\"\"\n        Double hashing: h(k, i) = (h1(k) + i*h2(k)) mod m\n        \"\"\"\n        index = self.hash1(key)\n        step = self.hash2(key)\n        i = 0\n        \n        while self.table[index] is not None:\n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (self.hash1(key) + i * step) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n---\n\n### 4. So sánh Chaining vs Open Addressing\n\n| Đặc điểm | Chaining | Open Addressing |\n|----------|----------|-----------------|\n| **Collision** | Dùng linked list | Tìm slot khác |\n| **Memory** | Thêm memory cho pointers | Chỉ dùng array |\n| **Load factor** | Có thể > 1 | Phải < 1 |\n| **Cache** | Kém (pointers) | Tốt (locality) |\n| **Delete** | Dễ | Phức tạp (cần marker) |\n| **Resize** | Ít cần | Cần thường xuyên |\n| **Performance** | Ổn định | Giảm khi đầy |\n\n**Khi nào dùng:**\n- **Chaining:** Không biết trước số phần tử, collision rate cao\n- **Open Addressing:** Biết trước size, cần tối ưu cache\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Two Sum Problem\n\n```python\ndef two_sum(nums, target):\n    \"\"\"\n    Tìm 2 số có tổng = target\n    Time: O(n), Space: O(n)\n    \"\"\"\n    hash_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in hash_map:\n            return [hash_map[complement], i]\n        \n        hash_map[num] = i\n    \n    return []\n\n# Test\nprint(two_sum([2, 7, 11, 15], 9))  # [0, 1]\n```\n\n#### 5.2. Group Anagrams\n\n```python\ndef group_anagrams(words):\n    \"\"\"\n    Nhóm các từ là anagram của nhau\n    Time: O(n * k log k) với k là độ dài từ\n    \"\"\"\n    from collections import defaultdict\n    \n    anagram_map = defaultdict(list)\n    \n    for word in words:\n        # Sort chữ cái làm key\n        key = ''.join(sorted(word))\n        anagram_map[key].append(word)\n    \n    return list(anagram_map.values())\n\n# Test\nwords = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(group_anagrams(words))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n```\n\n\n**Các khái niệm quan trọng:**\n- hash1 là hàm băm chính được sử dụng trong Double Hashing để tính toán vị trí ban đầu của một khóa trong bảng băm. Đối với khóa là chuỗi, nó tính tổng trọng số của các ký tự; đối với khóa là số nguyên, nó sử dụng phép toán modulo. Độ phức tạp thời gian của hash1 phụ thuộc vào độ dài của khóa, ví dụ O(k) cho chuỗi có độ dài k.\n- hash2 là hàm băm phụ được sử dụng trong Double Hashing để tính toán bước nhảy (step size) khi xảy ra va chạm. Hàm này phải đảm bảo trả về một giá trị khác 0 và tương đối nguyên tố với kích thước bảng băm để đảm bảo tất cả các vị trí trong bảng có thể được duyệt qua. Đối với khóa là chuỗi, nó tính tổng trọng số của các ký tự; đối với khóa là số nguyên, nó sử dụng phép toán modulo. Độ phức tạp thời gian của hash2 phụ thuộc vào độ dài của khóa, ví dụ O(k) cho chuỗi có độ dài k.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Hash Table (Bảng băm)** là một cấu trúc dữ liệu cho phép lưu trữ và truy xuất dữ liệu với độ phức tạp trung bình **O(1)**. Hash Table sử dụng **hash function** để chuyển đổi key thành index trong mảng.\n\n**Thành phần chính:**\n- **Key:** Khóa duy nhất để truy cập giá trị\n- **Value:** Giá trị được lưu trữ\n- **Hash Function:** Hàm chuyển key thành index\n- **Bucket/Slot:** Vị trí trong mảng để lưu cặp key-value\n\n**Ví dụ:**\n```\nKey: \"apple\"  → Hash(\"apple\") → Index: 5\nKey: \"banana\" → Hash(\"banana\") → Index: 2\nKey: \"cherry\" → Hash(\"cherry\") → Index: 8\n\nArray: [_, _, \"banana\", _, _, \"apple\", _, _, \"cherry\", _]\nIndex:  0  1     2      3  4     5     6  7     8      9\n```\n\n#### 1.2. Hash Function\n\n**Yêu cầu của hash function tốt:**\n1. **Deterministic:** Cùng input luôn cho cùng output\n2. **Uniform distribution:** Phân bố đều các key\n3. **Fast to compute:** Tính toán nhanh O(1)\n4. **Minimize collisions:** Giảm xung đột\n\n**Các phương pháp hash phổ biến:**\n\n**a) Division Method:**\n```python\ndef hash_division(key, table_size):\n    \"\"\"h(k) = k mod m\"\"\"\n    return key % table_size\n```\n\n**b) Multiplication Method:**\n```python\ndef hash_multiplication(key, table_size):\n    \"\"\"h(k) = floor(m * (k*A mod 1))\"\"\"\n    A = 0.6180339887  # (√5 - 1) / 2\n    return int(table_size * ((key * A) % 1))\n```\n\n**c) String Hash (Polynomial Rolling Hash):**\n```python\ndef hash_string(key, table_size):\n    \"\"\"Hash cho string\"\"\"\n    hash_value = 0\n    prime = 31\n    \n    for char in key:\n        hash_value = (hash_value * prime + ord(char)) % table_size\n    \n    return hash_value\n```\n\n**d) Universal Hashing:**\n```python\nimport random\n\ndef universal_hash(key, table_size):\n    \"\"\"Chọn ngẫu nhiên từ họ hash functions\"\"\"\n    p = 1000000007  # Số nguyên tố lớn\n    a = random.randint(1, p - 1)\n    b = random.randint(0, p - 1)\n    \n    return ((a * key + b) % p) % table_size\n```\n\n#### 1.3. Collision (Xung đột)\n\n**Collision xảy ra khi:** 2 key khác nhau có cùng hash value.\n\n```\nhash(\"apple\") = 5\nhash(\"avocado\") = 5  ← Collision!\n```\n\n**Hai phương pháp xử lý collision chính:**\n1. **Chaining (Open Hashing)**\n2. **Open Addressing (Closed Hashing)**\n\n---\n\n### 2. Chaining (Separate Chaining)\n\n#### 2.1. Ý tưởng\n\nMỗi slot trong bảng băm chứa một **linked list** (hoặc dynamic array) các phần tử có cùng hash value.\n\n**Minh họa:**\n```\nHash Table với Chaining:\n\nIndex 0: → [(\"apple\", 5)]\nIndex 1: → []\nIndex 2: → [(\"banana\", 3)] → [(\"blueberry\", 7)]\nIndex 3: → [(\"cherry\", 2)]\nIndex 4: → []\nIndex 5: → [(\"date\", 8)] → [(\"durian\", 9)]\n```\n\n#### 2.2. Cài đặt\n\n```python\nclass HashTableChaining:\n\n**Các khái niệm quan trọng:**\n- String Hash (Polynomial Rolling Hash) là một phương pháp hash được sử dụng cho các key là chuỗi ký tự. Nó tính toán hash value bằng cách kết hợp giá trị ASCII của từng ký tự với một số nguyên tố (prime) và phép modulo để giữ giá trị trong phạm vi table_size.\n- h(k) = k mod m là công thức toán học cho phương pháp Division Method trong Hash Function, trong đó h(k) là hash value, k là key, và m là kích thước của bảng băm (table_size). h(k) = floor(m * (k*A mod 1)) là công thức toán học cho phương pháp Multiplication Method trong Hash Function, trong đó h(k) là hash value, k là key, m là kích thước bảng băm, và A là một hằng số (thường là (√5 - 1) / 2).\n- ((a * key + b) % p) % table_size là công thức toán học cho Universal Hashing, trong đó a và b là các hệ số ngẫu nhiên, p là số nguyên tố lớn, key là khóa, và table_size là kích thước bảng băm. Công thức này tạo ra một hash value từ một họ các hàm băm.\n\n**Mối quan hệ:**\n- String Hash sử dụng hằng số prime = 31 trong công thức tính toán hash value.\n- Hash Function áp dụng String Hash như một phương pháp để tính toán hash value cho các chuỗi.\n- Universal Hashing dẫn xuất từ công thức ((a * key + b) % p) % table_size để tính toán hash value.\n- Division Method dẫn xuất từ công thức h(k) = k mod m để tính toán hash value."
        },
        "output_without_context": {
            "question": "Khi thiết kế mã băm cho một kiểu người dùng định nghĩa trong Java, yếu tố nào quan trọng nhất để đảm bảo phân phối đồng đều các giá trị băm?",
            "answer": "Sử dụng một hàm băm tốt để giảm thiểu xung đột."
        }
    },
    {
        "topic_description": "Chủ đề này xem xét khái niệm hàm băm một chiều, với các ứng dụng thực tiễn như lưu trữ mật khẩu. Học sinh sẽ nhận diện các hàm băm một chiều khác nhau và hiểu cách thức hoạt động của chúng trong bảo mật.",
        "output_with_context": {
            "question": "Hàm băm một chiều được sử dụng để chuyển đổi một khóa thành một chỉ mục trong bảng băm. Yêu cầu nào sau đây là đặc điểm của một hàm băm tốt?",
            "answer": "Phân bố đều các key.",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n        return -1\n    \n    def remove(self, key):\n        \"\"\"Time: O(n/k)\"\"\"\n        index = self._hash(key)\n        \n        for i, (k, v) in enumerate(self.buckets[index]):\n            if k == key:\n                self.buckets[index].pop(i)\n                return\n\n# Test\nhashmap = MyHashMap()\nhashmap.put(1, 1)\nhashmap.put(2, 2)\nprint(hashmap.get(1))    # 1\nhashmap.put(2, 1)\nprint(hashmap.get(2))    # 1\nhashmap.remove(2)\nprint(hashmap.get(2))    # -1\n```\n\n---\n\n### 6. Python Dictionary\n\nPython's `dict` là hash table được tối ưu cao:\n\n```python\n# Tạo dictionary\nd = {}\nd = dict()\nd = {'apple': 5, 'banana': 3}\n\n# Thao tác cơ bản\nd['cherry'] = 2        # Insert/Update - O(1)\nvalue = d['apple']     # Get - O(1)\ndel d['banana']        # Delete - O(1)\nexists = 'apple' in d  # Contains - O(1)\n\n# Methods\nkeys = d.keys()        # Tất cả keys\nvalues = d.values()    # Tất cả values\nitems = d.items()      # Tất cả (key, value) pairs\n\n# Get với default\nvalue = d.get('grape', 0)  # Trả về 0 nếu không tìm thấy\n\n# Duyệt\nfor key in d:\n    print(key, d[key])\n\nfor key, value in d.items():\n    print(key, value)\n\n# Counter\nfrom collections import Counter\nwords = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']\ncount = Counter(words)\nprint(count)  # Counter({'apple': 3, 'banana': 2, 'cherry': 1})\n\n# DefaultDict\nfrom collections import defaultdict\ndd = defaultdict(int)  # Default value = 0\ndd['apple'] += 1\n\ndd_list = defaultdict(list)  # Default value = []\ndd_list['fruits'].append('apple')\n```\n\n---\n\n### 7. Phân tích độ phức tạp\n\n| Thao tác | Average | Worst | Space |\n|----------|---------|-------|-------|\n| Insert | O(1) | O(n) | O(n) |\n| Search | O(1) | O(n) | O(n) |\n| Delete | O(1) | O(n) | O(n) |\n\n**Worst case:** Khi tất cả keys hash về cùng index (collision)\n\n**Load factor ảnh hưởng:**\n- α < 0.7: Performance tốt\n- α > 0.7: Nên resize\n\n---\n\n### 8. Khi nào dùng Hash Table?\n\n**Nên dùng:**\n- ✅ Cần lookup/insert/delete nhanh O(1)\n- ✅ Không cần thứ tự\n- ✅ Unique keys\n- ✅ Counting, frequency\n- ✅ Caching\n\n**Không nên dùng:**\n- ❌ Cần duy trì thứ tự → BST, Sorted Array\n- ❌ Cần range query → BST\n- ❌ Cần min/max → Heap\n- ❌ Memory bị hạn chế → Array\n\n---\n\n\n**Các khái niệm quan trọng:**\n- hash_function (hoặc _hash) là một phép toán cơ bản trong Hash Table, có nhiệm vụ chuyển đổi một khóa (key) thành một chỉ mục số nguyên (index) trong phạm vi kích thước của mảng lưu trữ của bảng băm. Hàm băm này được thiết kế để xử lý cả khóa số nguyên (thường bằng phép chia lấy dư) và khóa chuỗi (bằng cách tính tổng trọng số của các ký tự), sử dụng phép toán modulo để đảm bảo chỉ mục nằm trong giới hạn của bảng. Mục tiêu chính của một hàm băm tốt là phân phối các khóa một cách đồng đều khắp bảng để giảm thiểu va chạm, với độ phức tạp lý tưởng là O(1).\n- _hash là phép toán hàm băm nội bộ của MyHashMap, dùng để tính toán chỉ số (index) của bucket cho một key cụ thể. Công thức băm được sử dụng là `key % self.size`.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Hash Table (Bảng băm)** là một cấu trúc dữ liệu cho phép lưu trữ và truy xuất dữ liệu với độ phức tạp trung bình **O(1)**. Hash Table sử dụng **hash function** để chuyển đổi key thành index trong mảng.\n\n**Thành phần chính:**\n- **Key:** Khóa duy nhất để truy cập giá trị\n- **Value:** Giá trị được lưu trữ\n- **Hash Function:** Hàm chuyển key thành index\n- **Bucket/Slot:** Vị trí trong mảng để lưu cặp key-value\n\n**Ví dụ:**\n```\nKey: \"apple\"  → Hash(\"apple\") → Index: 5\nKey: \"banana\" → Hash(\"banana\") → Index: 2\nKey: \"cherry\" → Hash(\"cherry\") → Index: 8\n\nArray: [_, _, \"banana\", _, _, \"apple\", _, _, \"cherry\", _]\nIndex:  0  1     2      3  4     5     6  7     8      9\n```\n\n#### 1.2. Hash Function\n\n**Yêu cầu của hash function tốt:**\n1. **Deterministic:** Cùng input luôn cho cùng output\n2. **Uniform distribution:** Phân bố đều các key\n3. **Fast to compute:** Tính toán nhanh O(1)\n4. **Minimize collisions:** Giảm xung đột\n\n**Các phương pháp hash phổ biến:**\n\n**a) Division Method:**\n```python\ndef hash_division(key, table_size):\n    \"\"\"h(k) = k mod m\"\"\"\n    return key % table_size\n```\n\n**b) Multiplication Method:**\n```python\ndef hash_multiplication(key, table_size):\n    \"\"\"h(k) = floor(m * (k*A mod 1))\"\"\"\n    A = 0.6180339887  # (√5 - 1) / 2\n    return int(table_size * ((key * A) % 1))\n```\n\n**c) String Hash (Polynomial Rolling Hash):**\n```python\ndef hash_string(key, table_size):\n    \"\"\"Hash cho string\"\"\"\n    hash_value = 0\n    prime = 31\n    \n    for char in key:\n        hash_value = (hash_value * prime + ord(char)) % table_size\n    \n    return hash_value\n```\n\n**d) Universal Hashing:**\n```python\nimport random\n\ndef universal_hash(key, table_size):\n    \"\"\"Chọn ngẫu nhiên từ họ hash functions\"\"\"\n    p = 1000000007  # Số nguyên tố lớn\n    a = random.randint(1, p - 1)\n    b = random.randint(0, p - 1)\n    \n    return ((a * key + b) % p) % table_size\n```\n\n#### 1.3. Collision (Xung đột)\n\n**Collision xảy ra khi:** 2 key khác nhau có cùng hash value.\n\n```\nhash(\"apple\") = 5\nhash(\"avocado\") = 5  ← Collision!\n```\n\n**Hai phương pháp xử lý collision chính:**\n1. **Chaining (Open Hashing)**\n2. **Open Addressing (Closed Hashing)**\n\n---\n\n### 2. Chaining (Separate Chaining)\n\n#### 2.1. Ý tưởng\n\nMỗi slot trong bảng băm chứa một **linked list** (hoặc dynamic array) các phần tử có cùng hash value.\n\n**Minh họa:**\n```\nHash Table với Chaining:\n\nIndex 0: → [(\"apple\", 5)]\nIndex 1: → []\nIndex 2: → [(\"banana\", 3)] → [(\"blueberry\", 7)]\nIndex 3: → [(\"cherry\", 2)]\nIndex 4: → []\nIndex 5: → [(\"date\", 8)] → [(\"durian\", 9)]\n```\n\n#### 2.2. Cài đặt\n\n```python\nclass HashTableChaining:\n\n**Các khái niệm quan trọng:**\n- Hash Function là một hàm chuyển đổi Key thành một index (vị trí) trong mảng của Hash Table. Một hash function tốt cần phải deterministic, phân bố đều các key (uniform distribution), tính toán nhanh (O(1)), và giảm thiểu xung đột (minimize collisions).\n- Minimize collisions là một yêu cầu của hash function, nghĩa là hàm băm nên được thiết kế để giảm thiểu số lần hai key khác nhau tạo ra cùng một index.\n- String Hash (Polynomial Rolling Hash) là một phương pháp hash được sử dụng cho các key là chuỗi ký tự. Nó tính toán hash value bằng cách kết hợp giá trị ASCII của từng ký tự với một số nguyên tố (prime) và phép modulo để giữ giá trị trong phạm vi table_size.\n\n**Mối quan hệ:**\n- Hash Function áp dụng Multiplication Method như một phương pháp để tính toán hash value.\n- Hash Function áp dụng String Hash như một phương pháp để tính toán hash value cho các chuỗi.\n- Hash Function có tính chất Minimize collisions, nghĩa là nó nên giảm thiểu số lần hai key khác nhau tạo ra cùng một index.\n- Hash Function áp dụng Universal Hashing như một phương pháp để chọn ngẫu nhiên một hàm băm từ một họ các hàm băm.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (original_index + i * i) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n#### 3.4. Double Hashing\n\n```python\nclass HashTableDoubleHashing:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [None] * size\n        self.count = 0\n    \n    def hash1(self, key):\n        \"\"\"Primary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def hash2(self, key):\n        \"\"\"Secondary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 37 + ord(char))\n            return 1 + (hash_value % (self.size - 1))\n        return 1 + (key % (self.size - 1))\n    \n    def insert(self, key, value):\n        \"\"\"\n        Double hashing: h(k, i) = (h1(k) + i*h2(k)) mod m\n        \"\"\"\n        index = self.hash1(key)\n        step = self.hash2(key)\n        i = 0\n        \n        while self.table[index] is not None:\n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (self.hash1(key) + i * step) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n---\n\n### 4. So sánh Chaining vs Open Addressing\n\n| Đặc điểm | Chaining | Open Addressing |\n|----------|----------|-----------------|\n| **Collision** | Dùng linked list | Tìm slot khác |\n| **Memory** | Thêm memory cho pointers | Chỉ dùng array |\n| **Load factor** | Có thể > 1 | Phải < 1 |\n| **Cache** | Kém (pointers) | Tốt (locality) |\n| **Delete** | Dễ | Phức tạp (cần marker) |\n| **Resize** | Ít cần | Cần thường xuyên |\n| **Performance** | Ổn định | Giảm khi đầy |\n\n**Khi nào dùng:**\n- **Chaining:** Không biết trước số phần tử, collision rate cao\n- **Open Addressing:** Biết trước size, cần tối ưu cache\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Two Sum Problem\n\n```python\ndef two_sum(nums, target):\n    \"\"\"\n    Tìm 2 số có tổng = target\n    Time: O(n), Space: O(n)\n    \"\"\"\n    hash_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in hash_map:\n            return [hash_map[complement], i]\n        \n        hash_map[num] = i\n    \n    return []\n\n# Test\nprint(two_sum([2, 7, 11, 15], 9))  # [0, 1]\n```\n\n#### 5.2. Group Anagrams\n\n```python\ndef group_anagrams(words):\n    \"\"\"\n    Nhóm các từ là anagram của nhau\n    Time: O(n * k log k) với k là độ dài từ\n    \"\"\"\n    from collections import defaultdict\n    \n    anagram_map = defaultdict(list)\n    \n    for word in words:\n        # Sort chữ cái làm key\n        key = ''.join(sorted(word))\n        anagram_map[key].append(word)\n    \n    return list(anagram_map.values())\n\n# Test\nwords = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(group_anagrams(words))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n```\n\n\n**Các khái niệm quan trọng:**\n- hash2 là hàm băm phụ được sử dụng trong Double Hashing để tính toán bước nhảy (step size) khi xảy ra va chạm. Hàm này phải đảm bảo trả về một giá trị khác 0 và tương đối nguyên tố với kích thước bảng băm để đảm bảo tất cả các vị trí trong bảng có thể được duyệt qua. Đối với khóa là chuỗi, nó tính tổng trọng số của các ký tự; đối với khóa là số nguyên, nó sử dụng phép toán modulo. Độ phức tạp thời gian của hash2 phụ thuộc vào độ dài của khóa, ví dụ O(k) cho chuỗi có độ dài k.\n- hash1 là hàm băm chính được sử dụng trong Double Hashing để tính toán vị trí ban đầu của một khóa trong bảng băm. Đối với khóa là chuỗi, nó tính tổng trọng số của các ký tự; đối với khóa là số nguyên, nó sử dụng phép toán modulo. Độ phức tạp thời gian của hash1 phụ thuộc vào độ dài của khóa, ví dụ O(k) cho chuỗi có độ dài k."
        },
        "output_without_context": {
            "question": "Hàm băm một chiều được sử dụng chủ yếu trong ứng dụng nào dưới đây?",
            "answer": "Lưu trữ mật khẩu"
        }
    },
    {
        "topic_description": "Chủ đề này liên kết các khái niệm từ tuần 6 về cây tìm kiếm nhị phân và bảng băm, phân tích điểm mạnh và điểm yếu của mỗi phương pháp. Học sinh sẽ được kiểm tra khả năng so sánh hiệu suất giữa các cấu trúc dữ liệu và đối bức ảnh hưởng đến hiệu suất bảo mật.",
        "output_with_context": {
            "question": "So sánh hiệu suất giữa bảng băm và cây tìm kiếm cân bằng, trong trường hợp nào bảng băm có ưu thế hơn về tốc độ tìm kiếm?",
            "answer": "Bảng băm có ưu thế hơn về tốc độ tìm kiếm khi độ phức tạp trung bình của phép toán tìm kiếm là O(1), trong khi cây tìm kiếm cân bằng có độ phức tạp trung bình là O(log n).",
            "rag_context": "**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (original_index + i * i) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n#### 3.4. Double Hashing\n\n```python\nclass HashTableDoubleHashing:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [None] * size\n        self.count = 0\n    \n    def hash1(self, key):\n        \"\"\"Primary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def hash2(self, key):\n        \"\"\"Secondary hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 37 + ord(char))\n            return 1 + (hash_value % (self.size - 1))\n        return 1 + (key % (self.size - 1))\n    \n    def insert(self, key, value):\n        \"\"\"\n        Double hashing: h(k, i) = (h1(k) + i*h2(k)) mod m\n        \"\"\"\n        index = self.hash1(key)\n        step = self.hash2(key)\n        i = 0\n        \n        while self.table[index] is not None:\n            if self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            i += 1\n            index = (self.hash1(key) + i * step) % self.size\n            \n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        self.table[index] = (key, value)\n        self.count += 1\n```\n\n---\n\n### 4. So sánh Chaining vs Open Addressing\n\n| Đặc điểm | Chaining | Open Addressing |\n|----------|----------|-----------------|\n| **Collision** | Dùng linked list | Tìm slot khác |\n| **Memory** | Thêm memory cho pointers | Chỉ dùng array |\n| **Load factor** | Có thể > 1 | Phải < 1 |\n| **Cache** | Kém (pointers) | Tốt (locality) |\n| **Delete** | Dễ | Phức tạp (cần marker) |\n| **Resize** | Ít cần | Cần thường xuyên |\n| **Performance** | Ổn định | Giảm khi đầy |\n\n**Khi nào dùng:**\n- **Chaining:** Không biết trước số phần tử, collision rate cao\n- **Open Addressing:** Biết trước size, cần tối ưu cache\n\n---\n\n### 5. Ứng dụng thực tế\n\n#### 5.1. Two Sum Problem\n\n```python\ndef two_sum(nums, target):\n    \"\"\"\n    Tìm 2 số có tổng = target\n    Time: O(n), Space: O(n)\n    \"\"\"\n    hash_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in hash_map:\n            return [hash_map[complement], i]\n        \n        hash_map[num] = i\n    \n    return []\n\n# Test\nprint(two_sum([2, 7, 11, 15], 9))  # [0, 1]\n```\n\n#### 5.2. Group Anagrams\n\n```python\ndef group_anagrams(words):\n    \"\"\"\n    Nhóm các từ là anagram của nhau\n    Time: O(n * k log k) với k là độ dài từ\n    \"\"\"\n    from collections import defaultdict\n    \n    anagram_map = defaultdict(list)\n    \n    for word in words:\n        # Sort chữ cái làm key\n        key = ''.join(sorted(word))\n        anagram_map[key].append(word)\n    \n    return list(anagram_map.values())\n\n# Test\nwords = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(group_anagrams(words))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n```\n\n\n**Các khái niệm quan trọng:**\n- Performance (hiệu suất) của Hash Table đề cập đến tốc độ thực thi các phép toán. Chaining có hiệu suất ổn định hơn ngay cả khi load factor cao. Open Addressing có hiệu suất tốt khi bảng còn trống, nhưng giảm đáng kể khi bảng gần đầy do tăng số lượng va chạm và probing. Độ phức tạp trung bình O(1), worst case O(n).\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Priority Queue & Binary Heap\n| Delete | O(log n) | O(log n) avg, O(n) worst | O(n) |\n| Build | O(n) | O(n log n) | O(n log n) |\n\n**Khi nào dùng Heap?**\n- ✅ Cần extract min/max nhiều lần\n- ✅ Priority Queue\n- ✅ Tìm k largest/smallest elements\n- ✅ Median trong stream\n- ✅ Scheduling problems\n\n**Khi nào không dùng Heap?**\n- ❌ Cần search phần tử cụ thể (dùng BST)\n- ❌ Cần duyệt theo thứ tự (dùng BST)\n- ❌ Cần truy cập ngẫu nhiên (dùng array)\n\n---\n\n## Binary Search Tree \n\n### 1. Giới thiệu\n\n#### 1.1. Khái niệm\n\n**Binary Search Tree (BST)** là một cây nhị phân có tính chất đặc biệt:\n- Tất cả các node trong cây con trái có giá trị **< node gốc**\n- Tất cả các node trong cây con phải có giá trị **> node gốc**\n- Cây con trái và cây con phải cũng là BST\n\n**Ví dụ BST hợp lệ:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  7 13\n```\n\n**Không phải BST:**\n```\n        8\n       / \\\n      3   10\n     / \\    \\\n    1   6   14\n       / \\  /\n      4  9 13    <- 9 > 8, không thể ở cây con trái\n```\n\n#### 1.2. Tính chất quan trọng\n\n**a) Duyệt Inorder cho thứ tự tăng dần:**\n- Duyệt BST theo Inorder (Left-Root-Right) cho dãy số tăng dần\n- Ví dụ trên: 1, 3, 4, 6, 7, 8, 10, 13, 14\n\n**b) Tìm kiếm hiệu quả:**\n- Có thể loại bỏ 1 nửa cây ở mỗi bước\n- Average case: O(log n)\n- Worst case: O(n) - cây thoái hóa thành linked list\n\n**c) Dynamic data structure:**\n- Dễ dàng insert và delete\n- Không cần biết trước kích thước\n\n#### 1.3. Ứng dụng\n\n- **Database indexing:** B-Tree, B+ Tree (biến thể của BST)\n- **File system:** Tổ chức thư mục\n- **Expression parsing:** Cây biểu thức\n- **Priority Queue:** Có thể implement bằng BST\n- **Auto-complete:** Trie (dạng đặc biệt của cây)\n\n---\n\n### 2. Cấu trúc Node và BST\n\n#### 2.1. Định nghĩa Node\n\n```python\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n    \n    def __repr__(self):\n        return f\"Node({self.val})\"\n```\n\n#### 2.2. Lớp BST\n\n```python\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def is_empty(self):\n        return self.root is None\n    \n    def get_root(self):\n        return self.root\n```\n\n---\n\n### 3. Các thao tác cơ bản\n\n#### 3.1. Search (Tìm kiếm)\n\n```python\n    def search(self, val):\n        \"\"\"\n        Tìm node có giá trị val\n        Time: O(h) với h là chiều cao cây\n        Average: O(log n), Worst: O(n)\n        \"\"\"\n        return self._search_recursive(self.root, val)\n    \n\n**Các khái niệm quan trọng:**\n- Search là phép toán tìm kiếm một phần tử hoặc giá trị cụ thể trong cấu trúc dữ liệu. Trong Binary Search Tree (BST), phép toán này bắt đầu từ gốc, so sánh giá trị cần tìm với giá trị của node hiện tại. Nếu giá trị cần tìm nhỏ hơn, di chuyển sang cây con trái; nếu lớn hơn, di chuyển sang cây con phải. Nếu bằng, phần tử được tìm thấy. Độ phức tạp thời gian của Search trong BST là O(h), trong đó h là chiều cao của cây. Cụ thể: Best case là O(1) (tìm thấy ở gốc), Average case là O(log n) (đối với cây cân bằng), và Worst case là O(n) (đối với cây thoái hóa). Đối với Min/Max Heap, độ phức tạp của Search là O(n), khiến chúng không hiệu quả cho việc tìm kiếm phần tử cụ thể. Trong Sorted Array, Search có độ phức tạp O(log n) khi sử dụng tìm kiếm nhị phân.\n- Search là phép toán tìm kiếm giá trị liên kết với một khóa cụ thể trong Hash Table (ví dụ: Python Dictionary). Quá trình này bao gồm việc sử dụng hàm băm để tính toán chỉ mục (vị trí ban đầu) và sau đó áp dụng các kỹ thuật giải quyết va chạm (như Linear Probing hoặc Quadratic Probing) để tìm kiếm khóa nếu có va chạm. Nếu tìm thấy khóa, giá trị tương ứng sẽ được trả về; nếu không, một ngoại lệ KeyError sẽ được ném ra. Độ phức tạp thời gian trung bình của phép toán này là O(1), nhưng trong trường hợp xấu nhất, độ phức tạp có thể là O(n).\n\n**Mối quan hệ:**\n- Array (sorted) có độ phức tạp O(log n) cho phép toán Search.\n- Hash Table có độ phức tạp O(1) cho phép toán Search trong trường hợp trung bình.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Binary Search Tree \n    bst.root = build(0, len(arr) - 1)\n    return bst\n\n# Test\narr = [1, 2, 3, 4, 5, 6, 7]\nbst = sorted_array_to_bst(arr)\nprint(\"Level order:\", bst.level_order())  # [4, 2, 6, 1, 3, 5, 7]\n```\n\n#### 6.3. Serialize và Deserialize BST\n\n```python\ndef serialize(root):\n    \"\"\"Chuyển BST thành string\"\"\"\n    def preorder(node):\n        if node is None:\n            result.append('#')\n            return\n        result.append(str(node.val))\n        preorder(node.left)\n        preorder(node.right)\n    \n    result = []\n    preorder(root)\n    return ','.join(result)\n\ndef deserialize(data):\n    \"\"\"Xây dựng lại BST từ string\"\"\"\n    def build():\n        val = next(vals)\n        if val == '#':\n            return None\n        \n        node = TreeNode(int(val))\n        node.left = build()\n        node.right = build()\n        return node\n    \n    vals = iter(data.split(','))\n    return build()\n\n# Test\nbst = build_bst_from_array([8, 3, 10, 1, 6, 14])\nserialized = serialize(bst.root)\nprint(\"Serialized:\", serialized)\n\nroot = deserialize(serialized)\nbst2 = BST()\nbst2.root = root\nprint(\"Inorder after deserialize:\", bst2.inorder())\n```\n\n---\n\n### 7. Phân tích độ phức tạp\n\n| Thao tác | Average | Worst | Best |\n|----------|---------|-------|------|\n| Search | O(log n) | O(n) | O(1) |\n| Insert | O(log n) | O(n) | O(1) |\n| Delete | O(log n) | O(n) | O(1) |\n| Find Min/Max | O(log n) | O(n) | O(1) |\n| Inorder | O(n) | O(n) | O(n) |\n| Space | O(n) | O(n) | O(n) |\n\n**Worst case xảy ra khi:** Cây thoái hóa thành linked list (insert các phần tử đã sắp xếp)\n\n```\nCây cân bằng:        Cây thoái hóa:\n      4                   1\n     / \\                   \\\n    2   6                   2\n   / \\ / \\                   \\\n  1  3 5  7                   3\n                               \\\n                                4\nHeight: log n              Height: n\n```\n\n**Giải pháp:** Sử dụng **Self-balancing BST** như AVL Tree, Red-Black Tree\n\n---\n\n### 8. So sánh với các cấu trúc khác\n\n| Cấu trúc | Search | Insert | Delete | Sorted | Space |\n|----------|--------|--------|--------|--------|-------|\n| Array (unsorted) | O(n) | O(1) | O(n) | ❌ | O(n) |\n| Array (sorted) | O(log n) | O(n) | O(n) | ✅ | O(n) |\n| Linked List | O(n) | O(1) | O(n) | ❌ | O(n) |\n| BST | O(log n) | O(log n) | O(log n) | ✅ | O(n) |\n| Hash Table | O(1) | O(1) | O(1) | ❌ | O(n) |\n\n**Khi nào dùng BST?**\n- ✅ Cần duy trì thứ tự sorted\n- ✅ Cần range query (tìm trong khoảng)\n- ✅ Cần tìm successor/predecessor\n- ✅ Dynamic data (thêm/xóa thường xuyên)\n- ✅ Cần kth smallest/largest\n\n**Khi nào không dùng BST?**\n- ❌ Chỉ cần search nhanh → Hash Table\n- ❌ Truy cập theo index → Array\n- ❌ Dữ liệu đã sắp xếp → Sorted Array\n\n---\n\n\n**Các khái niệm quan trọng:**\n- Search là phép toán tìm kiếm một phần tử hoặc giá trị cụ thể trong cấu trúc dữ liệu. Trong Binary Search Tree (BST), phép toán này bắt đầu từ gốc, so sánh giá trị cần tìm với giá trị của node hiện tại. Nếu giá trị cần tìm nhỏ hơn, di chuyển sang cây con trái; nếu lớn hơn, di chuyển sang cây con phải. Nếu bằng, phần tử được tìm thấy. Độ phức tạp thời gian của Search trong BST là O(h), trong đó h là chiều cao của cây. Cụ thể: Best case là O(1) (tìm thấy ở gốc), Average case là O(log n) (đối với cây cân bằng), và Worst case là O(n) (đối với cây thoái hóa). Đối với Min/Max Heap, độ phức tạp của Search là O(n), khiến chúng không hiệu quả cho việc tìm kiếm phần tử cụ thể. Trong Sorted Array, Search có độ phức tạp O(log n) khi sử dụng tìm kiếm nhị phân.\n- Search là phép toán tìm kiếm giá trị liên kết với một khóa cụ thể trong Hash Table (ví dụ: Python Dictionary). Quá trình này bao gồm việc sử dụng hàm băm để tính toán chỉ mục (vị trí ban đầu) và sau đó áp dụng các kỹ thuật giải quyết va chạm (như Linear Probing hoặc Quadratic Probing) để tìm kiếm khóa nếu có va chạm. Nếu tìm thấy khóa, giá trị tương ứng sẽ được trả về; nếu không, một ngoại lệ KeyError sẽ được ném ra. Độ phức tạp thời gian trung bình của phép toán này là O(1), nhưng trong trường hợp xấu nhất, độ phức tạp có thể là O(n).\n\n**Mối quan hệ:**\n- Array (sorted) có độ phức tạp O(log n) cho phép toán Search.\n- Hash Table có độ phức tạp O(1) cho phép toán Search trong trường hợp trung bình.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n    def __init__(self, size=10):\n        self.size = size\n        self.table = [[] for _ in range(size)]\n        self.count = 0\n    \n    def hash_function(self, key):\n        \"\"\"Hash function đơn giản\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def insert(self, key, value):\n        \"\"\"\n        Thêm hoặc cập nhật key-value\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        # Kiểm tra key đã tồn tại chưa\n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                # Update giá trị\n                self.table[index][i] = (key, value)\n                return\n        \n        # Thêm mới\n        self.table[index].append((key, value))\n        self.count += 1\n        \n        # Resize nếu load factor quá cao\n        if self.load_factor() > 0.7:\n            self._resize()\n    \n    def search(self, key):\n        \"\"\"\n        Tìm giá trị theo key\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        for k, v in self.table[index]:\n            if k == key:\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def delete(self, key):\n        \"\"\"\n        Xóa key-value\n        Time: O(1) average, O(n) worst\n        \"\"\"\n        index = self.hash_function(key)\n        \n        for i, (k, v) in enumerate(self.table[index]):\n            if k == key:\n                self.table[index].pop(i)\n                self.count -= 1\n                return v\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def contains(self, key):\n        \"\"\"Kiểm tra key có tồn tại không\"\"\"\n        try:\n            self.search(key)\n            return True\n        except KeyError:\n            return False\n    \n    def load_factor(self):\n        \"\"\"Tính load factor = n / m\"\"\"\n        return self.count / self.size\n    \n    def _resize(self):\n        \"\"\"Tăng kích thước bảng khi load factor cao\"\"\"\n        old_table = self.table\n        self.size *= 2\n        self.table = [[] for _ in range(self.size)]\n        self.count = 0\n        \n        # Rehash tất cả phần tử\n        for bucket in old_table:\n            for key, value in bucket:\n                self.insert(key, value)\n    \n    def __str__(self):\n        result = []\n        for i, bucket in enumerate(self.table):\n            if bucket:\n                result.append(f\"Index {i}: {bucket}\")\n        return \"\n\".join(result) if result else \"Empty hash table\"\n```\n\n#### 2.3. Test Chaining\n\n```python\n# Test\nht = HashTableChaining(size=5)\n\n# Insert\nht.insert(\"apple\", 5)\nht.insert(\"banana\", 3)\nht.insert(\"cherry\", 2)\nht.insert(\"date\", 8)\nht.insert(\"elderberry\", 7)\n\nprint(\"Hash Table:\")\nprint(ht)\nprint(f\"\nLoad factor: {ht.load_factor():.2f}\")\n\n# Search\nprint(f\"\nSearch 'apple': {ht.search('apple')}\")\nprint(f\"Contains 'grape': {ht.contains('grape')}\")\n\n# Update\nht.insert(\"apple\", 10)\nprint(f\"Updated 'apple': {ht.search('apple')}\")\n\n# Delete\nht.delete(\"banana\")\nprint(f\"\nAfter deleting 'banana':\")\nprint(ht)\n```\n\n---\n\n### 3. Open Addressing\n\n#### 3.1. Ý tưởng\n\nKhi collision xảy ra, tìm slot trống khác trong cùng bảng băm bằng **probing**.\n\n**Các phương pháp probing:**\n1. **Linear Probing:** h(k, i) = (h(k) + i) mod m\n2. **Quadratic Probing:** h(k, i) = (h(k) + c₁·i + c₂·i²) mod m\n3. **Double Hashing:** h(k, i) = (h₁(k) + i·h₂(k)) mod m\n\n\n**Các khái niệm quan trọng:**\n- Linear Probing và Quadratic Probing là hai kỹ thuật giải quyết va chạm trong Hash Table, thuộc nhóm phương pháp Open Addressing. Khi một va chạm xảy ra (hai khóa băm về cùng một chỉ mục h(k)), cả hai kỹ thuật này đều tìm kiếm một vị trí trống tiếp theo trong bảng. Linear Probing thực hiện tìm kiếm tuần tự bằng cách tăng chỉ mục theo một bước nhảy tuyến tính: h(k, i) = (h(k) + i) mod m, với i là số lần thăm dò (0, 1, 2,...). Kỹ thuật này có thể dẫn đến hiện tượng \"primary clustering\", làm giảm hiệu suất. Ngược lại, Quadratic Probing tìm kiếm vị trí trống bằng cách tăng chỉ mục theo một hàm bậc hai: h(k, i) = (h(k) + i²) mod m hoặc tổng quát hơn là h(k, i) = (h(k) + c₁·i + c₂·i²) mod m, với c₁ và c₂ là các hằng số và i là số lần thăm dò. Quadratic Probing giúp giảm thiểu primary clustering so với Linear Probing nhưng có thể gây ra \"secondary clustering\" (các khóa có cùng giá trị băm ban đầu sẽ theo cùng một chuỗi thăm dò).\n\n**Mối quan hệ:**\n- HashTableQuadraticProbing sử dụng kỹ thuật Quadratic Probing để giải quyết va chạm.\n\n**Nội dung từ tài liệu:**\n# Cấu trúc dữ liệu và giải thuật\n## Hash Table \n#### 3.2. Linear Probing\n\n```python\nclass HashTableLinearProbing:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [None] * size\n        self.count = 0\n        self.DELETED = \"DELETED\"  # Marker cho phần tử đã xóa\n    \n    def hash_function(self, key):\n        \"\"\"Hash function\"\"\"\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def insert(self, key, value):\n        \"\"\"\n        Thêm key-value với linear probing\n        Time: O(1) average\n        \"\"\"\n        if self.load_factor() >= 0.7:\n            self._resize()\n        \n        index = self.hash_function(key)\n        original_index = index\n        i = 0\n        \n        while self.table[index] is not None:\n            # Nếu key đã tồn tại, update\n            if self.table[index] != self.DELETED and self.table[index][0] == key:\n                self.table[index] = (key, value)\n                return\n            \n            # Linear probing\n            i += 1\n            index = (original_index + i) % self.size\n            \n            # Nếu đã duyệt hết bảng\n            if i >= self.size:\n                raise Exception(\"Hash table is full\")\n        \n        # Tìm được slot trống\n        self.table[index] = (key, value)\n        self.count += 1\n    \n    def search(self, key):\n        \"\"\"\n        Tìm giá trị theo key\n        Time: O(1) average\n        \"\"\"\n        index = self.hash_function(key)\n        original_index = index\n        i = 0\n        \n        while self.table[index] is not None:\n            if self.table[index] != self.DELETED and self.table[index][0] == key:\n                return self.table[index][1]\n            \n            i += 1\n            index = (original_index + i) % self.size\n            \n            if i >= self.size:\n                break\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def delete(self, key):\n        \"\"\"\n        Xóa key-value\n        Đánh dấu DELETED thay vì xóa thật\n        \"\"\"\n        index = self.hash_function(key)\n        original_index = index\n        i = 0\n        \n        while self.table[index] is not None:\n            if self.table[index] != self.DELETED and self.table[index][0] == key:\n                value = self.table[index][1]\n                self.table[index] = self.DELETED\n                self.count -= 1\n                return value\n            \n            i += 1\n            index = (original_index + i) % self.size\n            \n            if i >= self.size:\n                break\n        \n        raise KeyError(f\"Key '{key}' not found\")\n    \n    def load_factor(self):\n        return self.count / self.size\n    \n    def _resize(self):\n        \"\"\"Resize bảng\"\"\"\n        old_table = self.table\n        self.size *= 2\n        self.table = [None] * self.size\n        self.count = 0\n        \n        for item in old_table:\n            if item is not None and item != self.DELETED:\n                self.insert(item[0], item[1])\n    \n    def __str__(self):\n        result = []\n        for i, item in enumerate(self.table):\n            if item is not None and item != self.DELETED:\n                result.append(f\"Index {i}: {item}\")\n        return \"\n\".join(result) if result else \"Empty hash table\"\n```\n\n#### 3.3. Quadratic Probing\n\n```python\nclass HashTableQuadraticProbing:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [None] * size\n        self.count = 0\n    \n    def hash_function(self, key):\n        if isinstance(key, str):\n            hash_value = 0\n            for char in key:\n                hash_value = (hash_value * 31 + ord(char)) % self.size\n            return hash_value\n        return key % self.size\n    \n    def insert(self, key, value):\n        \"\"\"\n        Quadratic probing: h(k, i) = (h(k) + i²) mod m\n        \"\"\"\n        index = self.hash_function(key)\n        original_index = index\n        i = 0\n        \n        while self.table[index] is not None:\n\n**Các khái niệm quan trọng:**\n- Linear Probing và Quadratic Probing là hai kỹ thuật giải quyết va chạm trong Hash Table, thuộc nhóm phương pháp Open Addressing. Khi một va chạm xảy ra (hai khóa băm về cùng một chỉ mục h(k)), cả hai kỹ thuật này đều tìm kiếm một vị trí trống tiếp theo trong bảng. Linear Probing thực hiện tìm kiếm tuần tự bằng cách tăng chỉ mục theo một bước nhảy tuyến tính: h(k, i) = (h(k) + i) mod m, với i là số lần thăm dò (0, 1, 2,...). Kỹ thuật này có thể dẫn đến hiện tượng \"primary clustering\", làm giảm hiệu suất. Ngược lại, Quadratic Probing tìm kiếm vị trí trống bằng cách tăng chỉ mục theo một hàm bậc hai: h(k, i) = (h(k) + i²) mod m hoặc tổng quát hơn là h(k, i) = (h(k) + c₁·i + c₂·i²) mod m, với c₁ và c₂ là các hằng số và i là số lần thăm dò. Quadratic Probing giúp giảm thiểu primary clustering so với Linear Probing nhưng có thể gây ra \"secondary clustering\" (các khóa có cùng giá trị băm ban đầu sẽ theo cùng một chuỗi thăm dò).\n\n**Mối quan hệ:**\n- HashTableQuadraticProbing sử dụng kỹ thuật Quadratic Probing để giải quyết va chạm."
        },
        "output_without_context": {
            "question": "So sánh hiệu suất của bảng băm và cây tìm kiếm cân bằng trong việc xử lý các thao tác tìm kiếm và chèn, phương pháp nào thường cho hiệu suất tốt hơn trong trường hợp có nhiều xung đột dữ liệu?",
            "answer": "Cây tìm kiếm cân bằng"
        }
    }
]